diff -urN miniupnpd-clean/getifaddr.c miniupnpd-pfsense2/getifaddr.c
--- miniupnpd-clean/getifaddr.c	Thu Jul 13 18:03:57 2006
+++ miniupnpd-pfsense2/getifaddr.c	Tue Aug 22 23:14:37 2006
@@ -13,15 +13,16 @@
 #include <net/if.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
-
+  
 int
-getifaddr(const char * ifname, char * buf, int len)
+getifaddr(const char * ifname, char * buf, int len, const char * use_ext_ip_addr)
 {
 	//  SIOCGIFADDR struct ifreq *
 	int s;
 	struct ifreq ifr;
 	int ifrlen;
 	struct sockaddr_in * addr;
+	struct in_addr in_addr_struct, *ina;
 	ifrlen = sizeof(ifr);
 	s = socket(PF_INET, SOCK_DGRAM, 0);
 	if(s<0)
@@ -36,8 +37,15 @@
 		close(s);
 		return -1;
 	}
-	addr = (struct sockaddr_in *)&ifr.ifr_addr;
-	if(!inet_ntop(AF_INET, &addr->sin_addr, buf, len))
+	if(use_ext_ip_addr != NULL)  {
+		inet_aton(use_ext_ip_addr, &in_addr_struct);
+		ina = &in_addr_struct;
+		syslog(LOG_ERR, "using external ip address %s", use_ext_ip_addr);
+	} else {
+		addr = (struct sockaddr_in *)&ifr.ifr_addr;
+		ina = &addr->sin_addr;
+	}
+	if(!inet_ntop(AF_INET, ina, buf, len))
 	{
 		syslog(LOG_ERR, "inet_ntop FAILED");
 		close(s);
diff -urN miniupnpd-clean/getifaddr.h miniupnpd-pfsense2/getifaddr.h
--- miniupnpd-clean/getifaddr.h	Thu May 25 17:47:43 2006
+++ miniupnpd-pfsense2/getifaddr.h	Tue Aug 22 23:14:37 2006
@@ -3,7 +3,7 @@
 #define __GETIFADDR_H__
 
 int
-getifaddr(const char * ifname, char * buf, int len);
+getifaddr(const char * ifname, char * buf, int len, const char * use_ext_ip_addr);
 
 #endif
 
diff -urN miniupnpd-clean/miniupnpd.c miniupnpd-pfsense2/miniupnpd.c
--- miniupnpd-clean/miniupnpd.c	Fri Aug 18 18:32:27 2006
+++ miniupnpd-pfsense2/miniupnpd.c	Thu Aug 24 13:11:37 2006
@@ -54,7 +54,7 @@
     memset(&sockname, 0, sizeof(struct sockaddr_in));
     sockname.sin_family = AF_INET;
     sockname.sin_port = htons(PORT);
-	// NOTE : it seams it doesnt work when binding on the specific address
+	// NOTE : it seems it doesnt work when binding on the specific address
     //sockname.sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);
     sockname.sin_addr.s_addr = htonl(INADDR_ANY);
     //sockname.sin_addr.s_addr = inet_addr(ifaddr);
@@ -128,7 +128,7 @@
 		"Cache-Control: max-age=120\r\n"
 		//"ST: urn:schemas-upnp-org:device:InternetGatewayDevice:1\r\n"
 		"ST: upnp:rootdevice\r\n"
-		//"USN: uuid:nanard-upnp-device::urn:schemas-upnp-org:service:WANIPConnection:1\r\n"
+		//"USN: uuid:pfsense-upnp-device::urn:schemas-upnp-org:service:WANIPConnection:1\r\n"
 		"USN: uuid:00000000-0000-0000-0000-000000000000::upnp:rootdevice\r\n"
 		"EXT:\r\n"
 		"Server: miniupnpd/1.0\r\n"
@@ -193,7 +193,7 @@
 }
 
 const char * ext_if_name = 0;
-//const char * ext_ip_addr = 0;
+const char * use_ext_ip_addr;
 char ext_ip_addr[INET_ADDRSTRLEN];
 
 /* === main === */
@@ -226,6 +226,9 @@
 		case 'i':
 			ext_if_name = argv[++i];
 			break;
+		case 'o':
+			use_ext_ip_addr = argv[++i];
+			break;
 		case 'p':
 			port = atoi(argv[++i]);
 			break;
@@ -250,8 +253,8 @@
 	if(!ext_if_name || !listen_addr || port<=0)
 	{
 		fprintf(stderr, "Usage:\n\t"
-		        "%s -i ext_ifname -a listening_ip -p port [-l logfile]\n"
-		        "\nNote:\n\tThere can be one or several litening_ips\n",
+		        "%s -i ext_ifname -a listening_ip -p port [-o outside_ip] [-l logfile]\n"
+		        "\nNote:\n\tThere can be one or several listening_ips\n",
 		        argv[0]);
 		return 1;
 	}
@@ -265,7 +268,7 @@
 	// TODO : change LOG_LOCAL0 to LOG_DAEMON
 	openlog("miniupnpd", LOG_PID|LOG_CONS, LOG_LOCAL6/*LOG_LOCAL0*/);
 	//ext_if_name = argv[1];
-	if(getifaddr(ext_if_name, ext_ip_addr, sizeof(ext_ip_addr)) < 0)
+	if(getifaddr(ext_if_name, ext_ip_addr, sizeof(ext_ip_addr), use_ext_ip_addr) < 0)
 	{
 		syslog(LOG_ERR, "could not get ip address for interface %s. EXITING",
 			ext_if_name);
@@ -335,9 +338,9 @@
 			}
 			else
 			{
-				syslog(LOG_INFO, "HTTP connection from %s:%d",
+				/* syslog(LOG_INFO, "HTTP connection from %s:%d",
 				       inet_ntoa(clientname.sin_addr),
-				   	   ntohs(clientname.sin_port) );
+				   	   ntohs(clientname.sin_port) ); */
 				if (fcntl(shttp, F_SETFL, O_NONBLOCK) < 0) {
 					syslog(LOG_ERR, "fcntl F_SETFL, O_NONBLOCK");
 				}
diff -urN miniupnpd-clean/openbsd/obsdrdr.c miniupnpd-pfsense2/openbsd/obsdrdr.c
--- miniupnpd-clean/openbsd/obsdrdr.c	Mon Jun  5 11:13:53 2006
+++ miniupnpd-pfsense2/openbsd/obsdrdr.c	Thu Aug 24 13:10:20 2006
@@ -161,7 +161,7 @@
 
 int
 add_redirect_rule2(const char * ifname, unsigned short eport,
-                   const char * iaddr, unsigned short iport, int proto)
+                   const char * iaddr, unsigned short iport, int proto, const char * desc)
 {
 	int dev;
 	int r;
@@ -203,6 +203,92 @@
 		inet_pton(AF_INET, iaddr, &a->addr.v.a.addr.v4.s_addr);
 		a->addr.v.a.mask.v4.s_addr = htonl(INADDR_NONE);
 		TAILQ_INSERT_TAIL(&pcr.rule.rpool.list, a, entries);
+		memcpy(&pp.addr, a, sizeof(struct pf_pooladdr));
+		strlcpy(pcr.rule.label, desc, MAXPATHLEN);
+
+		if(ioctl(dev, DIOCADDADDR, &pp) < 0)
+		{
+			syslog(LOG_ERR, "ioctl(dev, DIOCADDADDR, ...): %m");
+			r = -1;
+		}
+		else
+		{
+			pcr.action = PF_CHANGE_GET_TICKET;
+        	if(ioctl(dev, DIOCCHANGERULE, &pcr) < 0)
+			{
+            	syslog(LOG_ERR, "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_GET_TICKET: %m");
+				r = -1;
+			}
+			else
+			{
+				pcr.action = PF_CHANGE_ADD_TAIL;
+				if(ioctl(dev, DIOCCHANGERULE, &pcr) < 0)
+				{
+					syslog(LOG_ERR, "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_ADD_TAIL: %m");
+					r = -1;
+				}
+			}
+		}
+		free(a);
+	}
+	close(dev);
+	return r;
+}
+
+int
+add_filter_rule2(const char * ifname, const char * iaddr, 
+		unsigned short eport, int proto, const char * desc)
+{
+	int dev;
+	int r;
+	struct pfioc_rule pcr;
+	struct pfioc_pooladdr pp;
+	struct pf_pooladdr *a;
+	dev = open("/dev/pf", O_RDWR);
+	if(dev<0)
+	{
+		syslog(LOG_ERR, "open(\"/dev/pf\"): %m");
+		return -1;
+	}
+	r = 0;
+	memset(&pcr, 0, sizeof(pcr));
+	strlcpy(pcr.anchor, anchor_name, MAXPATHLEN);
+
+	memset(&pp, 0, sizeof(pp));
+	strlcpy(pp.anchor, anchor_name, MAXPATHLEN);
+	if(ioctl(dev, DIOCBEGINADDRS, &pp) < 0)
+	{
+		syslog(LOG_ERR, "ioctl(dev, DIOCBEGINADDRS, ...): %m");
+		r = -1;
+	}
+	else
+	{
+		pcr.pool_ticket = pp.ticket;
+		
+		pcr.rule.dst.port_op = PF_OP_EQ;
+		pcr.rule.dst.port[0] = htons(eport);
+		pcr.rule.direction = PF_IN;
+		pcr.rule.action = PF_PASS;
+		pcr.rule.af = AF_INET;
+		strlcpy(pcr.rule.ifname, ifname, IFNAMSIZ);
+		pcr.rule.proto = proto;
+                pcr.rule.quick = 1;
+                pcr.rule.log = 1;
+                pcr.rule.keep_state = 1;
+		strlcpy(pcr.rule.label, desc, MAXPATHLEN);
+
+		pcr.rule.rpool.proxy_port[0] = eport;
+		a = calloc(1, sizeof(struct pf_pooladdr));
+		inet_pton(AF_INET, iaddr, &a->addr.v.a.addr.v4.s_addr);
+		a->addr.v.a.mask.v4.s_addr = htonl(INADDR_NONE);
+		memcpy(&pp.addr, a, sizeof(struct pf_pooladdr));
+		TAILQ_INIT(&pcr.rule.rpool.list);
+		inet_pton(AF_INET, iaddr, &a->addr.v.a.addr.v4.s_addr);
+		TAILQ_INSERT_TAIL(&pcr.rule.rpool.list, a, entries);
+		
+		/* we have any - any port = # keep state label */
+		/* we want any - iaddr port = # keep state label */
+		/* memcpy(&pcr.rule.dst, a, sizeof(struct pf_pooladdr)); */
 
 		memcpy(&pp.addr, a, sizeof(struct pf_pooladdr));
 		if(ioctl(dev, DIOCADDADDR, &pp) < 0)
@@ -336,6 +422,61 @@
 		}
 		if( (eport == ntohs(pr.rule.dst.port[0]))
 		  && (eport == ntohs(pr.rule.dst.port[1]))
+		  && (pr.rule.proto == proto) )
+		{
+		pr.action = PF_CHANGE_GET_TICKET;
+        	if(ioctl(dev, DIOCCHANGERULE, &pr) < 0)
+			{
+            	syslog(LOG_ERR, "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_GET_TICKET: %m");
+				goto error;
+			}
+			pr.action = PF_CHANGE_REMOVE;
+			pr.nr = i;
+			if(ioctl(dev, DIOCCHANGERULE, &pr) < 0)
+			{
+				syslog(LOG_ERR, "ioctl(dev, DIOCCHANGERULE, ...) PF_CHANGE_REMOVE: %m");
+				goto error;
+			}
+			close(dev);
+			return 0;
+		}
+	}
+error:
+	close(dev);
+	return -1;
+}
+
+
+int
+delete_filter_rule(const char * ifname, unsigned short eport, int proto)
+{
+	int dev;
+	int i, n;
+	struct pfioc_rule pr;
+    dev = open("/dev/pf", O_RDWR);
+    if(dev<0)
+    {
+        syslog(LOG_ERR, "open(\"/dev/pf\"): %m");
+        return -1;
+    }
+	memset(&pr, 0, sizeof(pr));
+	strlcpy(pr.anchor, anchor_name, MAXPATHLEN);
+	pr.rule.action = PF_PASS;
+	if(ioctl(dev, DIOCGETRULES, &pr) < 0)
+	{
+		syslog(LOG_ERR, "ioctl(dev, DIOCGETRULES, ...): %m");
+		goto error;
+	}
+	n = pr.nr;
+	for(i=0; i<n; i++)
+	{
+		pr.nr = i;
+		if(ioctl(dev, DIOCGETRULE, &pr) < 0)
+		{
+			syslog(LOG_ERR, "ioctl(dev, DIOCGETRULE): %m");
+			goto error;
+		}
+		if( (eport == ntohs(pr.rule.dst.port[0]))
 		  && (pr.rule.proto == proto) )
 		{
 			pr.action = PF_CHANGE_GET_TICKET;
diff -urN miniupnpd-clean/openbsd/obsdrdr.h miniupnpd-pfsense2/openbsd/obsdrdr.h
--- miniupnpd-clean/openbsd/obsdrdr.h	Mon Jun  5 11:13:54 2006
+++ miniupnpd-pfsense2/openbsd/obsdrdr.h	Tue Aug 22 23:08:51 2006
@@ -17,7 +17,14 @@
  */
 int
 add_redirect_rule2(const char * ifname, unsigned short eport,
-                   const char * iaddr, unsigned short iport, int proto);
+                   const char * iaddr, unsigned short iport, int proto, const char * desc);
+
+/* add_filter_rule2() uses DIOCCHANGERULE ioctl
+ * proto can take the values IPPROTO_UDP or IPPROTO_TCP
+ */
+int
+add_filter_rule2(const char * ifname, const char * iaddr,
+                    unsigned short eport, int proto, const char * desc);
 
 /* get_redirect_rule() gets internal IP and port from
  * interface, external port and protocl
@@ -37,6 +44,10 @@
 int
 delete_redirect_rule(const char * ifname, unsigned short eport, int proto);
 
+/* delete_filter_rule()
+ */
+int
+delete_filter_rule(const char * ifname, unsigned short eport, int proto);
 
 int
 clear_redirect_rules(void);
diff -urN miniupnpd-clean/upnpdescgen.c miniupnpd-pfsense2/upnpdescgen.c
--- miniupnpd-clean/upnpdescgen.c	Thu Jul 13 18:03:57 2006
+++ miniupnpd-pfsense2/upnpdescgen.c	Tue Aug 22 23:08:51 2006
@@ -27,23 +27,23 @@
 	{"/major", {"1"}},
 	{"/minor", {"0"}},
 	{"/deviceType", {"urn:schemas-upnp-org:device:InternetGatewayDevice:1"}},
-	{"/friendlyName", {"OpenBSD router"}},
-	{"/manufacturer", {"OpenBSD"}},
-	{"/manufacturerURL", {"http://www.openbsd.org/"}},
+	{"/friendlyName", {"pfSense router"}},
+	{"/manufacturer", {"pfSense"}},
+	{"/manufacturerURL", {"http://www.pfsense.com/"}},
 	// presentationURL
-	{"/modelName", {"OpenBSD router"}},
+	{"/modelName", {"pfSense router"}},
 	{"/UDN", {(char *)uuid}},
 	{"serviceList", {INITHELPER(52,1)}},
 	{"deviceList", {INITHELPER(13,1)}},
 	{"device", {INITHELPER(14,13)}},
 	{"/deviceType", {"urn:schemas-upnp-org:device:WANDevice:1"}},
 	{"/friendlyName", {"WANDevice"}},
-	{"/manufacturer", {"nanard"}},
-	{"/manufacturerURL", {"http://miniupnp.free.fr/"}},
+	{"/manufacturer", {"pfSense"}},
+	{"/manufacturerURL", {"http://www.pfSense.com/"}},
 	{"/modelDescription" , {"WAN Device"}},
 	{"/modelName", {"WAN Device"}},
 	{"/modelNumber", {"1"}},
-	{"/modelURL", {"http://miniupnp.free.fr/"}},
+	{"/modelURL", {"http://www.pfsense.com/"}},
 	{"/serialNumber", {"00000000"}},
 	{"/UDN", {(char *)uuid}},
 	{"/UPC", {"MINIUPNPD"}},
@@ -59,12 +59,12 @@
 	{"device", {INITHELPER(34,12)}},
 	{"/deviceType", {"urn:schemas-upnp-org:device:WANConnectionDevice:1"}},
 	{"/friendlyName", {"WANConnectionDevice"}},
-	{"/manufacturer", {"nanard"}},
-	{"/manufacturerURL", {"http://miniupnp.free.fr/"}},
+	{"/manufacturer", {"pfSense"}},
+	{"/manufacturerURL", {"http://www.pfsense.com/"}},
 	{"/modelDescription", {"miniupnp daemon"}},
 	{"/modelName", {"miniupnpd"}},
 	{"/modelNumber", {"1"}},
-	{"/modelURL", {"http://miniupnp.free.fr/"}},
+	{"/modelURL", {"http://www.pfsense.com/"}},
 	{"/serialNumber", {"000000000"}},
 	{"/UDN", {(char *)uuid}},
 	{"/UPC", {"MINIUPNPD"}},
diff -urN miniupnpd-clean/upnpredirect.c miniupnpd-pfsense2/upnpredirect.c
--- miniupnpd-clean/upnpredirect.c	Thu Jul 13 18:03:57 2006
+++ miniupnpd-pfsense2/upnpredirect.c	Thu Aug 24 13:13:47 2006
@@ -37,15 +37,18 @@
 	                      iaddr_old, sizeof(iaddr_old), &iport_old);
 	if(r==0)
 	{
-		syslog(LOG_INFO, "port %d protocol %s allready redirected to %s:%d",
+		syslog(LOG_INFO, "Port %d protocol %s allready redirected to %s:%d",
 	    	             (int)eport, protocol, iaddr_old, (int)iport_old);
 		return -1;
 	}
 	else
 	{
-		syslog(LOG_INFO, "redirecting port %d to %s:%d protocol %s",
-	    	             (int)eport, iaddr, (int)iport, protocol);
-		add_redirect_rule2(ext_if_name, eport, iaddr, iport, proto);
+		/* syslog(LOG_INFO, "redirecting port %d to %s:%d protocol %s for: %s",
+	    	             (int)eport, iaddr, (int)iport, protocol, desc); */
+		add_redirect_rule2(ext_if_name, eport, iaddr, iport, proto, desc);
+		/* syslog(LOG_INFO, "create pass rule to %s:%d protocol %s for: %s",
+	    	             iaddr, (int)iport, protocol, desc); */
+		add_filter_rule2(ext_if_name, iaddr, eport, proto, desc);
 	}
 
 	return 0;
@@ -92,6 +95,7 @@
 	int proto;
 	proto = proto_atoi(protocol);
 	delete_redirect_rule(ext_if_name, eport, proto);
+	delete_filter_rule(ext_if_name, eport, proto);
 	return 0;
 }
 
diff -urN miniupnpd-clean/upnpsoap.c miniupnpd-pfsense2/upnpsoap.c
--- miniupnpd-clean/upnpsoap.c	Thu Jul 20 00:48:46 2006
+++ miniupnpd-pfsense2/upnpsoap.c	Tue Aug 22 23:08:51 2006
@@ -211,7 +211,7 @@
 	ext_port = GetValueFromNameValueList(&data, "NewExternalPort");
 	protocol = GetValueFromNameValueList(&data, "NewProtocol");
 	desc = GetValueFromNameValueList(&data, "NewPortMappingDescription");
-	syslog(LOG_INFO, "AddportMapping %s, description : %s", protocol, desc);
+	syslog(LOG_INFO, "AddportMapping %s, for %s, port %s, description : %s", protocol, int_ip, int_port, desc);
 	eport = (unsigned short)atoi(ext_port);
 	iport = (unsigned short)atoi(int_port);
 	r = upnp_redirect(eport, int_ip, iport, protocol, desc);
@@ -455,7 +455,7 @@
 		}
 	}
 	//printf("-- unknown soap method--\n");
-	syslog(LOG_NOTICE, "Unknown soap method");
+	syslog(LOG_NOTICE, "Unknown soap method: %s", action);
 	// TODO response
 	CloseSocket_upnphttp(h);
 }
