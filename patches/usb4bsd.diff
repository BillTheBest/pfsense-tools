Index: etc/mtree/BSD.include.dist
===================================================================
RCS file: /home/ncvs/src/etc/mtree/BSD.include.dist,v
retrieving revision 1.100.2.2
diff -u -r1.100.2.2 BSD.include.dist
--- etc/mtree/BSD.include.dist	16 Nov 2005 10:50:10 -0000	1.100.2.2
+++ etc/mtree/BSD.include.dist	8 Jun 2006 18:28:30 -0000
@@ -32,6 +32,8 @@
     crypto
     ..
     dev
+	usb2
+	..
         acpica
         ..
         an
Index: include/Makefile
===================================================================
RCS file: /home/ncvs/src/include/Makefile,v
retrieving revision 1.244.2.2
diff -u -r1.244.2.2 Makefile
--- include/Makefile	16 Nov 2005 10:50:09 -0000	1.244.2.2
+++ include/Makefile	8 Jun 2006 18:28:30 -0000
@@ -38,7 +38,7 @@
 LSUBDIRS=	cam/scsi \
 	dev/acpica dev/an dev/bktr dev/firewire dev/hwpmc \
 	dev/ic dev/iicbus ${_dev_ieee488} dev/ofw \
-	dev/pbio dev/ppbus dev/smbus dev/speaker dev/usb dev/wi dev/utopia \
+	dev/pbio dev/ppbus dev/smbus dev/speaker dev/usb dev/usb2 dev/wi dev/utopia \
 	fs/devfs fs/fdescfs fs/fifofs fs/msdosfs fs/ntfs fs/nullfs \
 	fs/nwfs fs/portalfs fs/procfs fs/smbfs fs/udf fs/umapfs \
 	fs/unionfs \
Index: sys/conf/files
===================================================================
RCS file: /home/ncvs/src/sys/conf/files,v
retrieving revision 1.1031.2.28.2.1
diff -u -r1.1031.2.28.2.1 files
--- sys/conf/files	12 Apr 2006 18:09:27 -0000	1.1031.2.28.2.1
+++ sys/conf/files	8 Jun 2006 18:28:29 -0000
@@ -72,12 +72,12 @@
 	clean		"pccarddevs.h"
 usbdevs.h			optional usb				   \
 	dependency	"$S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
-	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs -h" \
+	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
 	no-obj no-implicit-rule before-depend				   \
 	clean		"usbdevs.h"
 usbdevs_data.h			optional usb				   \
 	dependency	"$S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
-	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs -d" \
+	compile-with	"${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" \
 	no-obj no-implicit-rule before-depend				   \
 	clean		"usbdevs_data.h"
 cam/cam.c			optional scbus
@@ -908,8 +908,6 @@
 dev/ubsec/ubsec.c		optional ubsec
 #
 # USB support
-dev/usb/ehci.c			optional ehci
-dev/usb/ehci_pci.c		optional ehci pci
 dev/usb/hid.c			optional usb
 dev/usb/if_aue.c		optional aue
 dev/usb/if_axe.c		optional axe
@@ -919,8 +917,6 @@
 dev/usb/if_ural.c		optional ural
 dev/usb/if_rue.c		optional rue
 dev/usb/if_udav.c		optional udav
-dev/usb/ohci.c			optional ohci
-dev/usb/ohci_pci.c		optional ohci pci
 dev/usb/ubsa.c			optional ubsa ucom
 dev/usb/ubser.c			optional ubser
 dev/usb/ucom.c			optional ucom
@@ -928,11 +924,7 @@
 dev/usb/udbp.c			optional udbp
 dev/usb/ufm.c			optional ufm
 dev/usb/uftdi.c			optional uftdi ucom
-dev/usb/ugen.c			optional ugen
-dev/usb/uhci.c			optional uhci
-dev/usb/uhci_pci.c		optional uhci pci
 dev/usb/uhid.c			optional uhid
-dev/usb/uhub.c			optional usb
 dev/usb/ukbd.c			optional ukbd
 dev/usb/ulpt.c			optional ulpt
 dev/usb/umass.c			optional umass
@@ -941,14 +933,9 @@
 dev/usb/ums.c			optional ums
 dev/usb/uplcom.c		optional uplcom ucom
 dev/usb/urio.c			optional urio
-dev/usb/usb.c			optional usb
 dev/usb/usb_ethersubr.c		optional usb
 dev/usb/usb_if.m		optional usb
-dev/usb/usb_mem.c		optional usb
 dev/usb/usb_quirks.c		optional usb
-dev/usb/usb_subr.c		optional usb
-dev/usb/usbdi.c			optional usb
-dev/usb/usbdi_util.c		optional usb
 dev/usb/uscanner.c		optional uscanner
 dev/usb/uvisor.c		optional uvisor ucom
 dev/usb/uvscom.c		optional uvscom ucom
@@ -1856,3 +1843,23 @@
 vm/vm_unix.c			standard
 vm/vm_zeroidle.c		standard
 vm/vnode_pager.c		standard
+ 
+#  
+# USB support  
+dev/usb2/_uhci.c            optional usb  
+dev/usb2/_uhci_pci.c        optional usb  
+dev/usb2/_uhci.c            optional uhci  
+dev/usb2/_uhci_pci.c        optional uhci  
+dev/usb2/_ohci.c            optional usb  
+dev/usb2/_ohci_pci.c        optional usb  
+dev/usb2/_ohci.c            optional ohci  
+dev/usb2/_ohci_pci.c        optional ohci  
+dev/usb2/_ehci.c            optional ehci  
+dev/usb2/_ehci_pci.c        optional ehci  
+dev/usb2/_uhub.c            optional usb  
+dev/usb2/_usb.c             optional usb  
+dev/usb2/_usb_requests.c    optional usb  
+dev/usb2/_usb_subr.c        optional usb  
+dev/usb2/_usb_transfer.c    optional usb  
+dev/usb2/_ugen.c            optional ugen  
+usbdevs.h                   optional usb dependency "$S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" compile-with "${AWK} -f $S/tools/usbdevs2h.awk $S/dev/usb/usbdevs" no-obj no-implicit-rule before-depend clean "usbdevs.h"  
Index: sys/conf/kmod.mk
===================================================================
RCS file: /home/ncvs/src/sys/conf/kmod.mk,v
retrieving revision 1.192.2.4
diff -u -r1.192.2.4 kmod.mk
--- sys/conf/kmod.mk	23 Feb 2006 02:13:31 -0000	1.192.2.4
+++ sys/conf/kmod.mk	8 Jun 2006 18:28:30 -0000
@@ -402,7 +402,7 @@
 .else
 usbdevs.h: @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
-	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs -h
+	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
 
 .if ${SRCS:Musbdevs_data.h} != ""
@@ -412,7 +412,7 @@
 .else
 usbdevs_data.h: @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
-	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs -d
+	${AWK} -f @/tools/usbdevs2h.awk @/dev/usb/usbdevs
 .endif
 
 .if ${SRCS:Macpi_quirks.h} != ""
Index: sys/dev/sound/usb/uaudio.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/sound/usb/uaudio.c,v
retrieving revision 1.14.2.2
diff -u -r1.14.2.2 uaudio.c
--- sys/dev/sound/usb/uaudio.c	4 Apr 2006 17:34:10 -0000	1.14.2.2
+++ sys/dev/sound/usb/uaudio.c	8 Jun 2006 18:32:54 -0000
@@ -3742,9 +3742,6 @@
 	int i, j, enc;
 	int samples_per_frame, sample_size;
 
-	if ((sc->sc_playchan.pipe != NULL) || (sc->sc_recchan.pipe != NULL))
-		return (-1);
-
 	switch(ch->format & 0x000FFFFF) {
 	case AFMT_U8:
 		enc = AUDIO_ENCODING_ULINEAR_LE;
Index: sys/dev/usb/hid.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/hid.c,v
retrieving revision 1.25.2.1
diff -u -r1.25.2.1 hid.c
--- sys/dev/usb/hid.c	25 Mar 2006 04:46:52 -0000	1.25.2.1
+++ sys/dev/usb/hid.c	8 Jun 2006 18:28:30 -0000
@@ -55,7 +55,6 @@
 #ifdef USB_DEBUG
 #define DPRINTF(x)	if (usbdebug) logprintf x
 #define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
-extern int usbdebug;
 #else
 #define DPRINTF(x)
 #define DPRINTFN(n,x)
Index: sys/dev/usb/if_ural.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/if_ural.c,v
retrieving revision 1.10.2.7
diff -u -r1.10.2.7 if_ural.c
--- sys/dev/usb/if_ural.c	3 Apr 2006 17:18:22 -0000	1.10.2.7
+++ sys/dev/usb/if_ural.c	8 Jun 2006 18:28:30 -0000
@@ -37,11 +37,6 @@
 #include <sys/bus.h>
 #include <sys/endian.h>
 
-#include <machine/bus.h>
-#include <machine/resource.h>
-#include <machine/clock.h>
-#include <sys/rman.h>
-
 #include <net/bpf.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -808,8 +803,12 @@
 ural_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
 {
 	struct ural_softc *sc = ic->ic_ifp->if_softc;
-
+#if 0
 	usb_rem_task(sc->sc_udev, &sc->sc_task);
+#else
+	printf("%s: cannot call usb_rem_task here, "
+	       "because it can sleep! (fixme)\n", __FUNCTION__);
+#endif
 	callout_stop(&sc->scan_ch);
 	callout_stop(&sc->amrr_ch);
 
Index: sys/dev/usb/ucycom.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/ucycom.c,v
retrieving revision 1.3
diff -u -r1.3 ucycom.c
--- sys/dev/usb/ucycom.c	12 Oct 2004 09:21:03 -0000	1.3
+++ sys/dev/usb/ucycom.c	8 Jun 2006 18:28:30 -0000
@@ -46,6 +46,7 @@
 #include <sys/conf.h>
 #include <sys/kernel.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/sysctl.h>
 #include <sys/bus.h>
 #include <sys/tty.h>
Index: sys/dev/usb/udbp.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/udbp.c,v
retrieving revision 1.29
diff -u -r1.29 udbp.c
--- sys/dev/usb/udbp.c	6 Jan 2005 01:43:28 -0000	1.29
+++ sys/dev/usb/udbp.c	8 Jun 2006 18:28:30 -0000
@@ -91,7 +91,6 @@
 #include <sys/errno.h>
 #include <sys/sysctl.h>
 #include <net/if.h>
-#include <machine/bus.h>
 
 #include <dev/usb/usb.h>
 #include <dev/usb/usbdi.h>
Index: sys/dev/usb/ukbd.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/ukbd.c,v
retrieving revision 1.52.2.1
diff -u -r1.52.2.1 ukbd.c
--- sys/dev/usb/ukbd.c	1 Mar 2006 02:34:16 -0000	1.52.2.1
+++ sys/dev/usb/ukbd.c	8 Jun 2006 18:33:19 -0000
@@ -53,6 +53,7 @@
 #include <sys/kernel.h>
 #include <sys/ioccom.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/bus.h>
 #include <sys/file.h>
 #if __FreeBSD_version >= 500000
@@ -237,7 +238,7 @@
 {
 	keyboard_t *kbd = (keyboard_t *)addr;
 
-	(*kbdsw[kbd->kb_index]->intr)(kbd, (void *)status);
+	(*kbdsw[kbd->kb_index]->intr)(kbd, ((u_int8_t *)0) + status);
 }
 
 DRIVER_MODULE(ukbd, uhub, ukbd_driver, ukbd_devclass, ukbd_driver_load, 0);
@@ -683,7 +684,7 @@
 	kbd = (keyboard_t *)arg;
 	state = (ukbd_state_t *)kbd->kb_data;
 	s = splusb();
-	(*kbdsw[kbd->kb_index]->intr)(kbd, (void *)USBD_NORMAL_COMPLETION);
+	(*kbdsw[kbd->kb_index]->intr)(kbd, ((u_int8_t *)0) + USBD_NORMAL_COMPLETION);
 	usb_callout(state->ks_timeout_handle, hz / 40, ukbd_timeout, arg);
 	splx(s);
 }
@@ -691,7 +692,7 @@
 Static int
 ukbd_interrupt(keyboard_t *kbd, void *arg)
 {
-	usbd_status status = (usbd_status)arg;
+	usbd_status status = ((u_int8_t *)arg) - ((u_int8_t *)0);
 	ukbd_state_t *state;
 	struct ukbd_data *ud;
 	struct timeval tv;
Index: sys/dev/usb/umass.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/umass.c,v
retrieving revision 1.122.2.8
diff -u -r1.122.2.8 umass.c
--- sys/dev/usb/umass.c	24 Mar 2006 21:42:02 -0000	1.122.2.8
+++ sys/dev/usb/umass.c	8 Jun 2006 18:33:56 -0000
@@ -110,6 +110,7 @@
 #include <sys/systm.h>
 #include <sys/kernel.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/bus.h>
 #include <sys/sysctl.h>
 
@@ -1237,6 +1238,9 @@
 	usbd_status err;
 
 	/* Initialise a USB transfer and then schedule it */
+#ifdef USBD_CUSTOM_CLEARSTALL
+	flags |= USBD_CUSTOM_CLEARSTALL;
+#endif
 
 	(void) usbd_setup_xfer(xfer, pipe, (void *) sc, buffer, buflen, flags,
 			sc->timeout, sc->state);
@@ -1614,6 +1618,8 @@
 			next_xfer = sc->transfer_xfer[XFER_BBB_CSW2];
 		}
 
+		sc->timeout = 1000;
+
 		/* Read the Command Status Wrapper via bulk-in endpoint. */
 		if (umass_setup_transfer(sc, sc->bulkin_pipe,
 				&sc->csw, UMASS_BBB_CSW_SIZE, 0,
Index: sys/dev/usb/umodem.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/umodem.c,v
retrieving revision 1.57
diff -u -r1.57 umodem.c
--- sys/dev/usb/umodem.c	31 Jan 2005 13:58:10 -0000	1.57
+++ sys/dev/usb/umodem.c	8 Jun 2006 18:28:30 -0000
@@ -83,6 +83,7 @@
 #include <sys/systm.h>
 #include <sys/kernel.h>
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/ioccom.h>
 #include <sys/conf.h>
 #include <sys/serial.h>
Index: sys/dev/usb/ums.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/ums.c,v
retrieving revision 1.77.2.2
diff -u -r1.77.2.2 ums.c
--- sys/dev/usb/ums.c	6 Feb 2006 20:29:17 -0000	1.77.2.2
+++ sys/dev/usb/ums.c	8 Jun 2006 18:28:30 -0000
@@ -596,10 +596,12 @@
 	sc->status.dx = sc->status.dy = sc->status.dz /* = sc->status.dt */ = 0;
 
 	callout_handle_init((struct callout_handle *)&sc->callout_handle);
-
+#ifndef USBD_CUSTOM_CLEARSTALL
+#define USBD_CUSTOM_CLEARSTALL 0
+#endif
 	/* Set up interrupt pipe. */
 	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr,
-				USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
+				USBD_CUSTOM_CLEARSTALL|USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
 				sc->sc_ibuf, sc->sc_isize, ums_intr,
 				USBD_DEFAULT_INTERVAL);
 	if (err) {
Index: sys/dev/usb/usb.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/usb.h,v
retrieving revision 1.39.2.1
diff -u -r1.39.2.1 usb.h
--- sys/dev/usb/usb.h	20 Jan 2006 22:47:49 -0000	1.39.2.1
+++ sys/dev/usb/usb.h	8 Jun 2006 18:28:30 -0000
@@ -1,695 +1 @@
-/*	$NetBSD: usb.h,v 1.69 2002/09/22 23:20:50 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usb.h,v 1.39.2.1 2006/01/20 22:47:49 mux Exp $    */
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _USB_H_
-#define _USB_H_
-
-#include <sys/types.h>
-#include <sys/time.h>
-
-#if defined(__NetBSD__) || defined(__OpenBSD__)
-#include <sys/ioctl.h>
-#endif
-
-#if defined(_KERNEL)
-#include <dev/usb/usb_port.h>
-#endif /* _KERNEL */
-
-/* These two defines are used by usbd to autoload the usb kld */
-#define USB_KLD		"usb"		/* name of usb module */
-#define USB_UHUB	"usb/uhub"	/* root hub */
-
-#define USB_STACK_VERSION 2
-
-#define USB_MAX_DEVICES 128
-#define USB_START_ADDR 0
-
-#define USB_CONTROL_ENDPOINT 0
-#define USB_MAX_ENDPOINTS 16
-
-#define USB_FRAMES_PER_SECOND 1000
-
-/*
- * The USB records contain some unaligned little-endian word
- * components.  The U[SG]ETW macros take care of both the alignment
- * and endian problem and should always be used to access non-byte
- * values.
- */
-typedef u_int8_t uByte;
-typedef u_int8_t uWord[2];
-typedef u_int8_t uDWord[4];
-
-#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))
-
-#if 1
-#define UGETW(w) ((w)[0] | ((w)[1] << 8))
-#define USETW(w,v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
-#define UGETDW(w) ((w)[0] | ((w)[1] << 8) | ((w)[2] << 16) | ((w)[3] << 24))
-#define USETDW(w,v) ((w)[0] = (u_int8_t)(v), \
-		     (w)[1] = (u_int8_t)((v) >> 8), \
-		     (w)[2] = (u_int8_t)((v) >> 16), \
-		     (w)[3] = (u_int8_t)((v) >> 24))
-#else
-/*
- * On little-endian machines that can handle unanliged accesses
- * (e.g. i386) these macros can be replaced by the following.
- */
-#define UGETW(w) (*(u_int16_t *)(w))
-#define USETW(w,v) (*(u_int16_t *)(w) = (v))
-#define UGETDW(w) (*(u_int32_t *)(w))
-#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
-#endif
-
-#if defined(__FreeBSD__) && (__FreeBSD_version <= 500014)
-#define UPACKED __attribute__ ((packed))
-#else
-#define UPACKED __packed
-#endif
-
-typedef struct {
-	uByte		bmRequestType;
-	uByte		bRequest;
-	uWord		wValue;
-	uWord		wIndex;
-	uWord		wLength;
-} UPACKED usb_device_request_t;
-
-#define UT_WRITE		0x00
-#define UT_READ			0x80
-#define UT_STANDARD		0x00
-#define UT_CLASS		0x20
-#define UT_VENDOR		0x40
-#define UT_DEVICE		0x00
-#define UT_INTERFACE		0x01
-#define UT_ENDPOINT		0x02
-#define UT_OTHER		0x03
-
-#define UT_READ_DEVICE		(UT_READ  | UT_STANDARD | UT_DEVICE)
-#define UT_READ_INTERFACE	(UT_READ  | UT_STANDARD | UT_INTERFACE)
-#define UT_READ_ENDPOINT	(UT_READ  | UT_STANDARD | UT_ENDPOINT)
-#define UT_WRITE_DEVICE		(UT_WRITE | UT_STANDARD | UT_DEVICE)
-#define UT_WRITE_INTERFACE	(UT_WRITE | UT_STANDARD | UT_INTERFACE)
-#define UT_WRITE_ENDPOINT	(UT_WRITE | UT_STANDARD | UT_ENDPOINT)
-#define UT_READ_CLASS_DEVICE	(UT_READ  | UT_CLASS | UT_DEVICE)
-#define UT_READ_CLASS_INTERFACE	(UT_READ  | UT_CLASS | UT_INTERFACE)
-#define UT_READ_CLASS_OTHER	(UT_READ  | UT_CLASS | UT_OTHER)
-#define UT_READ_CLASS_ENDPOINT	(UT_READ  | UT_CLASS | UT_ENDPOINT)
-#define UT_WRITE_CLASS_DEVICE	(UT_WRITE | UT_CLASS | UT_DEVICE)
-#define UT_WRITE_CLASS_INTERFACE (UT_WRITE | UT_CLASS | UT_INTERFACE)
-#define UT_WRITE_CLASS_OTHER	(UT_WRITE | UT_CLASS | UT_OTHER)
-#define UT_WRITE_CLASS_ENDPOINT	(UT_WRITE | UT_CLASS | UT_ENDPOINT)
-#define UT_READ_VENDOR_DEVICE	(UT_READ  | UT_VENDOR | UT_DEVICE)
-#define UT_READ_VENDOR_INTERFACE (UT_READ  | UT_VENDOR | UT_INTERFACE)
-#define UT_READ_VENDOR_OTHER	(UT_READ  | UT_VENDOR | UT_OTHER)
-#define UT_READ_VENDOR_ENDPOINT	(UT_READ  | UT_VENDOR | UT_ENDPOINT)
-#define UT_WRITE_VENDOR_DEVICE	(UT_WRITE | UT_VENDOR | UT_DEVICE)
-#define UT_WRITE_VENDOR_INTERFACE (UT_WRITE | UT_VENDOR | UT_INTERFACE)
-#define UT_WRITE_VENDOR_OTHER	(UT_WRITE | UT_VENDOR | UT_OTHER)
-#define UT_WRITE_VENDOR_ENDPOINT (UT_WRITE | UT_VENDOR | UT_ENDPOINT)
-
-/* Requests */
-#define UR_GET_STATUS		0x00
-#define UR_CLEAR_FEATURE	0x01
-#define UR_SET_FEATURE		0x03
-#define UR_SET_ADDRESS		0x05
-#define UR_GET_DESCRIPTOR	0x06
-#define  UDESC_DEVICE		0x01
-#define  UDESC_CONFIG		0x02
-#define  UDESC_STRING		0x03
-#define  UDESC_INTERFACE	0x04
-#define  UDESC_ENDPOINT		0x05
-#define  UDESC_DEVICE_QUALIFIER	0x06
-#define  UDESC_OTHER_SPEED_CONFIGURATION 0x07
-#define  UDESC_INTERFACE_POWER	0x08
-#define  UDESC_OTG		0x09
-#define  UDESC_CS_DEVICE	0x21	/* class specific */
-#define  UDESC_CS_CONFIG	0x22
-#define  UDESC_CS_STRING	0x23
-#define  UDESC_CS_INTERFACE	0x24
-#define  UDESC_CS_ENDPOINT	0x25
-#define  UDESC_HUB		0x29
-#define UR_SET_DESCRIPTOR	0x07
-#define UR_GET_CONFIG		0x08
-#define UR_SET_CONFIG		0x09
-#define UR_GET_INTERFACE	0x0a
-#define UR_SET_INTERFACE	0x0b
-#define UR_SYNCH_FRAME		0x0c
-
-/* Feature numbers */
-#define UF_ENDPOINT_HALT	0
-#define UF_DEVICE_REMOTE_WAKEUP	1
-#define UF_TEST_MODE		2
-
-#define USB_MAX_IPACKET		8 /* maximum size of the initial packet */
-
-#define USB_2_MAX_CTRL_PACKET	64
-#define USB_2_MAX_BULK_PACKET	512
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bDescriptorSubtype;
-} UPACKED usb_descriptor_t;
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		bcdUSB;
-#define UD_USB_2_0		0x0200
-#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
-	uByte		bDeviceClass;
-	uByte		bDeviceSubClass;
-	uByte		bDeviceProtocol;
-	uByte		bMaxPacketSize;
-	/* The fields below are not part of the initial descriptor. */
-	uWord		idVendor;
-	uWord		idProduct;
-	uWord		bcdDevice;
-	uByte		iManufacturer;
-	uByte		iProduct;
-	uByte		iSerialNumber;
-	uByte		bNumConfigurations;
-} UPACKED usb_device_descriptor_t;
-#define USB_DEVICE_DESCRIPTOR_SIZE 18
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		wTotalLength;
-	uByte		bNumInterface;
-	uByte		bConfigurationValue;
-	uByte		iConfiguration;
-	uByte		bmAttributes;
-#define UC_BUS_POWERED		0x80
-#define UC_SELF_POWERED		0x40
-#define UC_REMOTE_WAKEUP	0x20
-	uByte		bMaxPower; /* max current in 2 mA units */
-#define UC_POWER_FACTOR 2
-} UPACKED usb_config_descriptor_t;
-#define USB_CONFIG_DESCRIPTOR_SIZE 9
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bInterfaceNumber;
-	uByte		bAlternateSetting;
-	uByte		bNumEndpoints;
-	uByte		bInterfaceClass;
-	uByte		bInterfaceSubClass;
-	uByte		bInterfaceProtocol;
-	uByte		iInterface;
-} UPACKED usb_interface_descriptor_t;
-#define USB_INTERFACE_DESCRIPTOR_SIZE 9
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bEndpointAddress;
-#define UE_GET_DIR(a)	((a) & 0x80)
-#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
-#define UE_DIR_IN	0x80
-#define UE_DIR_OUT	0x00
-#define UE_ADDR		0x0f
-#define UE_GET_ADDR(a)	((a) & UE_ADDR)
-	uByte		bmAttributes;
-#define UE_XFERTYPE	0x03
-#define  UE_CONTROL	0x00
-#define  UE_ISOCHRONOUS	0x01
-#define  UE_BULK	0x02
-#define  UE_INTERRUPT	0x03
-#define UE_GET_XFERTYPE(a)	((a) & UE_XFERTYPE)
-#define UE_ISO_TYPE	0x0c
-#define  UE_ISO_ASYNC	0x04
-#define  UE_ISO_ADAPT	0x08
-#define  UE_ISO_SYNC	0x0c
-#define UE_GET_ISO_TYPE(a)	((a) & UE_ISO_TYPE)
-	uWord		wMaxPacketSize;
-	uByte		bInterval;
-} UPACKED usb_endpoint_descriptor_t;
-#define USB_ENDPOINT_DESCRIPTOR_SIZE 7
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		bString[127];
-} UPACKED usb_string_descriptor_t;
-#define USB_MAX_STRING_LEN 128
-#define USB_LANGUAGE_TABLE 0	/* # of the string language id table */
-
-/* Hub specific request */
-#define UR_GET_BUS_STATE	0x02
-#define UR_CLEAR_TT_BUFFER	0x08
-#define UR_RESET_TT		0x09
-#define UR_GET_TT_STATE		0x0a
-#define UR_STOP_TT		0x0b
-
-/* Hub features */
-#define UHF_C_HUB_LOCAL_POWER	0
-#define UHF_C_HUB_OVER_CURRENT	1
-#define UHF_PORT_CONNECTION	0
-#define UHF_PORT_ENABLE		1
-#define UHF_PORT_SUSPEND	2
-#define UHF_PORT_OVER_CURRENT	3
-#define UHF_PORT_RESET		4
-#define UHF_PORT_POWER		8
-#define UHF_PORT_LOW_SPEED	9
-#define UHF_C_PORT_CONNECTION	16
-#define UHF_C_PORT_ENABLE	17
-#define UHF_C_PORT_SUSPEND	18
-#define UHF_C_PORT_OVER_CURRENT	19
-#define UHF_C_PORT_RESET	20
-#define UHF_PORT_TEST		21
-#define UHF_PORT_INDICATOR	22
-
-typedef struct {
-	uByte		bDescLength;
-	uByte		bDescriptorType;
-	uByte		bNbrPorts;
-	uWord		wHubCharacteristics;
-#define UHD_PWR			0x0003
-#define  UHD_PWR_GANGED		0x0000
-#define  UHD_PWR_INDIVIDUAL	0x0001
-#define  UHD_PWR_NO_SWITCH	0x0002
-#define UHD_COMPOUND		0x0004
-#define UHD_OC			0x0018
-#define  UHD_OC_GLOBAL		0x0000
-#define  UHD_OC_INDIVIDUAL	0x0008
-#define  UHD_OC_NONE		0x0010
-#define UHD_TT_THINK		0x0060
-#define  UHD_TT_THINK_8		0x0000
-#define  UHD_TT_THINK_16	0x0020
-#define  UHD_TT_THINK_24	0x0040
-#define  UHD_TT_THINK_32	0x0060
-#define UHD_PORT_IND		0x0080
-	uByte		bPwrOn2PwrGood;	/* delay in 2 ms units */
-#define UHD_PWRON_FACTOR 2
-	uByte		bHubContrCurrent;
-	uByte		DeviceRemovable[32]; /* max 255 ports */
-#define UHD_NOT_REMOV(desc, i) \
-    (((desc)->DeviceRemovable[(i)/8] >> ((i) % 8)) & 1)
-	/* deprecated */ uByte		PortPowerCtrlMask[1];
-} UPACKED usb_hub_descriptor_t;
-#define USB_HUB_DESCRIPTOR_SIZE 9 /* includes deprecated PortPowerCtrlMask */
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uWord		bcdUSB;
-	uByte		bDeviceClass;
-	uByte		bDeviceSubClass;
-	uByte		bDeviceProtocol;
-	uByte		bMaxPacketSize0;
-	uByte		bNumConfigurations;
-	uByte		bReserved;
-} UPACKED usb_device_qualifier_t;
-#define USB_DEVICE_QUALIFIER_SIZE 10
-
-typedef struct {
-	uByte		bLength;
-	uByte		bDescriptorType;
-	uByte		bmAttributes;
-#define UOTG_SRP	0x01
-#define UOTG_HNP	0x02
-} UPACKED usb_otg_descriptor_t;
-
-/* OTG feature selectors */
-#define UOTG_B_HNP_ENABLE	3
-#define UOTG_A_HNP_SUPPORT	4
-#define UOTG_A_ALT_HNP_SUPPORT	5
-
-typedef struct {
-	uWord		wStatus;
-/* Device status flags */
-#define UDS_SELF_POWERED		0x0001
-#define UDS_REMOTE_WAKEUP		0x0002
-/* Endpoint status flags */
-#define UES_HALT			0x0001
-} UPACKED usb_status_t;
-
-typedef struct {
-	uWord		wHubStatus;
-#define UHS_LOCAL_POWER			0x0001
-#define UHS_OVER_CURRENT		0x0002
-	uWord		wHubChange;
-} UPACKED usb_hub_status_t;
-
-typedef struct {
-	uWord		wPortStatus;
-#define UPS_CURRENT_CONNECT_STATUS	0x0001
-#define UPS_PORT_ENABLED		0x0002
-#define UPS_SUSPEND			0x0004
-#define UPS_OVERCURRENT_INDICATOR	0x0008
-#define UPS_RESET			0x0010
-#define UPS_PORT_POWER			0x0100
-#define UPS_LOW_SPEED			0x0200
-#define UPS_HIGH_SPEED			0x0400
-#define UPS_PORT_TEST			0x0800
-#define UPS_PORT_INDICATOR		0x1000
-	uWord		wPortChange;
-#define UPS_C_CONNECT_STATUS		0x0001
-#define UPS_C_PORT_ENABLED		0x0002
-#define UPS_C_SUSPEND			0x0004
-#define UPS_C_OVERCURRENT_INDICATOR	0x0008
-#define UPS_C_PORT_RESET		0x0010
-} UPACKED usb_port_status_t;
-
-/* Device class codes */
-#define UDCLASS_IN_INTERFACE	0x00
-#define UDCLASS_COMM		0x02
-#define UDCLASS_HUB		0x09
-#define  UDSUBCLASS_HUB		0x00
-#define  UDPROTO_FSHUB		0x00
-#define  UDPROTO_HSHUBSTT	0x01
-#define  UDPROTO_HSHUBMTT	0x02
-#define UDCLASS_DIAGNOSTIC	0xdc
-#define UDCLASS_WIRELESS	0xe0
-#define  UDSUBCLASS_RF		0x01
-#define   UDPROTO_BLUETOOTH	0x01
-#define UDCLASS_VENDOR		0xff
-
-/* Interface class codes */
-#define UICLASS_UNSPEC		0x00
-
-#define UICLASS_AUDIO		0x01
-#define  UISUBCLASS_AUDIOCONTROL	1
-#define  UISUBCLASS_AUDIOSTREAM		2
-#define  UISUBCLASS_MIDISTREAM		3
-
-#define UICLASS_CDC		0x02 /* communication */
-#define	 UISUBCLASS_DIRECT_LINE_CONTROL_MODEL	1
-#define  UISUBCLASS_ABSTRACT_CONTROL_MODEL	2
-#define	 UISUBCLASS_TELEPHONE_CONTROL_MODEL	3
-#define	 UISUBCLASS_MULTICHANNEL_CONTROL_MODEL	4
-#define	 UISUBCLASS_CAPI_CONTROLMODEL		5
-#define	 UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL 6
-#define	 UISUBCLASS_ATM_NETWORKING_CONTROL_MODEL 7
-#define   UIPROTO_CDC_AT			1
-
-#define UICLASS_HID		0x03
-#define  UISUBCLASS_BOOT	1
-#define  UIPROTO_BOOT_KEYBOARD	1
-
-#define UICLASS_PHYSICAL	0x05
-
-#define UICLASS_IMAGE		0x06
-
-#define UICLASS_PRINTER		0x07
-#define  UISUBCLASS_PRINTER	1
-#define  UIPROTO_PRINTER_UNI	1
-#define  UIPROTO_PRINTER_BI	2
-#define  UIPROTO_PRINTER_1284	3
-
-#define UICLASS_MASS		0x08
-#define  UISUBCLASS_RBC		1
-#define  UISUBCLASS_SFF8020I	2
-#define  UISUBCLASS_QIC157	3
-#define  UISUBCLASS_UFI		4
-#define  UISUBCLASS_SFF8070I	5
-#define  UISUBCLASS_SCSI	6
-#define  UIPROTO_MASS_CBI_I	0
-#define  UIPROTO_MASS_CBI	1
-#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
-#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */
-
-#define UICLASS_HUB		0x09
-#define  UISUBCLASS_HUB		0
-#define  UIPROTO_FSHUB		0
-#define  UIPROTO_HSHUBSTT	0 /* Yes, same as previous */
-#define  UIPROTO_HSHUBMTT	1
-
-#define UICLASS_CDC_DATA	0x0a
-#define  UISUBCLASS_DATA		0
-#define   UIPROTO_DATA_ISDNBRI		0x30    /* Physical iface */
-#define   UIPROTO_DATA_HDLC		0x31    /* HDLC */
-#define   UIPROTO_DATA_TRANSPARENT	0x32    /* Transparent */
-#define   UIPROTO_DATA_Q921M		0x50    /* Management for Q921 */
-#define   UIPROTO_DATA_Q921		0x51    /* Data for Q921 */
-#define   UIPROTO_DATA_Q921TM		0x52    /* TEI multiplexer for Q921 */
-#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */
-#define   UIPROTO_DATA_Q931		0x91    /* Euro-ISDN */
-#define   UIPROTO_DATA_V120		0x92    /* V.24 rate adaption */
-#define   UIPROTO_DATA_CAPI		0x93    /* CAPI 2.0 commands */
-#define   UIPROTO_DATA_HOST_BASED	0xfd    /* Host based driver */
-#define   UIPROTO_DATA_PUF		0xfe    /* see Prot. Unit Func. Desc.*/
-#define   UIPROTO_DATA_VENDOR		0xff    /* Vendor specific */
-
-#define UICLASS_SMARTCARD	0x0b
-
-/*#define UICLASS_FIRM_UPD	0x0c*/
-
-#define UICLASS_SECURITY	0x0d
-
-#define UICLASS_DIAGNOSTIC	0xdc
-
-#define UICLASS_WIRELESS	0xe0
-#define  UISUBCLASS_RF			0x01
-#define   UIPROTO_BLUETOOTH		0x01
-
-#define UICLASS_APPL_SPEC	0xfe
-#define  UISUBCLASS_FIRMWARE_DOWNLOAD	1
-#define  UISUBCLASS_IRDA		2
-#define  UIPROTO_IRDA			0
-
-#define UICLASS_VENDOR		0xff
-#define  UISUBCLASS_XBOX360_CONTROLLER	0x5d
-#define  UIPROTO_XBOX360_GAMEPAD	0x01
-
-
-#define USB_HUB_MAX_DEPTH 5
-
-/*
- * Minimum time a device needs to be powered down to go through
- * a power cycle.  XXX Are these time in the spec?
- */
-#define USB_POWER_DOWN_TIME	200 /* ms */
-#define USB_PORT_POWER_DOWN_TIME	100 /* ms */
-
-#if 0
-/* These are the values from the spec. */
-#define USB_PORT_RESET_DELAY	10  /* ms */
-#define USB_PORT_ROOT_RESET_DELAY 50  /* ms */
-#define USB_PORT_RESET_RECOVERY	10  /* ms */
-#define USB_PORT_POWERUP_DELAY	100 /* ms */
-#define USB_SET_ADDRESS_SETTLE	2   /* ms */
-#define USB_RESUME_DELAY	(20*5)  /* ms */
-#define USB_RESUME_WAIT		10  /* ms */
-#define USB_RESUME_RECOVERY	10  /* ms */
-#define USB_EXTRA_POWER_UP_TIME	0   /* ms */
-#else
-/* Allow for marginal (i.e. non-conforming) devices. */
-#define USB_PORT_RESET_DELAY	50  /* ms */
-#define USB_PORT_ROOT_RESET_DELAY 250  /* ms */
-#define USB_PORT_RESET_RECOVERY	250  /* ms */
-#define USB_PORT_POWERUP_DELAY	300 /* ms */
-#define USB_SET_ADDRESS_SETTLE	10  /* ms */
-#define USB_RESUME_DELAY	(50*5)  /* ms */
-#define USB_RESUME_WAIT		50  /* ms */
-#define USB_RESUME_RECOVERY	50  /* ms */
-#define USB_EXTRA_POWER_UP_TIME	20  /* ms */
-#endif
-
-#define USB_MIN_POWER		100 /* mA */
-#define USB_MAX_POWER		500 /* mA */
-
-#define USB_BUS_RESET_DELAY	100 /* ms XXX?*/
-
-
-#define USB_UNCONFIG_NO 0
-#define USB_UNCONFIG_INDEX (-1)
-
-/*** ioctl() related stuff ***/
-
-struct usb_ctl_request {
-	int	ucr_addr;
-	usb_device_request_t ucr_request;
-	void	*ucr_data;
-	int	ucr_flags;
-#define USBD_SHORT_XFER_OK	0x04	/* allow short reads */
-	int	ucr_actlen;		/* actual length transferred */
-};
-
-struct usb_alt_interface {
-	int	uai_config_index;
-	int	uai_interface_index;
-	int	uai_alt_no;
-};
-
-#define USB_CURRENT_CONFIG_INDEX (-1)
-#define USB_CURRENT_ALT_INDEX (-1)
-
-struct usb_config_desc {
-	int	ucd_config_index;
-	usb_config_descriptor_t ucd_desc;
-};
-
-struct usb_interface_desc {
-	int	uid_config_index;
-	int	uid_interface_index;
-	int	uid_alt_index;
-	usb_interface_descriptor_t uid_desc;
-};
-
-struct usb_endpoint_desc {
-	int	ued_config_index;
-	int	ued_interface_index;
-	int	ued_alt_index;
-	int	ued_endpoint_index;
-	usb_endpoint_descriptor_t ued_desc;
-};
-
-struct usb_full_desc {
-	int	ufd_config_index;
-	u_int	ufd_size;
-	u_char	*ufd_data;
-};
-
-struct usb_string_desc {
-	int	usd_string_index;
-	int	usd_language_id;
-	usb_string_descriptor_t usd_desc;
-};
-
-struct usb_ctl_report_desc {
-	int	ucrd_size;
-	u_char	ucrd_data[1024];	/* filled data size will vary */
-};
-
-typedef struct { u_int32_t cookie; } usb_event_cookie_t;
-
-#define USB_MAX_DEVNAMES 4
-#define USB_MAX_DEVNAMELEN 16
-struct usb_device_info {
-	u_int8_t	udi_bus;
-	u_int8_t	udi_addr;	/* device address */
-	usb_event_cookie_t udi_cookie;
-	char		udi_product[USB_MAX_STRING_LEN];
-	char		udi_vendor[USB_MAX_STRING_LEN];
-	char		udi_release[8];
-	u_int16_t	udi_productNo;
-	u_int16_t	udi_vendorNo;
-	u_int16_t	udi_releaseNo;
-	u_int8_t	udi_class;
-	u_int8_t	udi_subclass;
-	u_int8_t	udi_protocol;
-	u_int8_t	udi_config;
-	u_int8_t	udi_speed;
-#define USB_SPEED_LOW  1
-#define USB_SPEED_FULL 2
-#define USB_SPEED_HIGH 3
-	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
-	int		udi_nports;
-	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
-	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
-#define USB_PORT_ENABLED 0xff
-#define USB_PORT_SUSPENDED 0xfe
-#define USB_PORT_POWERED 0xfd
-#define USB_PORT_DISABLED 0xfc
-};
-
-struct usb_ctl_report {
-	int	ucr_report;
-	u_char	ucr_data[1024];	/* filled data size will vary */
-};
-
-struct usb_device_stats {
-	u_long	uds_requests[4];	/* indexed by transfer type UE_* */
-};
-
-/* Events that can be read from /dev/usb */
-struct usb_event {
-	int			ue_type;
-#define USB_EVENT_CTRLR_ATTACH 1
-#define USB_EVENT_CTRLR_DETACH 2
-#define USB_EVENT_DEVICE_ATTACH 3
-#define USB_EVENT_DEVICE_DETACH 4
-#define USB_EVENT_DRIVER_ATTACH 5
-#define USB_EVENT_DRIVER_DETACH 6
-#define USB_EVENT_IS_ATTACH(n) ((n) == USB_EVENT_CTRLR_ATTACH || (n) == USB_EVENT_DEVICE_ATTACH || (n) == USB_EVENT_DRIVER_ATTACH)
-#define USB_EVENT_IS_DETACH(n) ((n) == USB_EVENT_CTRLR_DETACH || (n) == USB_EVENT_DEVICE_DETACH || (n) == USB_EVENT_DRIVER_DETACH)
-	struct timespec		ue_time;
-	union {
-		struct {
-			int			ue_bus;
-		} ue_ctrlr;
-		struct usb_device_info		ue_device;
-		struct {
-			usb_event_cookie_t	ue_cookie;
-			char			ue_devname[16];
-		} ue_driver;
-	} u;
-};
-
-/* USB controller */
-#define USB_REQUEST		_IOWR('U', 1, struct usb_ctl_request)
-#define USB_SETDEBUG		_IOW ('U', 2, int)
-#define USB_DISCOVER		_IO  ('U', 3)
-#define USB_DEVICEINFO		_IOWR('U', 4, struct usb_device_info)
-#define USB_DEVICESTATS		_IOR ('U', 5, struct usb_device_stats)
-
-/* Generic HID device */
-#define USB_GET_REPORT_DESC	_IOR ('U', 21, struct usb_ctl_report_desc)
-#define USB_SET_IMMED		_IOW ('U', 22, int)
-#define USB_GET_REPORT		_IOWR('U', 23, struct usb_ctl_report)
-#define USB_SET_REPORT		_IOW ('U', 24, struct usb_ctl_report)
-#define USB_GET_REPORT_ID	_IOR ('U', 25, int)
-
-/* Generic USB device */
-#define USB_GET_CONFIG		_IOR ('U', 100, int)
-#define USB_SET_CONFIG		_IOW ('U', 101, int)
-#define USB_GET_ALTINTERFACE	_IOWR('U', 102, struct usb_alt_interface)
-#define USB_SET_ALTINTERFACE	_IOWR('U', 103, struct usb_alt_interface)
-#define USB_GET_NO_ALT		_IOWR('U', 104, struct usb_alt_interface)
-#define USB_GET_DEVICE_DESC	_IOR ('U', 105, usb_device_descriptor_t)
-#define USB_GET_CONFIG_DESC	_IOWR('U', 106, struct usb_config_desc)
-#define USB_GET_INTERFACE_DESC	_IOWR('U', 107, struct usb_interface_desc)
-#define USB_GET_ENDPOINT_DESC	_IOWR('U', 108, struct usb_endpoint_desc)
-#define USB_GET_FULL_DESC	_IOWR('U', 109, struct usb_full_desc)
-#define USB_GET_STRING_DESC	_IOWR('U', 110, struct usb_string_desc)
-#define USB_DO_REQUEST		_IOWR('U', 111, struct usb_ctl_request)
-#define USB_GET_DEVICEINFO	_IOR ('U', 112, struct usb_device_info)
-#define USB_SET_SHORT_XFER	_IOW ('U', 113, int)
-#define USB_SET_TIMEOUT		_IOW ('U', 114, int)
-
-/* Modem device */
-#define USB_GET_CM_OVER_DATA	_IOR ('U', 130, int)
-#define USB_SET_CM_OVER_DATA	_IOW ('U', 131, int)
-
-#endif /* _USB_H_ */
+#include <dev/usb2/usb.h>
Index: sys/dev/usb/usb_port.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/usb_port.h,v
retrieving revision 1.74
diff -u -r1.74 usb_port.h
--- sys/dev/usb/usb_port.h	20 Jan 2005 05:03:28 -0000	1.74
+++ sys/dev/usb/usb_port.h	8 Jun 2006 18:28:30 -0000
@@ -1,529 +1 @@
-/*	$OpenBSD: usb_port.h,v 1.18 2000/09/06 22:42:10 rahnds Exp $ */
-/*	$NetBSD: usb_port.h,v 1.54 2002/03/28 21:49:19 ichiro Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usb_port.h,v 1.74 2005/01/20 05:03:28 imp Exp $       */
-
-/* Also already merged from NetBSD:
- *	$NetBSD: usb_port.h,v 1.57 2002/09/27 20:42:01 thorpej Exp $
- *	$NetBSD: usb_port.h,v 1.58 2002/10/01 01:25:26 thorpej Exp $
- */
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _USB_PORT_H
-#define _USB_PORT_H
-
-/*
- * Macro's to cope with the differences between operating systems.
- */
-
-#if defined(__NetBSD__)
-/*
- * NetBSD
- */
-
-#include "opt_usbverbose.h"
-
-#define USB_USE_SOFTINTR
-
-#ifdef USB_DEBUG
-#define Static
-#else
-#define Static static
-#endif
-
-#define SCSI_MODE_SENSE		MODE_SENSE
-
-typedef struct proc *usb_proc_ptr;
-
-typedef struct device *device_ptr_t;
-#define USBBASEDEVICE struct device
-#define USBDEV(bdev) (&(bdev))
-#define USBDEVNAME(bdev) ((bdev).dv_xname)
-#define USBDEVUNIT(bdev) ((bdev).dv_unit)
-#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
-#define USBGETSOFTC(d) ((void *)(d))
-
-#define DECLARE_USB_DMA_T \
-	struct usb_dma_block; \
-	typedef struct { \
-		struct usb_dma_block *block; \
-		u_int offs; \
-	} usb_dma_t
-
-typedef struct callout usb_callout_t;
-#define usb_callout_init(h)	callout_init(&(h))
-#define	usb_callout(h, t, f, d)	callout_reset(&(h), (t), (f), (d))
-#define	usb_uncallout(h, f, d)	callout_stop(&(h))
-
-#define usb_kthread_create1	kthread_create1
-#define usb_kthread_create	kthread_create
-
-typedef int usb_malloc_type;
-
-#define Ether_ifattach ether_ifattach
-#define IF_INPUT(ifp, m) (*(ifp)->if_input)((ifp), (m))
-
-#define logprintf printf
-
-#define	USB_DNAME(dname)	dname
-#define USB_DECLARE_DRIVER(dname)  \
-int __CONCAT(dname,_match)(struct device *, struct cfdata *, void *); \
-void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
-int __CONCAT(dname,_detach)(struct device *, int); \
-int __CONCAT(dname,_activate)(struct device *, enum devact); \
-\
-extern struct cfdriver __CONCAT(dname,_cd); \
-\
-CFATTACH_DECL(USB_DNAME(dname), \
-    sizeof(struct ___CONCAT(dname,_softc)), \
-    ___CONCAT(dname,_match), \
-    ___CONCAT(dname,_attach), \
-    ___CONCAT(dname,_detach), \
-    ___CONCAT(dname,_activate))
-
-#define USB_MATCH(dname) \
-int __CONCAT(dname,_match)(struct device *parent, struct cfdata *match, void *aux)
-
-#define USB_MATCH_START(dname, uaa) \
-	struct usb_attach_arg *uaa = aux
-
-#define USB_ATTACH(dname) \
-void __CONCAT(dname,_attach)(struct device *parent, struct device *self, void *aux)
-
-#define USB_ATTACH_START(dname, sc, uaa) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self; \
-	struct usb_attach_arg *uaa = aux
-
-/* Returns from attach */
-#define USB_ATTACH_ERROR_RETURN	return
-#define USB_ATTACH_SUCCESS_RETURN	return
-
-#define USB_ATTACH_SETUP
-	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
-
-#define USB_DETACH(dname) \
-int __CONCAT(dname,_detach)(struct device *self, int flags)
-
-#define USB_DETACH_START(dname, sc) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self
-
-#define USB_GET_SC_OPEN(dname, unit, sc) \
-	if (unit >= __CONCAT(dname,_cd).cd_ndevs) \
-		return (ENXIO); \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]; \
-	if (sc == NULL) \
-		return (ENXIO)
-
-#define USB_GET_SC(dname, unit, sc) \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]
-
-#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
-	(config_found_sm(parent, args, print, sub))
-
-#elif defined(__OpenBSD__)
-/*
- * OpenBSD
- */
-#define Static
-
-typedef struct proc *usb_proc_ptr;
-
-#define UCOMBUSCF_PORTNO		-1
-#define UCOMBUSCF_PORTNO_DEFAULT	-1
-
-#define SCSI_MODE_SENSE		MODE_SENSE
-#define XS_STS_DONE		ITSDONE
-#define XS_CTL_POLL		SCSI_POLL
-#define XS_CTL_DATA_IN		SCSI_DATA_IN
-#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
-#define scsipi_adapter		scsi_adapter
-#define scsipi_cmd		scsi_cmd
-#define scsipi_device		scsi_device
-#define scsipi_done		scsi_done
-#define scsipi_link		scsi_link
-#define scsipi_minphys		scsi_minphys
-#define scsipi_sense		scsi_sense
-#define scsipi_xfer		scsi_xfer
-#define xs_control		flags
-#define xs_status		status
-
-#define	memcpy(d, s, l)		bcopy((s),(d),(l))
-#define	memset(d, v, l)		bzero((d),(l))
-#define bswap32(x)		swap32(x)
-#define bswap16(x)		swap16(x)
-
-/*
- * The UHCI/OHCI controllers are little endian, so on big endian machines
- * the data strored in memory needs to be swapped.
- */
-
-#if defined(letoh32)
-#define le32toh(x) letoh32(x)
-#define le16toh(x) letoh16(x)
-#endif
-
-#define usb_kthread_create1	kthread_create
-#define usb_kthread_create	kthread_create_deferred
-
-#define	config_pending_incr()
-#define	config_pending_decr()
-
-typedef int usb_malloc_type;
-
-#define Ether_ifattach(ifp, eaddr) ether_ifattach(ifp)
-#define if_deactivate(x)
-#define IF_INPUT(ifp, m) do {						\
-	struct ether_header *eh;					\
-									\
-	eh = mtod(m, struct ether_header *);				\
-	m_adj(m, sizeof(struct ether_header));				\
-	ether_input((ifp), (eh), (m));					\
-} while (0)
-
-#define	usbpoll			usbselect
-#define	uhidpoll		uhidselect
-#define	ugenpoll		ugenselect
-#define	uriopoll		urioselect
-#define uscannerpoll		uscannerselect
-
-#define powerhook_establish(fn, sc) (fn)
-#define powerhook_disestablish(hdl)
-#define PWR_RESUME 0
-
-#define logprintf printf
-
-#define swap_bytes_change_sign16_le swap_bytes_change_sign16
-#define change_sign16_swap_bytes_le change_sign16_swap_bytes
-#define change_sign16_le change_sign16
-
-#define realloc usb_realloc
-void *usb_realloc(void *, u_int, int, int);
-
-extern int cold;
-
-typedef struct device *device_ptr_t;
-#define USBBASEDEVICE struct device
-#define USBDEV(bdev) (&(bdev))
-#define USBDEVNAME(bdev) ((bdev).dv_xname)
-#define USBDEVUNIT(bdev) ((bdev).dv_unit)
-#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
-#define USBGETSOFTC(d) ((void *)(d))
-
-#define DECLARE_USB_DMA_T \
-	struct usb_dma_block; \
-	typedef struct { \
-		struct usb_dma_block *block; \
-		u_int offs; \
-	} usb_dma_t
-
-typedef char usb_callout_t;
-#define usb_callout_init(h)
-#define usb_callout(h, t, f, d) timeout((f), (d), (t))
-#define usb_uncallout(h, f, d) untimeout((f), (d))
-
-#define USB_DECLARE_DRIVER(dname)  \
-int __CONCAT(dname,_match)(struct device *, void *, void *); \
-void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
-int __CONCAT(dname,_detach)(struct device *, int); \
-int __CONCAT(dname,_activate)(struct device *, enum devact); \
-\
-struct cfdriver __CONCAT(dname,_cd) = { \
-	NULL, #dname, DV_DULL \
-}; \
-\
-const struct cfattach __CONCAT(dname,_ca) = { \
-	sizeof(struct __CONCAT(dname,_softc)), \
-	__CONCAT(dname,_match), \
-	__CONCAT(dname,_attach), \
-	__CONCAT(dname,_detach), \
-	__CONCAT(dname,_activate), \
-}
-
-#define USB_MATCH(dname) \
-int \
-__CONCAT(dname,_match)(parent, match, aux) \
-	struct device *parent; \
-	void *match; \
-	void *aux;
-
-#define USB_MATCH_START(dname, uaa) \
-	struct usb_attach_arg *uaa = aux
-
-#define USB_ATTACH(dname) \
-void \
-__CONCAT(dname,_attach)(parent, self, aux) \
-	struct device *parent; \
-	struct device *self; \
-	void *aux;
-
-#define USB_ATTACH_START(dname, sc, uaa) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self; \
-	struct usb_attach_arg *uaa = aux
-
-/* Returns from attach */
-#define USB_ATTACH_ERROR_RETURN	return
-#define USB_ATTACH_SUCCESS_RETURN	return
-
-#define USB_ATTACH_SETUP
-	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
-
-#define USB_DETACH(dname) \
-int \
-__CONCAT(dname,_detach)(self, flags) \
-	struct device *self; \
-	int flags;
-
-#define USB_DETACH_START(dname, sc) \
-	struct __CONCAT(dname,_softc) *sc = \
-		(struct __CONCAT(dname,_softc) *)self
-
-#define USB_GET_SC_OPEN(dname, unit, sc) \
-	if (unit >= __CONCAT(dname,_cd).cd_ndevs) \
-		return (ENXIO); \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]; \
-	if (sc == NULL) \
-		return (ENXIO)
-
-#define USB_GET_SC(dname, unit, sc) \
-	sc = __CONCAT(dname,_cd).cd_devs[unit]
-
-#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
-	(config_found_sm(parent, args, print, sub))
-
-#elif defined(__FreeBSD__)
-/*
- * FreeBSD
- */
-
-#include "opt_usb.h"
-
-#if defined(_KERNEL)
-#include <sys/malloc.h>
-
-MALLOC_DECLARE(M_USB);
-MALLOC_DECLARE(M_USBDEV);
-MALLOC_DECLARE(M_USBHC);
-
-#endif
-
-/* We don't use the soft interrupt code in FreeBSD. */
-#if 0
-#define USB_USE_SOFTINTR
-#endif
-
-#define Static static
-
-#define device_ptr_t device_t
-#define USBBASEDEVICE device_t
-#define USBDEV(bdev) (bdev)
-#define USBDEVNAME(bdev) device_get_nameunit(bdev)
-#define USBDEVUNIT(bdev) device_get_unit(bdev)
-#define USBDEVPTRNAME(bdev) device_get_nameunit(bdev)
-#define USBDEVUNIT(bdev) device_get_unit(bdev)
-#define USBGETSOFTC(bdev) (device_get_softc(bdev))
-
-#define DECLARE_USB_DMA_T \
-	struct usb_dma_block; \
-	typedef struct { \
-		struct usb_dma_block *block; \
-		u_int offs; \
-		u_int len; \
-	} usb_dma_t
-
-#if __FreeBSD_version >= 500000
-typedef struct thread *usb_proc_ptr;
-
-#define uio_procp uio_td
-
-#define usb_kthread_create1(f, s, p, a0, a1) \
-		kthread_create((f), (s), (p), RFHIGHPID, 0, (a0), (a1))
-#define usb_kthread_create2(f, s, p, a0) \
-		kthread_create((f), (s), (p), RFHIGHPID, 0, (a0))
-#define usb_kthread_create	kthread_create
-
-#define	config_pending_incr()
-#define	config_pending_decr()
-
-typedef struct callout usb_callout_t;
-#define usb_callout_init(h)     callout_init(&(h), 0)
-#define usb_callout(h, t, f, d) callout_reset(&(h), (t), (f), (d))
-#define usb_uncallout(h, f, d)  callout_stop(&(h))
-#define usb_uncallout_drain(h, f, d)  callout_drain(&(h))
-#else
-typedef struct proc *usb_proc_ptr;
-
-#define	PROC_LOCK(p)
-#define	PROC_UNLOCK(p)
-
-#define usb_kthread_create1(f, s, p, a0, a1) \
-		kthread_create((f), (s), (p), (a0), (a1))
-#define usb_kthread_create2(f, s, p, a0) \
-		kthread_create((f), (s), (p), (a0))
-#define usb_kthread_create	kthread_create
-
-#define	config_pending_incr()
-#define	config_pending_decr()
-
-typedef struct callout usb_callout_t;
-#define usb_callout_init(h)     callout_init(&(h))
-#define usb_callout(h, t, f, d) callout_reset(&(h), (t), (f), (d))
-#define usb_uncallout(h, f, d)  callout_stop(&(h))
-
-#define	BUS_DMA_COHERENT	0
-#define	ETHER_ALIGN		2
-#define	BPF_MTAP(ifp, m)	if ((ifp)->if_bpf) bpf_mtap((ifp), (m));
-#endif
-
-#define clalloc(p, s, x) (clist_alloc_cblocks((p), (s), (s)), 0)
-#define clfree(p) clist_free_cblocks((p))
-
-#define PWR_RESUME 0
-#define PWR_SUSPEND 1
-
-#define config_detach(dev, flag) \
-	do { \
-		device_detach(dev); \
-		free(device_get_ivars(dev), M_USB); \
-		device_delete_child(device_get_parent(dev), dev); \
-	} while (0);
-
-typedef struct malloc_type *usb_malloc_type;
-
-#define USB_DECLARE_DRIVER_INIT(dname, init...) \
-Static device_probe_t __CONCAT(dname,_match); \
-Static device_attach_t __CONCAT(dname,_attach); \
-Static device_detach_t __CONCAT(dname,_detach); \
-\
-Static devclass_t __CONCAT(dname,_devclass); \
-\
-Static device_method_t __CONCAT(dname,_methods)[] = { \
-        DEVMETHOD(device_probe, __CONCAT(dname,_match)), \
-        DEVMETHOD(device_attach, __CONCAT(dname,_attach)), \
-        DEVMETHOD(device_detach, __CONCAT(dname,_detach)), \
-	init, \
-        {0,0} \
-}; \
-\
-Static driver_t __CONCAT(dname,_driver) = { \
-        #dname, \
-        __CONCAT(dname,_methods), \
-        sizeof(struct __CONCAT(dname,_softc)) \
-}; \
-MODULE_DEPEND(dname, usb, 1, 1, 1)
-
-
-#define METHODS_NONE			{0,0}
-#define USB_DECLARE_DRIVER(dname)	USB_DECLARE_DRIVER_INIT(dname, METHODS_NONE)
-
-#define USB_MATCH(dname) \
-Static int \
-__CONCAT(dname,_match)(device_t self)
-
-#define USB_MATCH_START(dname, uaa) \
-        struct usb_attach_arg *uaa = device_get_ivars(self)
-
-#define USB_MATCH_SETUP \
-	sc->sc_dev = self
-
-#define USB_ATTACH(dname) \
-Static int \
-__CONCAT(dname,_attach)(device_t self)
-
-#define USB_ATTACH_START(dname, sc, uaa) \
-        struct __CONCAT(dname,_softc) *sc = device_get_softc(self); \
-        struct usb_attach_arg *uaa = device_get_ivars(self)
-
-/* Returns from attach */
-#define USB_ATTACH_ERROR_RETURN	return ENXIO
-#define USB_ATTACH_SUCCESS_RETURN	return 0
-
-#define USB_ATTACH_SETUP \
-	do { \
-		sc->sc_dev = self; \
-		device_set_desc_copy(self, devinfo); \
-		device_printf(self, "%s\n", devinfo); \
-	} while (0);
-
-#define USB_DETACH(dname) \
-Static int \
-__CONCAT(dname,_detach)(device_t self)
-
-#define USB_DETACH_START(dname, sc) \
-	struct __CONCAT(dname,_softc) *sc = device_get_softc(self)
-
-#define USB_GET_SC_OPEN(dname, unit, sc) \
-	sc = devclass_get_softc(__CONCAT(dname,_devclass), unit); \
-	if (sc == NULL) \
-		return (ENXIO)
-
-#define USB_GET_SC(dname, unit, sc) \
-	sc = devclass_get_softc(__CONCAT(dname,_devclass), unit)
-
-#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
-	(device_probe_and_attach((bdev)) == 0 ? (bdev) : 0)
-
-/* conversion from one type of queue to the other */
-#define SIMPLEQ_REMOVE_HEAD	STAILQ_REMOVE_HEAD
-#define SIMPLEQ_INSERT_HEAD	STAILQ_INSERT_HEAD
-#define SIMPLEQ_INSERT_TAIL	STAILQ_INSERT_TAIL
-#define SIMPLEQ_NEXT		STAILQ_NEXT
-#define SIMPLEQ_FIRST		STAILQ_FIRST
-#define SIMPLEQ_HEAD		STAILQ_HEAD
-#define SIMPLEQ_EMPTY		STAILQ_EMPTY
-#define SIMPLEQ_FOREACH		STAILQ_FOREACH
-#define SIMPLEQ_INIT		STAILQ_INIT
-#define SIMPLEQ_HEAD_INITIALIZER	STAILQ_HEAD_INITIALIZER
-#define SIMPLEQ_ENTRY		STAILQ_ENTRY
-
-#include <sys/syslog.h>
-/*
-#define logprintf(args...)	log(LOG_DEBUG, args)
-*/
-#define logprintf		printf
-
-#ifdef SYSCTL_DECL
-SYSCTL_DECL(_hw_usb);
-#endif
-
-#endif /* __FreeBSD__ */
-
-#endif /* _USB_PORT_H */
-
+#include <dev/usb2/usb_port.h>
Index: sys/dev/usb/usb_quirks.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/usb_quirks.c,v
retrieving revision 1.41.2.4
diff -u -r1.41.2.4 usb_quirks.c
--- sys/dev/usb/usb_quirks.c	15 Feb 2006 22:51:08 -0000	1.41.2.4
+++ sys/dev/usb/usb_quirks.c	8 Jun 2006 18:28:30 -0000
@@ -48,10 +48,6 @@
 #include "usbdevs.h"
 #include <dev/usb/usb_quirks.h>
 
-#ifdef USB_DEBUG
-extern int usbdebug;
-#endif
-
 #define ANY 0xffff
 
 Static const struct usbd_quirk_entry {
Index: sys/dev/usb/usbdi.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/usbdi.h,v
retrieving revision 1.59
diff -u -r1.59 usbdi.h
--- sys/dev/usb/usbdi.h	16 May 2005 06:58:43 -0000	1.59
+++ sys/dev/usb/usbdi.h	8 Jun 2006 18:28:30 -0000
@@ -1,308 +1 @@
-/*	$NetBSD: usbdi.h,v 1.64 2004/10/23 13:26:34 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usbdi.h,v 1.59 2005/05/16 06:58:43 imp Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _USBDI_H_
-#define _USBDI_H_
-
-typedef struct usbd_bus		*usbd_bus_handle;
-typedef struct usbd_device	*usbd_device_handle;
-typedef struct usbd_interface	*usbd_interface_handle;
-typedef struct usbd_pipe	*usbd_pipe_handle;
-typedef struct usbd_xfer	*usbd_xfer_handle;
-typedef void			*usbd_private_handle;
-
-typedef enum {		/* keep in sync with usbd_status_msgs */
-	USBD_NORMAL_COMPLETION = 0, /* must be 0 */
-	USBD_IN_PROGRESS,	/* 1 */
-	/* errors */
-	USBD_PENDING_REQUESTS,	/* 2 */
-	USBD_NOT_STARTED,	/* 3 */
-	USBD_INVAL,		/* 4 */
-	USBD_NOMEM,		/* 5 */
-	USBD_CANCELLED,		/* 6 */
-	USBD_BAD_ADDRESS,	/* 7 */
-	USBD_IN_USE,		/* 8 */
-	USBD_NO_ADDR,		/* 9 */
-	USBD_SET_ADDR_FAILED,	/* 10 */
-	USBD_NO_POWER,		/* 11 */
-	USBD_TOO_DEEP,		/* 12 */
-	USBD_IOERROR,		/* 13 */
-	USBD_NOT_CONFIGURED,	/* 14 */
-	USBD_TIMEOUT,		/* 15 */
-	USBD_SHORT_XFER,	/* 16 */
-	USBD_STALLED,		/* 17 */
-	USBD_INTERRUPTED,	/* 18 */
-
-	USBD_ERROR_MAX		/* must be last */
-} usbd_status;
-
-typedef void (*usbd_callback)(usbd_xfer_handle, usbd_private_handle,
-			      usbd_status);
-
-/* Open flags */
-#define USBD_EXCLUSIVE_USE	0x01
-
-/* Use default (specified by ep. desc.) interval on interrupt pipe */
-#define USBD_DEFAULT_INTERVAL	(-1)
-
-/* Request flags */
-#define USBD_NO_COPY		0x01	/* do not copy data to DMA buffer */
-#define USBD_SYNCHRONOUS	0x02	/* wait for completion */
-/* in usb.h #define USBD_SHORT_XFER_OK	0x04*/	/* allow short reads */
-#define USBD_FORCE_SHORT_XFER	0x08	/* force last short packet on write */
-
-#define USBD_NO_TIMEOUT 0
-#define USBD_DEFAULT_TIMEOUT 5000 /* ms = 5 s */
-
-usbd_status usbd_open_pipe(usbd_interface_handle, u_int8_t,
-			   u_int8_t, usbd_pipe_handle *);
-usbd_status usbd_close_pipe(usbd_pipe_handle);
-usbd_status usbd_transfer(usbd_xfer_handle);
-usbd_xfer_handle usbd_alloc_xfer(usbd_device_handle);
-usbd_status usbd_free_xfer(usbd_xfer_handle);
-void usbd_setup_xfer(usbd_xfer_handle, usbd_pipe_handle,
-		     usbd_private_handle, void *,
-		     u_int32_t, u_int16_t, u_int32_t,
-		     usbd_callback);
-void usbd_setup_default_xfer(usbd_xfer_handle, usbd_device_handle,
-			     usbd_private_handle, u_int32_t,
-			     usb_device_request_t *, void *,
-			     u_int32_t, u_int16_t, usbd_callback);
-void usbd_setup_isoc_xfer(usbd_xfer_handle, usbd_pipe_handle,
-			  usbd_private_handle, u_int16_t *,
-			  u_int32_t, u_int16_t, usbd_callback);
-void usbd_get_xfer_status(usbd_xfer_handle, usbd_private_handle *,
-			  void **, u_int32_t *, usbd_status *);
-usb_endpoint_descriptor_t *usbd_interface2endpoint_descriptor
-			(usbd_interface_handle, u_int8_t);
-usbd_status usbd_abort_pipe(usbd_pipe_handle);
-usbd_status usbd_abort_default_pipe(usbd_device_handle);
-usbd_status usbd_clear_endpoint_stall(usbd_pipe_handle);
-usbd_status usbd_clear_endpoint_stall_async(usbd_pipe_handle);
-void usbd_clear_endpoint_toggle(usbd_pipe_handle);
-usbd_status usbd_endpoint_count(usbd_interface_handle, u_int8_t *);
-usbd_status usbd_interface_count(usbd_device_handle, u_int8_t *);
-void usbd_interface2device_handle(usbd_interface_handle,
-					 usbd_device_handle *);
-usbd_status usbd_device2interface_handle(usbd_device_handle,
-			      u_int8_t, usbd_interface_handle *);
-
-usbd_device_handle usbd_pipe2device_handle(usbd_pipe_handle);
-void *usbd_alloc_buffer(usbd_xfer_handle, u_int32_t);
-void usbd_free_buffer(usbd_xfer_handle);
-void *usbd_get_buffer(usbd_xfer_handle);
-usbd_status usbd_sync_transfer(usbd_xfer_handle);
-usbd_status usbd_open_pipe_intr(usbd_interface_handle, u_int8_t,
-				u_int8_t, usbd_pipe_handle *,
-				usbd_private_handle, void *,
-				u_int32_t, usbd_callback, int);
-usbd_status usbd_do_request(usbd_device_handle, usb_device_request_t *, void *);
-usbd_status usbd_do_request_async(usbd_device_handle,
-				  usb_device_request_t *, void *);
-usbd_status usbd_do_request_flags(usbd_device_handle, usb_device_request_t *,
-				  void *, u_int16_t, int*, u_int32_t);
-usbd_status usbd_do_request_flags_pipe(usbd_device_handle, usbd_pipe_handle,
-	usb_device_request_t *, void *, u_int16_t, int *, u_int32_t);
-usb_interface_descriptor_t *usbd_get_interface_descriptor
-				(usbd_interface_handle);
-usb_config_descriptor_t *usbd_get_config_descriptor(usbd_device_handle);
-usb_device_descriptor_t *usbd_get_device_descriptor(usbd_device_handle);
-int usbd_get_speed(usbd_device_handle);
-usbd_status usbd_set_interface(usbd_interface_handle, int);
-int usbd_get_no_alts(usb_config_descriptor_t *, int);
-usbd_status  usbd_get_interface(usbd_interface_handle, u_int8_t *);
-void usbd_fill_deviceinfo(usbd_device_handle, struct usb_device_info *, int);
-int usbd_get_interface_altindex(usbd_interface_handle);
-
-usb_interface_descriptor_t *usbd_find_idesc(usb_config_descriptor_t *,
-					    int, int);
-usb_endpoint_descriptor_t *usbd_find_edesc(usb_config_descriptor_t *,
-					   int, int, int);
-
-void usbd_dopoll(usbd_interface_handle);
-void usbd_set_polling(usbd_device_handle, int);
-
-const char *usbd_errstr(usbd_status);
-
-void usbd_add_dev_event(int, usbd_device_handle);
-void usbd_add_drv_event(int, usbd_device_handle, device_ptr_t);
-
-void usbd_devinfo(usbd_device_handle, int, char *);
-const struct usbd_quirks *usbd_get_quirks(usbd_device_handle);
-usb_endpoint_descriptor_t *usbd_get_endpoint_descriptor
-			(usbd_interface_handle, u_int8_t);
-
-usbd_status usbd_reload_device_desc(usbd_device_handle);
-
-int usbd_ratecheck(struct timeval *last);
-
-usbd_status usbd_get_string(usbd_device_handle dev, int si, char *buf);
-
-/* An iterator for descriptors. */
-typedef struct {
-	const uByte *cur;
-	const uByte *end;
-} usbd_desc_iter_t;
-void usb_desc_iter_init(usbd_device_handle dev, usbd_desc_iter_t *iter);
-const usb_descriptor_t *usb_desc_iter_next(usbd_desc_iter_t *iter);
-
-/*
- * The usb_task structs form a queue of things to run in the USB event
- * thread.  Normally this is just device discovery when a connect/disconnect
- * has been detected.  But it may also be used by drivers that need to
- * perform (short) tasks that must have a process context.
- */
-struct usb_task {
-	TAILQ_ENTRY(usb_task) next;
-	void (*fun)(void *);
-	void *arg;
-	char onqueue;
-};
-
-void usb_add_task(usbd_device_handle, struct usb_task *);
-void usb_rem_task(usbd_device_handle, struct usb_task *);
-#define usb_init_task(t, f, a) ((t)->fun = (f), (t)->arg = (a), (t)->onqueue = 0)
-
-struct usb_devno {
-	u_int16_t ud_vendor;
-	u_int16_t ud_product;
-};
-const struct usb_devno *usb_match_device(const struct usb_devno *,
-	u_int, u_int, u_int16_t, u_int16_t);
-#define usb_lookup(tbl, vendor, product) \
-	usb_match_device((const struct usb_devno *)(tbl), sizeof (tbl) / sizeof ((tbl)[0]), sizeof ((tbl)[0]), (vendor), (product))
-#define	USB_PRODUCT_ANY		0xffff
-
-/* NetBSD attachment information */
-
-/* Attach data */
-struct usb_attach_arg {
-	int			port;
-	int			configno;
-	int			ifaceno;
-	int			vendor;
-	int			product;
-	int			release;
-	int			matchlvl;
-	usbd_device_handle	device;	/* current device */
-	usbd_interface_handle	iface; /* current interface */
-	int			usegeneric;
-	usbd_interface_handle  *ifaces;	/* all interfaces */
-	int			nifaces; /* number of interfaces */
-};
-
-#if defined(__NetBSD__) || defined(__OpenBSD__)
-/* Match codes. */
-/* First five codes is for a whole device. */
-#define UMATCH_VENDOR_PRODUCT_REV			14
-#define UMATCH_VENDOR_PRODUCT				13
-#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			12
-#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		11
-#define UMATCH_DEVCLASS_DEVSUBCLASS			10
-/* Next six codes are for interfaces. */
-#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		 9
-#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		 8
-#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		 7
-#define UMATCH_VENDOR_IFACESUBCLASS			 6
-#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	 5
-#define UMATCH_IFACECLASS_IFACESUBCLASS			 4
-#define UMATCH_IFACECLASS				 3
-#define UMATCH_IFACECLASS_GENERIC			 2
-/* Generic driver */
-#define UMATCH_GENERIC					 1
-/* No match */
-#define UMATCH_NONE					 0
-
-#elif defined(__FreeBSD__)
-/* FreeBSD needs values less than zero */
-#define UMATCH_VENDOR_PRODUCT_REV			(-10)
-#define UMATCH_VENDOR_PRODUCT				(-20)
-#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			(-30)
-#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		(-40)
-#define UMATCH_DEVCLASS_DEVSUBCLASS			(-50)
-#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		(-60)
-#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		(-70)
-#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		(-80)
-#define UMATCH_VENDOR_IFACESUBCLASS			(-90)
-#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	(-100)
-#define UMATCH_IFACECLASS_IFACESUBCLASS			(-110)
-#define UMATCH_IFACECLASS				(-120)
-#define UMATCH_IFACECLASS_GENERIC			(-130)
-#define UMATCH_GENERIC					(-140)
-#define UMATCH_NONE					(ENXIO)
-
-#endif
-
-#define USBD_SHOW_DEVICE_CLASS		0x1
-#define USBD_SHOW_INTERFACE_CLASS	0x2
-
-#if defined(__FreeBSD__)
-int usbd_driver_load(module_t mod, int what, void *arg);
-
-static inline int
-usb_get_port(device_t dev)
-{
-	struct usb_attach_arg *uap = device_get_ivars(dev);
-	return (uap->port);
-}
-
-static inline struct usbd_interface *
-usb_get_iface(device_t dev)
-{
-	struct usb_attach_arg *uap = device_get_ivars(dev);
-	return (uap->iface);
-}
-
-#endif
-
-/* XXX Perhaps USB should have its own levels? */
-#ifdef USB_USE_SOFTINTR
-#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
-#define splusb splsoftnet
-#else
-#define	splusb splsoftclock
-#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
-#else
-#define splusb splbio
-#endif /* USB_USE_SOFTINTR */
-#define splhardusb splbio
-#define IPL_USB IPL_BIO
-
-#endif /* _USBDI_H_ */
+#include <dev/usb2/usb_subr.h>
Index: sys/dev/usb/usbdi_util.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/usbdi_util.h,v
retrieving revision 1.19
diff -u -r1.19 usbdi_util.h
--- sys/dev/usb/usbdi_util.h	1 Mar 2005 08:01:22 -0000	1.19
+++ sys/dev/usb/usbdi_util.h	8 Jun 2006 18:28:30 -0000
@@ -1,95 +1 @@
-/*	$NetBSD: usbdi_util.h,v 1.31 2004/12/03 08:53:40 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usbdi_util.h,v 1.19 2005/03/01 08:01:22 sobomax Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-usbd_status	usbd_get_desc(usbd_device_handle dev, int type,
-			      int index, int len, void *desc);
-usbd_status	usbd_get_config_desc(usbd_device_handle, int,
-				     usb_config_descriptor_t *);
-usbd_status	usbd_get_config_desc_full(usbd_device_handle, int, void *, int);
-usbd_status	usbd_get_device_desc(usbd_device_handle dev,
-				     usb_device_descriptor_t *d);
-usbd_status	usbd_set_address(usbd_device_handle dev, int addr);
-usbd_status	usbd_get_port_status(usbd_device_handle,
-				     int, usb_port_status_t *);
-usbd_status	usbd_set_hub_feature(usbd_device_handle dev, int);
-usbd_status	usbd_clear_hub_feature(usbd_device_handle, int);
-usbd_status	usbd_set_port_feature(usbd_device_handle dev, int, int);
-usbd_status	usbd_clear_port_feature(usbd_device_handle, int, int);
-usbd_status	usbd_get_device_status(usbd_device_handle, usb_status_t *);
-usbd_status	usbd_get_hub_status(usbd_device_handle, usb_hub_status_t *);
-usbd_status	usbd_get_protocol(usbd_interface_handle dev, u_int8_t *report);
-usbd_status	usbd_set_protocol(usbd_interface_handle dev, int report);
-usbd_status	usbd_get_report_descriptor(usbd_device_handle dev, int ifcno,
-					   int size, void *d);
-struct usb_hid_descriptor *usbd_get_hid_descriptor(usbd_interface_handle ifc);
-usbd_status	usbd_set_report(usbd_interface_handle iface, int type, int id,
-				void *data,int len);
-usbd_status	usbd_set_report_async(usbd_interface_handle iface, int type,
-				      int id, void *data, int len);
-usbd_status	usbd_get_report(usbd_interface_handle iface, int type, int id,
-				void *data, int len);
-usbd_status	usbd_set_idle(usbd_interface_handle iface, int duration, int id);
-usbd_status	usbd_read_report_desc(usbd_interface_handle ifc, void **descp,
-				      int *sizep, usb_malloc_type mem);
-usbd_status	usbd_get_config(usbd_device_handle dev, u_int8_t *conf);
-usbd_status	usbd_get_string_desc(usbd_device_handle dev, int sindex,
-				     int langid,usb_string_descriptor_t *sdesc,
-				     int *sizep);
-void		usbd_delay_ms(usbd_device_handle, u_int);
-
-
-usbd_status usbd_set_config_no(usbd_device_handle dev, int no, int msg);
-usbd_status usbd_set_config_index(usbd_device_handle dev, int index, int msg);
-
-usbd_status usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
-			       u_int16_t flags, u_int32_t timeout, void *buf,
-			       u_int32_t *size, char *lbl);
-
-usbd_status usbd_intr_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
-			       u_int16_t flags, u_int32_t timeout, void *buf,
-			       u_int32_t *size, char *lbl);
-
-void usb_detach_wait(device_ptr_t);
-void usb_detach_wakeup(device_ptr_t);
-
-const usb_descriptor_t *usb_find_desc(usbd_device_handle dev, int type,
-				      int subtype);
-#define USBD_SUBTYPE_ANY (~0)
-
+#include <dev/usb2/usb_subr.h>
Index: sys/dev/usb/usbdivar.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/usbdivar.h,v
retrieving revision 1.43.2.1
diff -u -r1.43.2.1 usbdivar.h
--- sys/dev/usb/usbdivar.h	1 Mar 2006 01:59:05 -0000	1.43.2.1
+++ sys/dev/usb/usbdivar.h	8 Jun 2006 18:28:30 -0000
@@ -1,321 +1 @@
-/*	$NetBSD: usbdivar.h,v 1.70 2002/07/11 21:14:36 augustss Exp $	*/
-/*	$FreeBSD: src/sys/dev/usb/usbdivar.h,v 1.43.2.1 2006/03/01 01:59:05 iedowse Exp $	*/
-
-/*-
- * Copyright (c) 1998 The NetBSD Foundation, Inc.
- * All rights reserved.
- *
- * This code is derived from software contributed to The NetBSD Foundation
- * by Lennart Augustsson (lennart@augustsson.net) at
- * Carlstedt Research & Technology.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *        This product includes software developed by the NetBSD
- *        Foundation, Inc. and its contributors.
- * 4. Neither the name of The NetBSD Foundation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#if defined(__NetBSD__)
-#include <sys/callout.h>
-#endif
-
-/* From usb_mem.h */
-DECLARE_USB_DMA_T;
-
-struct usbd_xfer;
-struct usbd_pipe;
-
-struct usbd_endpoint {
-	usb_endpoint_descriptor_t *edesc;
-	int			refcnt;
-	int			savedtoggle;
-};
-
-struct usbd_bus_methods {
-	usbd_status	      (*open_pipe)(struct usbd_pipe *pipe);
-	void		      (*soft_intr)(void *);
-	void		      (*do_poll)(struct usbd_bus *);
-	usbd_status	      (*allocm)(struct usbd_bus *, usb_dma_t *,
-					u_int32_t bufsize);
-	void		      (*freem)(struct usbd_bus *, usb_dma_t *);
-	struct usbd_xfer *    (*allocx)(struct usbd_bus *);
-	void		      (*freex)(struct usbd_bus *, struct usbd_xfer *);
-};
-
-struct usbd_pipe_methods {
-	usbd_status	      (*transfer)(usbd_xfer_handle xfer);
-	usbd_status	      (*start)(usbd_xfer_handle xfer);
-	void		      (*abort)(usbd_xfer_handle xfer);
-	void		      (*close)(usbd_pipe_handle pipe);
-	void		      (*cleartoggle)(usbd_pipe_handle pipe);
-	void		      (*done)(usbd_xfer_handle xfer);
-};
-
-struct usbd_tt {
-	struct usbd_hub		*hub;
-};
-
-struct usbd_port {
-	usb_port_status_t	status;
-	u_int16_t		power;	/* mA of current on port */
-	u_int8_t		portno;
-	u_int8_t		restartcnt;
-#define USBD_RESTART_MAX 5
-	struct usbd_device     *device;	/* Connected device */
-	struct usbd_device     *parent;	/* The ports hub */
-	struct usbd_tt	       *tt; /* Transaction translator (if any) */
-};
-
-struct usbd_hub {
-	usbd_status	      (*explore)(usbd_device_handle hub);
-	void		       *hubsoftc;
-	usb_hub_descriptor_t	hubdesc;
-	struct usbd_port        ports[1];
-};
-
-struct usb_softc;
-
-/*****/
-
-struct usbd_bus {
-	/* Filled by HC driver */
-	USBBASEDEVICE		bdev; /* base device, host adapter */
-	struct usbd_bus_methods	*methods;
-	u_int32_t		pipe_size; /* size of a pipe struct */
-	/* Filled by usb driver */
-	struct usbd_device     *root_hub;
-	usbd_device_handle	devices[USB_MAX_DEVICES];
-	char			needs_explore;/* a hub a signalled a change */
-	char			use_polling;
-	struct usb_softc       *usbctl;
-	struct usb_device_stats	stats;
-	int 			intr_context;
-	u_int			no_intrs;
-	int			usbrev;	/* USB revision */
-#define USBREV_UNKNOWN	0
-#define USBREV_PRE_1_0	1
-#define USBREV_1_0	2
-#define USBREV_1_1	3
-#define USBREV_2_0	4
-#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1", "2.0" }
-
-#ifdef USB_USE_SOFTINTR
-#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
-	void		       *soft; /* soft interrupt cookie */
-#else
-	struct callout		softi;
-#endif
-#endif
-
-	bus_dma_tag_t		dmatag;	/* DMA tag */
-};
-
-struct usbd_device {
-	struct usbd_bus	       *bus;           /* our controller */
-	struct usbd_pipe       *default_pipe;  /* pipe 0 */
-	u_int8_t		address;       /* device addess */
-	u_int8_t		config;	       /* current configuration # */
-	u_int8_t		depth;         /* distance from root hub */
-	u_int8_t		speed;         /* low/full/high speed */
-	u_int8_t		self_powered;  /* flag for self powered */
-	u_int16_t		power;         /* mA the device uses */
-	int16_t			langid;	       /* language for strings */
-#define USBD_NOLANG (-1)
-	usb_event_cookie_t	cookie;	       /* unique connection id */
-	struct usbd_port       *powersrc;      /* upstream hub port, or 0 */
-	struct usbd_device     *myhub;	       /* upstream hub */
-	struct usbd_port       *myhsport;      /* closest high speed port */
-	struct usbd_endpoint	def_ep;	       /* for pipe 0 */
-	usb_endpoint_descriptor_t def_ep_desc; /* for pipe 0 */
-	struct usbd_interface  *ifaces;        /* array of all interfaces */
-	usb_device_descriptor_t ddesc;         /* device descriptor */
-	usb_config_descriptor_t *cdesc;	       /* full config descr */
-	const struct usbd_quirks     *quirks;  /* device quirks, always set */
-	struct usbd_hub	       *hub;           /* only if this is a hub */
-	device_ptr_t	       *subdevs;       /* sub-devices, 0 terminated */
-	uint8_t		       *ifacenums;     /* sub-device interfacenumbers */
-};
-
-struct usbd_interface {
-	struct usbd_device     *device;
-	usb_interface_descriptor_t *idesc;
-	int			index;
-	int			altindex;
-	struct usbd_endpoint   *endpoints;
-	void		       *priv;
-	LIST_HEAD(, usbd_pipe)	pipes;
-};
-
-struct usbd_pipe {
-	struct usbd_interface  *iface;
-	struct usbd_device     *device;
-	struct usbd_endpoint   *endpoint;
-	int			refcnt;
-	char			running;
-	char			aborting;
-	SIMPLEQ_HEAD(, usbd_xfer) queue;
-	LIST_ENTRY(usbd_pipe)	next;
-
-	usbd_xfer_handle	intrxfer; /* used for repeating requests */
-	char			repeat;
-	int			interval;
-
-	/* Filled by HC driver. */
-	struct usbd_pipe_methods *methods;
-};
-
-struct usbd_xfer {
-	struct usbd_pipe       *pipe;
-	void		       *priv;
-	void		       *buffer;
-	u_int32_t		length;
-	u_int32_t		actlen;
-	u_int16_t		flags;
-	u_int32_t		timeout;
-	usbd_status		status;
-	usbd_callback		callback;
-	__volatile char		done;
-#ifdef DIAGNOSTIC
-	u_int32_t		busy_free;
-#define XFER_FREE 0x46524545
-#define XFER_BUSY 0x42555359
-#define XFER_ONQU 0x4f4e5155
-#endif
-
-	/* For control pipe */
-	usb_device_request_t	request;
-
-	/* For isoc */
-	u_int16_t		*frlengths;
-	int			nframes;
-
-	/* For memory allocation */
-	struct usbd_device     *device;
-	usb_dma_t		dmabuf;
-
-	int			rqflags;
-#define URQ_REQUEST	0x01
-#define URQ_AUTO_DMABUF	0x10
-#define URQ_DEV_DMABUF	0x20
-
-	SIMPLEQ_ENTRY(usbd_xfer) next;
-
-	void		       *hcpriv; /* private use by the HC driver */
-
-	usb_callout_t		timeout_handle;
-};
-
-void usbd_init(void);
-void usbd_finish(void);
-
-#ifdef USB_DEBUG
-void usbd_dump_iface(struct usbd_interface *iface);
-void usbd_dump_device(struct usbd_device *dev);
-void usbd_dump_endpoint(struct usbd_endpoint *endp);
-void usbd_dump_queue(usbd_pipe_handle pipe);
-void usbd_dump_pipe(usbd_pipe_handle pipe);
-#endif
-
-/* Routines from usb_subr.c */
-int		usbctlprint(void *, const char *);
-void		usb_delay_ms(usbd_bus_handle, u_int);
-usbd_status	usbd_reset_port(usbd_device_handle dev,
-				int port, usb_port_status_t *ps);
-usbd_status	usbd_setup_pipe(usbd_device_handle dev,
-				usbd_interface_handle iface,
-				struct usbd_endpoint *, int,
-				usbd_pipe_handle *pipe);
-usbd_status	usbd_new_device(device_ptr_t parent,
-				usbd_bus_handle bus, int depth,
-				int lowspeed, int port,
-				struct usbd_port *);
-void		usbd_remove_device(usbd_device_handle, struct usbd_port *);
-int		usbd_printBCD(char *cp, int bcd);
-usbd_status	usbd_fill_iface_data(usbd_device_handle dev, int i, int a);
-void		usb_free_device(usbd_device_handle);
-
-usbd_status	usb_insert_transfer(usbd_xfer_handle xfer);
-void		usb_transfer_complete(usbd_xfer_handle xfer);
-void		usb_disconnect_port(struct usbd_port *up, device_ptr_t);
-
-/* Routines from usb.c */
-void		usb_needs_explore(usbd_device_handle);
-void		usb_schedsoftintr(struct usbd_bus *);
-
-/*
- * XXX This check is extremely bogus. Bad Bad Bad.
- */
-#if defined(DIAGNOSTIC) && 0
-#define SPLUSBCHECK \
-	do { int _s = splusb(), _su = splusb(); \
-             if (!cold && _s != _su) printf("SPLUSBCHECK failed 0x%x!=0x%x, %s:%d\n", \
-				   _s, _su, __FILE__, __LINE__); \
-	     splx(_s); \
-        } while (0)
-#else
-#define SPLUSBCHECK
-#endif
-
-/* Locator stuff. */
-
-#if defined(__NetBSD__)
-#include "locators.h"
-#elif defined(__FreeBSD__) || defined(__OpenBSD__)
-/* XXX these values are used to statically bind some elements in the USB tree
- * to specific driver instances. This should be somehow emulated in FreeBSD
- * but can be done later on.
- * The values are copied from the files.usb file in the NetBSD sources.
- */
-#define UHUBCF_PORT_DEFAULT -1
-#define UHUBCF_CONFIGURATION_DEFAULT -1
-#define UHUBCF_INTERFACE_DEFAULT -1
-#define UHUBCF_VENDOR_DEFAULT -1
-#define UHUBCF_PRODUCT_DEFAULT -1
-#define UHUBCF_RELEASE_DEFAULT -1
-#endif
-
-#if defined (__OpenBSD__)
-#define	UHUBCF_PORT		0
-#define	UHUBCF_CONFIGURATION	1
-#define	UHUBCF_INTERFACE	2
-#define	UHUBCF_VENDOR		3
-#define	UHUBCF_PRODUCT		4
-#define	UHUBCF_RELEASE		5
-#endif
-
-#define	uhubcf_port		cf_loc[UHUBCF_PORT]
-#define	uhubcf_configuration	cf_loc[UHUBCF_CONFIGURATION]
-#define	uhubcf_interface	cf_loc[UHUBCF_INTERFACE]
-#define	uhubcf_vendor		cf_loc[UHUBCF_VENDOR]
-#define	uhubcf_product		cf_loc[UHUBCF_PRODUCT]
-#define	uhubcf_release		cf_loc[UHUBCF_RELEASE]
-#define	UHUB_UNK_PORT		UHUBCF_PORT_DEFAULT /* wildcarded 'port' */
-#define	UHUB_UNK_CONFIGURATION	UHUBCF_CONFIGURATION_DEFAULT /* wildcarded 'configuration' */
-#define	UHUB_UNK_INTERFACE	UHUBCF_INTERFACE_DEFAULT /* wildcarded 'interface' */
-#define	UHUB_UNK_VENDOR		UHUBCF_VENDOR_DEFAULT /* wildcarded 'vendor' */
-#define	UHUB_UNK_PRODUCT	UHUBCF_PRODUCT_DEFAULT /* wildcarded 'product' */
-#define	UHUB_UNK_RELEASE	UHUBCF_RELEASE_DEFAULT /* wildcarded 'release' */
-
+#include <dev/usb2/usb_subr.h>
Index: sys/dev/usb/uvisor.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/usb/uvisor.c,v
retrieving revision 1.24.2.1
diff -u -r1.24.2.1 uvisor.c
--- sys/dev/usb/uvisor.c	12 Dec 2005 19:52:52 -0000	1.24.2.1
+++ sys/dev/usb/uvisor.c	8 Jun 2006 18:28:30 -0000
@@ -62,6 +62,7 @@
 #include <sys/device.h>
 #elif defined(__FreeBSD__)
 #include <sys/module.h>
+#include <sys/malloc.h>
 #include <sys/bus.h>
 #endif
 #include <sys/conf.h>
Index: sys/modules/ugen/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/modules/ugen/Makefile,v
retrieving revision 1.14
diff -u -r1.14 Makefile
--- sys/modules/ugen/Makefile	4 Jun 2005 10:58:38 -0000	1.14
+++ sys/modules/ugen/Makefile	8 Jun 2006 18:28:30 -0000
@@ -1,8 +1,10 @@
-# $FreeBSD: src/sys/modules/ugen/Makefile,v 1.14 2005/06/04 10:58:38 schweikh Exp $
+# $FreeBSD: src/sys/modules/ugen/Makefile,v 1.12 2004/06/27 12:33:18 imp Exp $ 
 
-.PATH: ${.CURDIR}/../../dev/usb
+MAINTAINER=	n_hibma@freebsd.org
+
+.PATH: ${.CURDIR}/../../dev/usb ${.CURDIR}/../../dev/usb2
 
 KMOD=	ugen
-SRCS=	bus_if.h device_if.h opt_usb.h ugen.c usbdevs.h
+SRCS=	bus_if.h device_if.h vnode_if.h opt_usb.h _ugen.c usbdevs.h
 
 .include <bsd.kmod.mk>
Index: sys/modules/usb/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/modules/usb/Makefile,v
retrieving revision 1.18
diff -u -r1.18 Makefile
--- sys/modules/usb/Makefile	4 Jun 2005 10:58:39 -0000	1.18
+++ sys/modules/usb/Makefile	8 Jun 2006 18:28:30 -0000
@@ -1,27 +1,28 @@
-# $FreeBSD: src/sys/modules/usb/Makefile,v 1.18 2005/06/04 10:58:39 schweikh Exp $
+# $FreeBSD: src/sys/modules/usb/Makefile,v 1.15 2004/07/12 21:59:06 imp Exp $ 
+
+MAINTAINER=	n_hibma@freebsd.org
 
 S=	${.CURDIR}/../..
 
-.PATH: $S/dev/usb $S/pci
+.PATH: $S/dev/usb $S/dev/usb2 $S/pci
 
 KMOD=	usb
 SRCS=	bus_if.h device_if.h usb_if.h usb_if.c \
+	vnode_if.h \
 	opt_usb.h \
 	hid.c hid.h usbhid.h \
-	uhub.c \
-	usb.c usb.h \
-	usb_mem.c usb_mem.h \
-	usb_port.h \
-	usb_quirks.c usb_quirks.h \
-	usb_subr.c \
-	usbdevs.h usbdevs_data.h \
-	usbdi.c usbdi.h usbdivar.h \
-	usbdi_util.c usbdi_util.h \
-	usb_ethersubr.c usbdevs.h
-
-SRCS+=	uhci_pci.c uhci.c uhcireg.h uhcivar.h
-SRCS+=	ohci_pci.c ohci.c ohcireg.h ohcivar.h
-SRCS+=	ehci_pci.c ehci.c ehcireg.h ehcivar.h
+	usb_quirks.c ../usb/usb_quirks.h \
+	usb_ethersubr.c usbdevs.h \
+	_uhub.c \
+	_usb.c ../usb2/usb.h \
+	_usb_requests.c \
+	_usb_subr.c ../usb2/usb_subr.h \
+	_usb_transfer.c \
+	../usb2/usb_port.h
+
+SRCS+=	_uhci_pci.c _uhci.c ../usb2/uhci.h
+SRCS+=	_ohci_pci.c _ohci.c ../usb2/ohci.h
+SRCS+=	_ehci_pci.c _ehci.c ../usb2/ehci.h
 SRCS+=	opt_bus.h pci_if.h
 
 .include <bsd.kmod.mk>
Index: sys/tools/usbdevs2h.awk
===================================================================
RCS file: /home/ncvs/src/sys/tools/usbdevs2h.awk,v
retrieving revision 1.7
diff -u -r1.7 usbdevs2h.awk
--- sys/tools/usbdevs2h.awk	7 Jan 2005 02:29:25 -0000	1.7
+++ sys/tools/usbdevs2h.awk	8 Jun 2006 18:28:30 -0000
@@ -1,7 +1,6 @@
 #! /usr/bin/awk -f
-#-
 #	$NetBSD: usb/devlist2h.awk,v 1.9 2001/01/18 20:28:22 jdolecek Exp $
-#  $FreeBSD: src/sys/tools/usbdevs2h.awk,v 1.7 2005/01/07 02:29:25 imp Exp $
+#  $FreeBSD: src/sys/tools/usbdevs2h.awk,v 1.3 2004/04/16 05:22:11 obrien Exp $
 #
 # Copyright (c) 1995, 1996 Christopher G. Demetriou
 # All rights reserved.
@@ -31,142 +30,157 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
+BEGIN {
+	nproducts = nvendors = 0
+	dfile="usbdevs_data.h"
+	hfile="usbdevs.h"
+}
+NR == 1 {
+	VERSION = $0
+	gsub("\\$", "", VERSION)
 
-function usage()
-{
-	print "usage: usbdevs2h.awk <srcfile> [-d|-h]";
-	exit 1;
-}
+	if (os == "NetBSD")
+		printf("/*\t\$NetBSD\$\t*/\n\n") > dfile
+	else if (os == "FreeBSD")
+		printf("/* \$FreeBSD\$ */\n\n") > dfile
+	else if (os == "OpenBSD")
+		printf("/*\t\$OpenBSD\$\t*/\n\n") > dfile
+	else
+		printf("/* ??? */\n\n") > dfile
+	printf("/*\n") > dfile
+	printf(" * THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT EDIT.\n") \
+	    > dfile
+	printf(" *\n") > dfile
+	printf(" * generated from:\n") > dfile
+	printf(" *\t%s\n", VERSION) > dfile
+	printf(" */\n") > dfile
 
-function header(file)
-{
 	if (os == "NetBSD")
-		printf("/*\t\$NetBSD\$\t*/\n\n") > file
+		printf("/*\t\$NetBSD\$\t*/\n\n") > hfile
 	else if (os == "FreeBSD")
-		printf("/* \$FreeBSD\$ */\n\n") > file
+		printf("/* \$FreeBSD\$ */\n\n") > hfile
 	else if (os == "OpenBSD")
-		printf("/*\t\$OpenBSD\$\t*/\n\n") > file
+		printf("/*\t\$OpenBSD\$\t*/\n\n") > hfile
 	else
-		printf("/* ??? */\n\n") > file
-	printf("/*\n") > file
+		printf("/* ??? */\n\n") > hfile
+	printf("/*\n") > hfile
 	printf(" * THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT EDIT.\n") \
-	    > file
-	printf(" *\n") > file
-	printf(" * generated from:\n") > file
-	printf(" *\t%s\n", VERSION) > file
-	printf(" */\n") > file
-}
+	    > hfile
+	printf(" *\n") > hfile
+	printf(" * generated from:\n") > hfile
+	printf(" *\t%s\n", VERSION) > hfile
+	printf(" */\n") > hfile
 
-function vendor(hfile)
-{
+	next
+}
+$1 == "vendor" {
 	nvendors++
 
 	vendorindex[$2] = nvendors;		# record index for this name, for later.
 	vendors[nvendors, 1] = $2;		# name
 	vendors[nvendors, 2] = $3;		# id
-	if (hfile)
-		printf("#define\tUSB_VENDOR_%s\t%s\t", vendors[nvendors, 1],
-		    vendors[nvendors, 2]) > hfile
+	printf("#define\tUSB_VENDOR_%s\t%s\t", vendors[nvendors, 1],
+	    vendors[nvendors, 2]) > hfile
+
 	i = 3; f = 4;
 
 	# comments
 	ocomment = oparen = 0
 	if (f <= NF) {
-		if (hfile)
-			printf("\t/* ") > hfile
+		printf("\t/* ") > hfile
 		ocomment = 1;
 	}
 	while (f <= NF) {
 		if ($f == "#") {
-			if (hfile)
-				printf("(") > hfile
+			printf("(") > hfile
 			oparen = 1
 			f++
 			continue
 		}
 		if (oparen) {
-			if (hfile)
-				printf("%s", $f) > hfile
-			if (f < NF && hfile)
+			printf("%s", $f) > hfile
+			if (f < NF)
 				printf(" ") > hfile
 			f++
 			continue
 		}
 		vendors[nvendors, i] = $f
-		if (hfile)
-			printf("%s", vendors[nvendors, i]) > hfile
-		if (f < NF && hfile)
+		printf("%s", vendors[nvendors, i]) > hfile
+		if (f < NF)
 			printf(" ") > hfile
 		i++; f++;
 	}
-	if (oparen && hfile)
+	if (oparen)
 		printf(")") > hfile
-	if (ocomment && hfile)
+	if (ocomment)
 		printf(" */") > hfile
-	if (hfile)
-		printf("\n") > hfile
-}
+	printf("\n") > hfile
 
-function product(hfile)
-{
+	next
+}
+$1 == "product" {
 	nproducts++
 
 	products[nproducts, 1] = $2;		# vendor name
 	products[nproducts, 2] = $3;		# product id
 	products[nproducts, 3] = $4;		# id
-	if (hfile)
-		printf("#define\tUSB_PRODUCT_%s_%s\t%s\t", \
-		  products[nproducts, 1], products[nproducts, 2], \
-		  products[nproducts, 3]) > hfile
+	printf("#define\tUSB_PRODUCT_%s_%s\t%s\t", products[nproducts, 1],
+	    products[nproducts, 2], products[nproducts, 3]) > hfile
 
 	i=4; f = 5;
 
 	# comments
 	ocomment = oparen = 0
 	if (f <= NF) {
-		if (hfile)
-			printf("\t/* ") > hfile
+		printf("\t/* ") > hfile
 		ocomment = 1;
 	}
 	while (f <= NF) {
 		if ($f == "#") {
-			if (hfile)
-				printf("(") > hfile
+			printf("(") > hfile
 			oparen = 1
 			f++
 			continue
 		}
 		if (oparen) {
-			if (hfile)
-				printf("%s", $f) > hfile
-			if (f < NF && hfile)
+			printf("%s", $f) > hfile
+			if (f < NF)
 				printf(" ") > hfile
 			f++
 			continue
 		}
 		products[nproducts, i] = $f
-		if (hfile)
-			printf("%s", products[nproducts, i]) > hfile
-		if (f < NF && hfile)
+		printf("%s", products[nproducts, i]) > hfile
+		if (f < NF)
 			printf(" ") > hfile
 		i++; f++;
 	}
-	if (oparen && hfile)
+	if (oparen)
 		printf(")") > hfile
-	if (ocomment && hfile)
+	if (ocomment)
 		printf(" */") > hfile
-	if (hfile)
-		printf("\n") > hfile
-}
+	printf("\n") > hfile
 
-function dump_dfile(dfile)
+	next
+}
 {
+	if ($0 == "")
+		blanklines++
+	print $0 > hfile
+	if (blanklines < 2)
+		print $0 > dfile
+}
+END {
+	# print out the match tables
+
 	printf("\n") > dfile
+
 	printf("const struct usb_knowndev usb_knowndevs[] = {\n") > dfile
 	for (i = 1; i <= nproducts; i++) {
 		printf("\t{\n") > dfile
 		printf("\t    USB_VENDOR_%s, USB_PRODUCT_%s_%s,\n",
-		    products[i, 1], products[i, 1], products[i, 2]) > dfile
+		    products[i, 1], products[i, 1], products[i, 2]) \
+		    > dfile
 		printf("\t    ") > dfile
 		printf("0") > dfile
 		printf(",\n") > dfile
@@ -199,8 +213,10 @@
 	}
 	for (i = 1; i <= nvendors; i++) {
 		printf("\t{\n") > dfile
-		printf("\t    USB_VENDOR_%s, 0,\n", vendors[i, 1]) > dfile
-		printf("\t    USB_KNOWNDEV_NOPROD,\n") > dfile
+		printf("\t    USB_VENDOR_%s, 0,\n", vendors[i, 1]) \
+		    > dfile
+		printf("\t    USB_KNOWNDEV_NOPROD,\n") \
+		    > dfile
 		printf("\t    \"") > dfile
 		j = 3;
 		needspace = 0;
@@ -218,54 +234,3 @@
 	printf("\t{ 0, 0, 0, NULL, NULL, }\n") > dfile
 	printf("};\n") > dfile
 }
-
-BEGIN {
-
-nproducts = nvendors = 0
-# Process the command line
-for (i = 1; i < ARGC; i++) {
-	arg = ARGV[i];
-	if (arg !~ /^-[dh]+$/ && arg !~ /devs$/)
-		usage();
-	if (arg ~ /^-.*d/)
-		dfile="usbdevs_data.h"
-	if (arg ~ /^-.*h/)
-		hfile="usbdevs.h"
-	if (arg ~ /devs$/)
-		srcfile = arg;
-}
-ARGC = 1;
-line=0;
-
-while ((getline < srcfile) > 0) {
-	line++;
-	if (line == 1) {
-		VERSION = $0
-		gsub("\\$", "", VERSION)
-		if (dfile)
-			header(dfile)
-		if (hfile)
-			header(hfile)
-		continue;
-	}
-	if ($1 == "vendor") {
-		vendor(hfile)
-		continue
-	}
-	if ($1 == "product") {
-		product(hfile)
-		continue
-	}
-	if ($0 == "")
-		blanklines++
-	if (hfile)
-		print $0 > hfile
-	if (blanklines < 2 && dfile)
-	    print $0 > dfile
-}
-
-# print out the match tables
-
-if (dfile)
-	dump_dfile(dfile)
-}
