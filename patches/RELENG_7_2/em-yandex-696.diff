Index: LICENSE
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/LICENSE,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 LICENSE
--- LICENSE	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ LICENSE	30 Apr 2009 19:54:57 -0000
@@ -1,4 +1,4 @@
-$FreeBSD: src/sys/dev/e1000/LICENSE,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $
+$FreeBSD: src/sys/dev/e1000/LICENSE,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $
 
   Copyright (c) 2001-2008, Intel Corporation 
   All rights reserved.
Index: README
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/README,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 README
--- README	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ README	30 Apr 2009 19:54:57 -0000
@@ -1,4 +1,4 @@
-$FreeBSD: src/sys/dev/e1000/README,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $
+$FreeBSD: src/sys/dev/e1000/README,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $
 FreeBSD* Driver for Intel Network Connection
 =============================================
 
Index: e1000_80003es2lan.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_80003es2lan.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_80003es2lan.c
--- e1000_80003es2lan.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_80003es2lan.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_80003es2lan.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_80003es2lan.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 80003ES2LAN Gigabit Ethernet Controller (Copper)
Index: e1000_80003es2lan.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_80003es2lan.h,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 e1000_80003es2lan.h
--- e1000_80003es2lan.h	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ e1000_80003es2lan.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_80003es2lan.h,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_80003es2lan.h,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $*/
 
 
 #ifndef _E1000_80003ES2LAN_H_
Index: e1000_82540.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82540.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_82540.c
--- e1000_82540.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_82540.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82540.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82540.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 82540EM Gigabit Ethernet Controller
Index: e1000_82541.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82541.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_82541.c
--- e1000_82541.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_82541.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82541.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82541.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 82541EI Gigabit Ethernet Controller
Index: e1000_82541.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82541.h,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 e1000_82541.h
--- e1000_82541.h	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ e1000_82541.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82541.h,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82541.h,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $*/
 
 #ifndef _E1000_82541_H_
 #define _E1000_82541_H_
Index: e1000_82542.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82542.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_82542.c
--- e1000_82542.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_82542.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82542.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82542.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 82542 Gigabit Ethernet Controller
Index: e1000_82543.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82543.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_82543.c
--- e1000_82543.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_82543.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82543.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82543.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 82543GC Gigabit Ethernet Controller (Fiber)
Index: e1000_82543.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82543.h,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 e1000_82543.h
--- e1000_82543.h	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ e1000_82543.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82543.h,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82543.h,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $*/
 
 #ifndef _E1000_82543_H_
 #define _E1000_82543_H_
Index: e1000_82571.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82571.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_82571.c
--- e1000_82571.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_82571.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82571.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82571.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 82571EB Gigabit Ethernet Controller
Index: e1000_82571.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82571.h,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 e1000_82571.h
--- e1000_82571.h	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ e1000_82571.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82571.h,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82571.h,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $*/
 
 #ifndef _E1000_82571_H_
 #define _E1000_82571_H_
Index: e1000_82575.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82575.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_82575.c
--- e1000_82575.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_82575.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82575.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82575.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 82575EB Gigabit Network Connection
Index: e1000_82575.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_82575.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_82575.h
--- e1000_82575.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_82575.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_82575.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_82575.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_82575_H_
 #define _E1000_82575_H_
Index: e1000_api.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_api.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_api.c
--- e1000_api.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_api.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_api.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_api.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #include "e1000_api.h"
 
Index: e1000_api.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_api.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_api.h
--- e1000_api.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_api.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_api.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_api.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_API_H_
 #define _E1000_API_H_
Index: e1000_defines.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_defines.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_defines.h
--- e1000_defines.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_defines.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_defines.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_defines.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_DEFINES_H_
 #define _E1000_DEFINES_H_
@@ -799,7 +799,6 @@
  */
 #define IMS_ENABLE_MASK ( \
     E1000_IMS_RXT0   |    \
-    E1000_IMS_TXDW   |    \
     E1000_IMS_RXDMT0 |    \
     E1000_IMS_RXSEQ  |    \
     E1000_IMS_LSC)
Index: e1000_hw.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_hw.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_hw.h
--- e1000_hw.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_hw.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_hw.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_hw.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_HW_H_
 #define _E1000_HW_H_
Index: e1000_ich8lan.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_ich8lan.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_ich8lan.c
--- e1000_ich8lan.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_ich8lan.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_ich8lan.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_ich8lan.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 /*
  * 82562G 10/100 Network Connection
Index: e1000_ich8lan.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_ich8lan.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_ich8lan.h
--- e1000_ich8lan.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_ich8lan.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_ich8lan.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_ich8lan.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_ICH8LAN_H_
 #define _E1000_ICH8LAN_H_
Index: e1000_mac.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_mac.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_mac.c
--- e1000_mac.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_mac.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_mac.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_mac.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #include "e1000_api.h"
 
Index: e1000_mac.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_mac.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_mac.h
--- e1000_mac.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_mac.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_mac.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_mac.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_MAC_H_
 #define _E1000_MAC_H_
Index: e1000_manage.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_manage.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_manage.c
--- e1000_manage.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_manage.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_manage.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_manage.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #include "e1000_api.h"
 
Index: e1000_manage.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_manage.h,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 e1000_manage.h
--- e1000_manage.h	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ e1000_manage.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_manage.h,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_manage.h,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $*/
 
 #ifndef _E1000_MANAGE_H_
 #define _E1000_MANAGE_H_
Index: e1000_nvm.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_nvm.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_nvm.c
--- e1000_nvm.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_nvm.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_nvm.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_nvm.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #include "e1000_api.h"
 
Index: e1000_nvm.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_nvm.h,v
retrieving revision 1.1.2.1.2.1
diff -u -r1.1.2.1.2.1 e1000_nvm.h
--- e1000_nvm.h	25 Nov 2008 02:59:29 -0000	1.1.2.1.2.1
+++ e1000_nvm.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_nvm.h,v 1.1.2.1.2.1 2008/11/25 02:59:29 kensmith Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_nvm.h,v 1.1.2.1 2008/08/11 18:33:10 jfv Exp $*/
 
 #ifndef _E1000_NVM_H_
 #define _E1000_NVM_H_
Index: e1000_osdep.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_osdep.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_osdep.c
--- e1000_osdep.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_osdep.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_osdep.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_osdep.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #include "e1000_api.h"
 
Index: e1000_osdep.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_osdep.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_osdep.h
--- e1000_osdep.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_osdep.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_osdep.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_osdep.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 
 #ifndef _FREEBSD_OS_H_
Index: e1000_phy.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_phy.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_phy.c
--- e1000_phy.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_phy.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_phy.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_phy.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #include "e1000_api.h"
 
Index: e1000_phy.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_phy.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_phy.h
--- e1000_phy.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_phy.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_phy.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_phy.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_PHY_H_
 #define _E1000_PHY_H_
Index: e1000_regs.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/e1000_regs.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 e1000_regs.h
--- e1000_regs.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ e1000_regs.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/e1000_regs.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/e1000_regs.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _E1000_REGS_H_
 #define _E1000_REGS_H_
Index: if_em.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/if_em.c,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 if_em.c
--- if_em.c	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ if_em.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/if_em.c,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/if_em.c,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifdef HAVE_KERNEL_OPTION_HEADERS
 #include "opt_device_polling.h"
@@ -49,12 +49,13 @@
 #include <sys/socket.h>
 #include <sys/sockio.h>
 #include <sys/sysctl.h>
-#include <sys/taskqueue.h>
 #include <sys/eventhandler.h>
 #ifdef EM_TIMESYNC
 #include <sys/ioccom.h>
 #include <sys/time.h>
 #endif
+#include <sys/proc.h>
+#include <sys/sched.h>
 #include <machine/bus.h>
 #include <machine/resource.h>
 
@@ -92,7 +93,7 @@
 /*********************************************************************
  *  Driver version:
  *********************************************************************/
-char em_driver_version[] = "6.9.6";
+char em_driver_version[] = "6.9.6.Yandex[$Revision: 1.36.2.10 $]";
 
 
 /*********************************************************************
@@ -252,14 +253,19 @@
 static void	em_initialize_receive_unit(struct adapter *);
 static void	em_enable_intr(struct adapter *);
 static void	em_disable_intr(struct adapter *);
+#ifndef EM_LEGACY_IRQ
+static void	em_enable_intr_rx(struct adapter *);
+static void	em_disable_intr_rx(struct adapter *);
+static void	em_enable_intr_tx(struct adapter *);
+static void	em_disable_intr_tx(struct adapter *);
+#endif
 static void	em_free_transmit_structures(struct adapter *);
 static void	em_free_receive_structures(struct adapter *);
 static void	em_update_stats_counters(struct adapter *);
 static void	em_txeof(struct adapter *);
-static void	em_tx_purge(struct adapter *);
 static int	em_allocate_receive_structures(struct adapter *);
 static int	em_allocate_transmit_structures(struct adapter *);
-static int	em_rxeof(struct adapter *, int);
+static int	em_rxeof(struct adapter *, int, int);
 #ifndef __NO_STRICT_ALIGNMENT
 static int	em_fixup_rx(struct adapter *);
 #endif
@@ -317,7 +323,7 @@
 
 #ifdef EM_LEGACY_IRQ
 static void	em_intr(void *);
-#else /* FAST IRQ */
+#else /* LEGACY IRQ */
 #if __FreeBSD_version < 700000
 static void	em_irq_fast(void *);
 #else
@@ -327,14 +333,14 @@
 static void	em_msix_tx(void *);
 static void	em_msix_rx(void *);
 static void	em_msix_link(void *);
-static void	em_add_rx_process_limit(struct adapter *, const char *,
-		    const char *, int *, int);
-static void	em_handle_rxtx(void *context, int pending);
-static void	em_handle_rx(void *context, int pending);
-static void	em_handle_tx(void *context, int pending);
-static void	em_handle_link(void *context, int pending);
+static void	em_handle_link(void *arg);
+static void	em_kthread_rx(void *);
+static void	em_kthread_txcleaner(void *);
 #endif /* EM_LEGACY_IRQ */
 
+static void em_tx_purge(struct adapter *adapter);
+
+
 #ifdef DEVICE_POLLING
 static poll_handler_t em_poll;
 #endif /* POLLING */
@@ -399,9 +405,11 @@
 TUNABLE_INT("hw.em.enable_msi", &em_enable_msi);
 
 #ifndef EM_LEGACY_IRQ
-/* How many packets rxeof tries to clean at a time */
-static int em_rx_process_limit = 100;
-TUNABLE_INT("hw.em.rx_process_limit", &em_rx_process_limit);
+static int em_rx_kthread_priority = PRI_MAX_KERN;
+TUNABLE_INT("hw.em.rx_kthread_priority", &em_rx_kthread_priority);
+static int	em_sysctl_rx_kthreads(SYSCTL_HANDLER_ARGS);
+static void     em_add_int_rx_kthread_priority(struct adapter *, const char *,
+                const char *, int *, int);
 #endif
 
 /* Global used in WOL setup with multiport cards */
@@ -419,7 +427,7 @@
 static int
 em_probe(device_t dev)
 {
-	char		adapter_name[60];
+	char		adapter_name[90];
 	u16		pci_vendor_id = 0;
 	u16		pci_device_id = 0;
 	u16		pci_subvendor_id = 0;
@@ -495,6 +503,12 @@
 	    OID_AUTO, "stats", CTLTYPE_INT|CTLFLAG_RW, adapter, 0,
 	    em_sysctl_stats, "I", "Statistics");
 
+#ifndef EM_LEGACY_IRQ
+	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, "rx_kthreads", CTLTYPE_UINT|CTLFLAG_RW, adapter, 0,
+	    em_sysctl_rx_kthreads, "IU", "RX Kthreads");
+#endif
 	callout_init_mtx(&adapter->timer, &adapter->core_mtx, 0);
 	callout_init_mtx(&adapter->tx_fifo_timer, &adapter->tx_mtx, 0);
 
@@ -563,10 +577,10 @@
 	}
 
 #ifndef EM_LEGACY_IRQ
-	/* Sysctls for limiting the amount of work done in the taskqueue */
-	em_add_rx_process_limit(adapter, "rx_processing_limit",
-	    "max number of rx packets to process", &adapter->rx_process_limit,
-	    em_rx_process_limit);
+        /* Sysctls for set the RX kthreads' priority */
+        em_add_int_rx_kthread_priority(adapter, "rx_kthread_priority",
+            "priority of RX handler kthread", &adapter->rx_kthread_priority,
+            em_rx_kthread_priority);
 #endif
 
 	/*
@@ -574,24 +588,44 @@
 	 * must not exceed hardware maximum, and must be multiple
 	 * of E1000_DBA_ALIGN.
 	 */
-	if (((em_txd * sizeof(struct e1000_tx_desc)) % EM_DBA_ALIGN) != 0 ||
-	    (adapter->hw.mac.type >= e1000_82544 && em_txd > EM_MAX_TXD) ||
-	    (adapter->hw.mac.type < e1000_82544 && em_txd > EM_MAX_TXD_82543) ||
-	    (em_txd < EM_MIN_TXD)) {
-		device_printf(dev, "Using %d TX descriptors instead of %d!\n",
-		    EM_DEFAULT_TXD, em_txd);
-		adapter->num_tx_desc = EM_DEFAULT_TXD;
-	} else
-		adapter->num_tx_desc = em_txd;
-	if (((em_rxd * sizeof(struct e1000_rx_desc)) % EM_DBA_ALIGN) != 0 ||
-	    (adapter->hw.mac.type >= e1000_82544 && em_rxd > EM_MAX_RXD) ||
-	    (adapter->hw.mac.type < e1000_82544 && em_rxd > EM_MAX_RXD_82543) ||
-	    (em_rxd < EM_MIN_RXD)) {
-		device_printf(dev, "Using %d RX descriptors instead of %d!\n",
-		    EM_DEFAULT_RXD, em_rxd);
-		adapter->num_rx_desc = EM_DEFAULT_RXD;
-	} else
-		adapter->num_rx_desc = em_rxd;
+	if (adapter->hw.mac.type >= e1000_82544) {
+		adapter->num_tx_desc = EM_MAX_TXD;
+		adapter->num_rx_desc = EM_MAX_RXD;
+	} else {
+		adapter->num_tx_desc = EM_MAX_TXD_82543;
+		adapter->num_rx_desc = EM_MAX_RXD_82543;
+	}
+
+	if (adapter->hw.mac.type == e1000_82544) 
+		adapter -> use_txd_low = 0;
+	else {
+		int txdctl;
+		int txd_lwthresh;
+		int max_txd_lwthresh = 0xff >> 1;
+		
+		/*
+		 * LWTHRESH (not applicable to the 82544GC/EI) controls the number of pre-fetched transmit
+		 * descriptors at which a transmit descriptor-low interrupt (ICR.TXD_LOW) is reported. This can
+		 * enable software to operate more efficiently by maintaining a continuous addition of transmit work,
+		 * interrupting only when the hardware nears completion of all submitted work. LWTHRESH
+		 * specifies a multiple of eight descriptors. An interrupt is asserted when the number of descriptors
+		 * available transitions from (threshold level=8*LWTHRESH)+1 to (threshold
+		 * level=8*LWTHRESH). Setting this value to 0b causes this interrupt to be generated only when the
+		 * transmit descriptor cache becomes completely empty.
+		 */
+
+		device_printf(dev, "Using TXD_LOW instead of TXDW\n");
+		adapter -> use_txd_low = !0;
+
+		txd_lwthresh = adapter->num_tx_desc >> 3 >> 1;
+		if (txd_lwthresh > max_txd_lwthresh)
+			txd_lwthresh = max_txd_lwthresh;
+		txdctl = E1000_READ_REG(&adapter -> hw, E1000_TXDCTL(0));
+		txdctl = (txdctl & ~E1000_TXDCTL_LWTHRESH) |
+			((u32) txd_lwthresh << 25); /* set TXD_LOW threshold as half of TX ring */
+		E1000_WRITE_REG(&adapter -> hw, E1000_TXDCTL(0), txdctl);
+
+	}
 
 	adapter->hw.mac.autoneg = DO_AUTO_NEG;
 	adapter->hw.phy.autoneg_wait_to_complete = FALSE;
@@ -705,6 +739,24 @@
 	if (error)
 		goto err_rx_struct;
 
+	adapter->rx_shutdown_flag=FALSE;
+	adapter->rxKthreadNum=0;
+	adapter->reorder_cnt=0;
+	adapter->idle_rx_threads=0;
+	adapter -> rx_intrs_dis_count=0;
+	adapter -> tx_interrupts = 0;
+
+	kthread_create (em_handle_link, adapter, NULL, INTR_TYPE_NET | INTR_FAST | INTR_MPSAFE, 
+		0, "%s_link_handle",device_get_nameunit(dev));
+
+	kthread_create (em_kthread_txcleaner, adapter, NULL, INTR_TYPE_NET | INTR_FAST | INTR_MPSAFE, 
+		0, "%s_txcleaner",device_get_nameunit(dev));
+
+	for (int i = 0; i < EM_RX_KTHREADS_DEFAULT; i++) {
+		kthread_create (em_kthread_rx, adapter, NULL, INTR_TYPE_NET | INTR_FAST | INTR_MPSAFE, 
+			0, "%s_rx_kthread_%d",device_get_nameunit(dev),i);
+	}
+
 	/* Setup OS specific network interface */
 	em_setup_interface(dev, adapter);
 
@@ -876,7 +928,7 @@
 		em_enable_wakeup(dev);
 	}
 
-	EM_TX_UNLOCK(adapter);
+	EM_TX_UNLOCK(adapter,!0);
 	EM_CORE_UNLOCK(adapter);
 
 #ifdef EM_HW_VLAN_SUPPORT
@@ -941,7 +993,7 @@
 
 	EM_TX_LOCK(adapter);
 	em_stop(adapter);
-	EM_TX_UNLOCK(adapter);
+	EM_TX_UNLOCK(adapter,!0);
 
         em_release_manageability(adapter);
 
@@ -1016,6 +1068,8 @@
 			if (m_head == NULL)
 				break;
 			ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+			if (!adapter -> use_txd_low)
+				em_enable_intr_tx (adapter);
 			IFQ_DRV_PREPEND(&ifp->if_snd, m_head);
 			break;
 		}
@@ -1024,8 +1078,9 @@
 		ETHER_BPF_MTAP(ifp, m_head);
 
 		/* Set timeout in case hardware has problems transmitting. */
-		adapter->watchdog_timer = EM_TX_TIMEOUT;
+		adapter->tx_counter ++;
 	}
+
 }
 
 static void
@@ -1033,10 +1088,12 @@
 {
 	struct adapter *adapter = ifp->if_softc;
 
-	EM_TX_LOCK(adapter);
-	if (ifp->if_drv_flags & IFF_DRV_RUNNING)
-		em_start_locked(ifp);
-	EM_TX_UNLOCK(adapter);
+        /* if somebody else locks the mutex then he've to flush ifp's TX queue */
+        if (EM_TX_TRYLOCK(adapter)) {
+                if (ifp->if_drv_flags & IFF_DRV_RUNNING)
+                        em_start_locked(ifp);
+                EM_TX_UNLOCK(adapter,0);
+        }
 }
 
 /*********************************************************************
@@ -1147,7 +1204,7 @@
 			if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
 				EM_TX_LOCK(adapter);
 				em_stop(adapter);
-				EM_TX_UNLOCK(adapter);
+				EM_TX_UNLOCK(adapter,0);
 			}
 		adapter->if_flags = ifp->if_flags;
 		EM_CORE_UNLOCK(adapter);
@@ -1157,6 +1214,7 @@
 		IOCTL_DEBUGOUT("ioctl rcv'd: SIOC(ADD|DEL)MULTI");
 		if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
 			EM_CORE_LOCK(adapter);
+			EM_TX_LOCK(adapter);
 			em_disable_intr(adapter);
 			em_set_multi(adapter);
 			if (adapter->hw.mac.type == e1000_82542 && 
@@ -1167,6 +1225,7 @@
 			if (!(ifp->if_capenable & IFCAP_POLLING))
 #endif
 				em_enable_intr(adapter);
+			EM_TX_UNLOCK(adapter,0);
 			EM_CORE_UNLOCK(adapter);
 		}
 		break;
@@ -1322,35 +1381,55 @@
 {
 
 	EM_CORE_LOCK_ASSERT(adapter);
-
-	/*
-	** The timer is set to 5 every time start queues a packet.
-	** Then txeof keeps resetting it as long as it cleans at
-	** least one descriptor.
-	** Finally, anytime all descriptors are clean the timer is
-	** set to 0.
-	*/
 	EM_TX_LOCK(adapter);
-	if ((adapter->watchdog_timer == 0) || (--adapter->watchdog_timer)) {
-		EM_TX_UNLOCK(adapter);
+
+	if (E1000_READ_REG(&adapter->hw, E1000_TDH(0)) == E1000_READ_REG(&adapter->hw, E1000_TDT(0))) {
+		// TX queue is clean. Nothing to wait
+		adapter->tx_counter_watchdog_mark = 0;
+		EM_TX_UNLOCK(adapter,0);
 		return;
 	}
 
-	/* If we are in this routine because of pause frames, then
-	 * don't reset the hardware.
-	 */
-	if (E1000_READ_REG(&adapter->hw, E1000_STATUS) &
-	    E1000_STATUS_TXOFF) {
-		adapter->watchdog_timer = EM_TX_TIMEOUT;
-		EM_TX_UNLOCK(adapter);
+	if (E1000_READ_REG(&adapter->hw, E1000_STATUS) & E1000_STATUS_TXOFF) {
+		// XOFF received.
+		adapter->tx_counter_watchdog_mark = 0;
+		EM_TX_UNLOCK(adapter,0);
+		return;
+	}
+
+	if (!adapter->tx_counter_watchdog_mark) {
+		// watchdog isn't started yet
+		// let we do it
+		adapter->tx_counter_watchdog_mark = adapter->tx_counter;
+		adapter->tx_tdh_watchdog_mark = E1000_READ_REG(&adapter->hw, E1000_TDH(0));
+		EM_TX_UNLOCK(adapter,0);
 		return;
 	}
 
-	if (e1000_check_for_link(&adapter->hw) == 0)
+	if (adapter->tx_counter - adapter->tx_counter_watchdog_mark >= adapter->num_tx_desc) {
+		// TX ring has been wrapped
+		// let we clean watchdog condition
+		adapter->tx_counter_watchdog_mark = 0;
+		EM_TX_UNLOCK(adapter,0);
+		return;
+	}
+
+	if (adapter->tx_tdh_watchdog_mark != E1000_READ_REG(&adapter->hw, E1000_TDH(0))) {
+		// they've sent smth !
+		adapter->tx_counter_watchdog_mark = 0;
+		EM_TX_UNLOCK(adapter,0);
+		return;
+	}
+
+	if (e1000_check_for_link(&adapter->hw) == 0) {
 		device_printf(adapter->dev, "watchdog timeout -- resetting\n");
+		em_print_hw_stats(adapter);
+		em_print_debug_info(adapter);
+	}
+
 	adapter->ifp->if_drv_flags &= ~IFF_DRV_RUNNING;
 	adapter->watchdog_events++;
-	EM_TX_UNLOCK(adapter);
+	EM_TX_UNLOCK(adapter,0);
 
 	em_init_locked(adapter);
 }
@@ -1379,7 +1458,7 @@
 
 	EM_TX_LOCK(adapter);
 	em_stop(adapter);
-	EM_TX_UNLOCK(adapter);
+	EM_TX_UNLOCK(adapter,!0);
 
 	/*
 	 * Packet Buffer Allocation (PBA)
@@ -1498,7 +1577,7 @@
 		device_printf(dev, "Could not setup receive structures\n");
 		EM_TX_LOCK(adapter);
 		em_stop(adapter);
-		EM_TX_UNLOCK(adapter);
+		EM_TX_UNLOCK(adapter,!0);
 		return;
 	}
 	em_initialize_receive_unit(adapter);
@@ -1591,14 +1670,14 @@
 	}
 	EM_CORE_UNLOCK(adapter);
 
-	em_rxeof(adapter, count);
+	em_rxeof(adapter, count, 0);
 
 	EM_TX_LOCK(adapter);
 	em_txeof(adapter);
 
 	if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
 		em_start_locked(ifp);
-	EM_TX_UNLOCK(adapter);
+	EM_TX_UNLOCK(adapter,0);
 }
 #endif /* DEVICE_POLLING */
 
@@ -1639,15 +1718,6 @@
 		if (reg_icr == 0xffffffff)
 			break;
 
-		EM_CORE_UNLOCK(adapter);
-		if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
-			em_rxeof(adapter, -1);
-			EM_TX_LOCK(adapter);
-			em_txeof(adapter);
-			EM_TX_UNLOCK(adapter);
-		}
-		EM_CORE_LOCK(adapter);
-
 		/* Link status change */
 		if (reg_icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
 			callout_stop(&adapter->timer);
@@ -1658,86 +1728,125 @@
 			callout_reset(&adapter->timer, hz,
 			    em_local_timer, adapter);
 		}
-
+		if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+			if (reg_icr & (E1000_ICR_RXDMT0|E1000_ICR_RXO|E1000_ICR_RXT0))
+				em_rxeof(adapter, -1, 0);
+			if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd)) {
+				EM_TX_LOCK (adapter);
+				em_start_locked(ifp);
+				EM_TX_UNLOCK (adapter,0);
+			}
+		}
+                                                                                                                                                                                                                                                                                                                                
 		if (reg_icr & E1000_ICR_RXO)
 			adapter->rx_overruns++;
 	}
 	EM_CORE_UNLOCK(adapter);
-
-	if (ifp->if_drv_flags & IFF_DRV_RUNNING &&
-	    !IFQ_DRV_IS_EMPTY(&ifp->if_snd))
-		em_start(ifp);
 }
 
 #else /* EM_FAST_IRQ, then fast interrupt routines only */
 
 static void
-em_handle_link(void *context, int pending)
+em_handle_link(void *context)
 {
 	struct adapter	*adapter = context;
 	struct ifnet *ifp = adapter->ifp;
 
-	if (!(ifp->if_drv_flags & IFF_DRV_RUNNING))
-		return;
-
 	EM_CORE_LOCK(adapter);
-	callout_stop(&adapter->timer);
-	em_update_link_status(adapter);
-	/* Deal with TX cruft when link lost */
-	em_tx_purge(adapter);
-	callout_reset(&adapter->timer, hz, em_local_timer, adapter);
+	while (!adapter->rx_shutdown_flag) {
+		if (msleep(&adapter->wakeup_link, &adapter->core_mtx, PI_NET, "WAIT", hz))
+			continue;
+		if (!(ifp->if_drv_flags & IFF_DRV_RUNNING))
+			break;
+
+		EM_TX_LOCK(adapter);
+		callout_stop(&adapter->timer);
+		adapter->hw.mac.get_link_status = 1;
+		em_update_link_status(adapter);
+		/* Deal with TX cruft when link lost */
+		em_tx_purge(adapter);
+		callout_reset(&adapter->timer, hz, em_local_timer, adapter);
+		EM_TX_UNLOCK(adapter,0);
+	}
 	EM_CORE_UNLOCK(adapter);
+	kthread_exit(0);
 }
 
+#if __FreeBSD_version >= 700000
+#if !defined(NET_LOCK_GIANT)
+#define NET_LOCK_GIANT()
+#define NET_UNLOCK_GIANT()
+#endif
+#endif
 
-/* Combined RX/TX handler, used by Legacy and MSI */
 static void
-em_handle_rxtx(void *context, int pending)
+em_kthread_rx(void *arg)
 {
-	struct adapter	*adapter = context;
+	struct adapter	*adapter = arg;
 	struct ifnet	*ifp = adapter->ifp;
+	int myKthreadNo = 0;
 
+	EM_CORE_LOCK(adapter);
+	myKthreadNo = adapter -> rxKthreadNum ++;
+	adapter -> rxIpBeingProcessed[myKthreadNo] = 0;
+	adapter -> waitedBy[myKthreadNo] = 0;
+
+	while (!adapter->rx_shutdown_flag && myKthreadNo < adapter -> rxKthreadNum) {
+		if (!adapter -> idle_rx_threads)
+			em_enable_intr_rx(adapter);
+		adapter -> idle_rx_threads ++;
 
-	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
-		if (em_rxeof(adapter, adapter->rx_process_limit) != 0)
-			taskqueue_enqueue(adapter->tq, &adapter->rxtx_task);
-		EM_TX_LOCK(adapter);
-		em_txeof(adapter);
+		msleep(&adapter->wakeup_rxthread, &adapter->core_mtx, adapter->rx_kthread_priority, "WAIT", hz);
 
-		if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
-			em_start_locked(ifp);
-		EM_TX_UNLOCK(adapter);
-	}
+		if (myKthreadNo >= adapter -> rxKthreadNum)
+			break;
+		if (adapter->rx_shutdown_flag)
+			break;
 
-	em_enable_intr(adapter);
-}
+		adapter -> idle_rx_threads --;
+		if (!adapter -> idle_rx_threads) {
+			em_disable_intr_rx(adapter);
+			adapter -> rx_intrs_dis_count ++;
+		}
 
-static void
-em_handle_rx(void *context, int pending)
-{
-	struct adapter	*adapter = context;
-	struct ifnet	*ifp = adapter->ifp;
+		if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+			EM_CORE_UNLOCK(adapter);
+			em_rxeof(adapter,-1, myKthreadNo);
+			EM_CORE_LOCK(adapter);
+		}
+	}
 
-	if ((ifp->if_drv_flags & IFF_DRV_RUNNING) &&
-	    (em_rxeof(adapter, adapter->rx_process_limit) != 0))
-		taskqueue_enqueue(adapter->tq, &adapter->rx_task);
+	if (!adapter->rx_shutdown_flag) {
+		if (adapter -> waitedBy[myKthreadNo]) {
+			// some thread wait me for wakeup due to anti reoder trick
+			wakeup (adapter -> rxIpBeingProcessed+myKthreadNo);
+			adapter -> waitedBy [myKthreadNo] = 0;
+		}
+		adapter -> rxIpBeingProcessed[myKthreadNo] = 0;
+	}
 
+	EM_CORE_UNLOCK(adapter);
+	kthread_exit (0);
 }
 
 static void
-em_handle_tx(void *context, int pending)
+em_kthread_txcleaner(void *arg) 
 {
-	struct adapter	*adapter = context;
-	struct ifnet	*ifp = adapter->ifp;
-
-	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
-		EM_TX_LOCK(adapter);
+	struct adapter	*adapter = arg;
+	EM_TX_LOCK(adapter);
+	while (!adapter->rx_shutdown_flag) {
+		msleep(&adapter->wakeup_txcleaner, &adapter->tx_mtx, PI_NET, "WAIT", hz);
 		em_txeof(adapter);
-		if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
-			em_start_locked(ifp);
-		EM_TX_UNLOCK(adapter);
+		if (!IFQ_DRV_IS_EMPTY(&adapter->ifp->if_snd))
+			em_start_locked(adapter->ifp);
 	}
-}
+
+	EM_TX_UNLOCK(adapter,!0);
+	kthread_exit (0);
+} // em_kthread_txcleaner
+
+
+
 
 /*********************************************************************
  *
@@ -1755,7 +1864,7 @@
 {
 	struct adapter	*adapter = arg;
 	struct ifnet	*ifp;
-	u32		reg_icr;
+	uint32_t	reg_icr;
 
 	ifp = adapter->ifp;
 
@@ -1777,20 +1886,22 @@
 	    (reg_icr & E1000_ICR_INT_ASSERTED) == 0)
 		return FILTER_STRAY;
 
-	/*
-	 * Mask interrupts until the taskqueue is finished running.  This is
-	 * cheap, just assume that it is needed.  This also works around the
-	 * MSI message reordering errata on certain systems.
-	 */
-	em_disable_intr(adapter);
-	taskqueue_enqueue(adapter->tq, &adapter->rxtx_task);
+	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+		if (reg_icr & (E1000_ICR_RXDMT0|E1000_ICR_RXO|E1000_ICR_RXT0)) {
+			wakeup_one (&adapter->wakeup_rxthread);
+		}
+	}
 
 	/* Link status change */
 	if (reg_icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
-		adapter->hw.mac.get_link_status = 1;
-		taskqueue_enqueue(taskqueue_fast, &adapter->link_task);
+		wakeup (&adapter->wakeup_link);
 	}
 
+	if (ifp->if_drv_flags & IFF_DRV_OACTIVE && reg_icr & (E1000_ICR_TXDW | E1000_ICR_TXD_LOW)) { 	 
+		wakeup (&adapter->wakeup_txcleaner); 	 
+		adapter->tx_interrupts ++;
+	} 	 
+
 	if (reg_icr & E1000_ICR_RXO)
 		adapter->rx_overruns++;
 	return FILTER_HANDLED;
@@ -1812,14 +1923,8 @@
 	struct ifnet	*ifp = adapter->ifp;
 
 	++adapter->tx_irq;
-	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
-		EM_TX_LOCK(adapter);
-		em_txeof(adapter);
-		EM_TX_UNLOCK(adapter);
-		taskqueue_enqueue(adapter->tq, &adapter->tx_task);
-	}
-	/* Reenable this interrupt */
-	E1000_WRITE_REG(&adapter->hw, E1000_IMS, EM_MSIX_TX);
+	if (ifp->if_drv_flags & IFF_DRV_RUNNING)
+		wakeup(&adapter->wakeup_txcleaner);
 	return;
 }
 
@@ -1836,11 +1941,8 @@
 	struct ifnet	*ifp = adapter->ifp;
 
 	++adapter->rx_irq;
-	if ((ifp->if_drv_flags & IFF_DRV_RUNNING) &&
-	    (em_rxeof(adapter, adapter->rx_process_limit) != 0))
-		taskqueue_enqueue(adapter->tq, &adapter->rx_task);
-	/* Reenable this interrupt */
-	E1000_WRITE_REG(&adapter->hw, E1000_IMS, EM_MSIX_RX);
+	if (ifp->if_drv_flags & IFF_DRV_RUNNING)
+		wakeup_one(&adapter->wakeup_rxthread);
 	return;
 }
 
@@ -1859,10 +1961,8 @@
 	++adapter->link_irq;
 	reg_icr = E1000_READ_REG(&adapter->hw, E1000_ICR);
 
-	if (reg_icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC)) {
-		adapter->hw.mac.get_link_status = 1;
-		taskqueue_enqueue(taskqueue_fast, &adapter->link_task);
-	}
+	if (reg_icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC))
+		wakeup (&adapter->wakeup_link);
 	E1000_WRITE_REG(&adapter->hw, E1000_IMS,
 	    EM_MSIX_LINK | E1000_IMS_LSC);
 	return;
@@ -2000,7 +2100,7 @@
 	struct em_buffer	*tx_buffer, *tx_buffer_mapped;
 	struct e1000_tx_desc	*ctxd = NULL;
 	struct mbuf		*m_head;
-	u32			txd_upper, txd_lower, txd_used, txd_saved;
+	uint32_t		txd_upper, txd_lower, txd_used, txd_saved;
 	int			nsegs, i, j, first, last = 0;
 	int			error, do_tso, tso_desc = 0;
 #if __FreeBSD_version < 700000
@@ -2019,13 +2119,18 @@
          * Force a cleanup if number of TX descriptors
          * available hits the threshold
          */
-	if (adapter->num_tx_desc_avail <= EM_TX_CLEANUP_THRESHOLD) {
+	if (adapter->num_tx_desc - adapter->num_tx_desc_avail > EM_TX_CLEANUP_THRESHOLD) {
+#ifndef EM_LEGACY_IRQ
+		wakeup(&adapter->wakeup_txcleaner);
+#else
 		em_txeof(adapter);
-		/* Now do we at least have a minimal? */
-		if (adapter->num_tx_desc_avail <= EM_TX_OP_THRESHOLD) {
-			adapter->no_tx_desc_avail1++;
-			return (ENOBUFS);
-		}
+#endif
+	}
+
+	/* Now do we at least have a minimal? */
+	if (adapter->num_tx_desc_avail <= EM_TX_OP_THRESHOLD) {
+		adapter->no_tx_desc_avail1++;
+		return (ENOBUFS);
 	}
 
 
@@ -2130,14 +2235,7 @@
 		tso_desc = TRUE;
 	} else
 #endif
-#ifndef EM_TIMESYNC
-	/*
-	** Timesync needs to check the packet header 
-	** so call checksum code to do so, but don't
-	** penalize the code if not defined.
-	*/
-	if (m_head->m_pkthdr.csum_flags & CSUM_OFFLOAD)
-#endif
+	 if (m_head->m_pkthdr.csum_flags & CSUM_OFFLOAD)
 		em_transmit_checksum_setup(adapter,  m_head,
 		    &txd_upper, &txd_lower);
 
@@ -2152,7 +2250,7 @@
 		/* If adapter is 82544 and on PCIX bus */
 		if(adapter->pcix_82544) {
 			DESC_ARRAY	desc_array;
-			u32		array_elements, counter;
+			uint32_t	array_elements, counter;
 			/*
 			 * Check the Address and Length combination and
 			 * split the data accordingly
@@ -2171,7 +2269,7 @@
 				ctxd->buffer_addr = htole64(
 				    desc_array.descriptor[counter].address);
 				ctxd->lower.data = htole32(
-				    (adapter->txd_cmd | txd_lower | (u16)
+				    (adapter->txd_cmd | txd_lower | (uint16_t) 
 				    desc_array.descriptor[counter].length));
 				ctxd->upper.data =
 				    htole32((txd_upper));
@@ -2294,11 +2392,6 @@
 			    m_head->m_pkthdr.len);
 	}
 
-#ifdef EM_TIMESYNC
-	if (ctxd->upper.data & E1000_TXD_EXTCMD_TSTAMP) {
-		HW_DEBUGOUT( "@@@ Timestamp bit is set in transmit descriptor\n" );
-	} 
-#endif
 	return (0);
 }
 
@@ -2550,7 +2643,6 @@
 	em_watchdog(adapter);
 
 	callout_reset(&adapter->timer, hz, em_local_timer, adapter);
-
 }
 
 static void
@@ -2616,7 +2708,6 @@
 			device_printf(dev, "Link is Down\n");
 		adapter->link_active = 0;
 		/* Link down, disable watchdog */
-		adapter->watchdog_timer = FALSE;
 		if_link_state_change(ifp, LINK_STATE_DOWN);
 	}
 }
@@ -2817,12 +2908,7 @@
 	 * Try allocating a fast interrupt and the associated deferred
 	 * processing contexts.
 	 */
-	TASK_INIT(&adapter->rxtx_task, 0, em_handle_rxtx, adapter);
-	TASK_INIT(&adapter->link_task, 0, em_handle_link, adapter);
-	adapter->tq = taskqueue_create_fast("em_taskq", M_NOWAIT,
-	    taskqueue_thread_enqueue, &adapter->tq);
-	taskqueue_start_threads(&adapter->tq, 1, PI_NET, "%s taskq",
-	    device_get_nameunit(adapter->dev));
+	
 #if __FreeBSD_version < 700000
 	if ((error = bus_setup_intr(dev, adapter->res[0],
 	    INTR_TYPE_NET | INTR_FAST, em_irq_fast, adapter,
@@ -2833,8 +2919,6 @@
 	    &adapter->tag[0])) != 0) {
 		device_printf(dev, "Failed to register fast interrupt "
 			    "handler: %d\n", error);
-		taskqueue_free(adapter->tq);
-		adapter->tq = NULL;
 		return (error);
 	}
 #endif  /* EM_LEGACY_IRQ */
@@ -2871,17 +2955,6 @@
 	}
 
 	/*
-	 * Now allocate deferred processing contexts.
-	 */
-	TASK_INIT(&adapter->rx_task, 0, em_handle_rx, adapter);
-	TASK_INIT(&adapter->tx_task, 0, em_handle_tx, adapter);
-	TASK_INIT(&adapter->link_task, 0, em_handle_link, adapter);
-	adapter->tq = taskqueue_create_fast("em_taskq", M_NOWAIT,
-	    taskqueue_thread_enqueue, &adapter->tq);
-	taskqueue_start_threads(&adapter->tq, 1, PI_NET, "%s taskq",
-	    device_get_nameunit(adapter->dev));
-
-	/*
 	 * And setup the interrupt handlers
 	 */
 
@@ -3498,7 +3571,7 @@
 	E1000_WRITE_REG(&adapter->hw, E1000_TIDV, adapter->tx_int_delay.value);
 	if(adapter->hw.mac.type >= e1000_82540)
 		E1000_WRITE_REG(&adapter->hw, E1000_TADV,
-		    adapter->tx_abs_int_delay.value);
+		    EM_USECS_TO_TICKS(adapter->tx_abs_int_delay.value));
 
 	if ((adapter->hw.mac.type == e1000_82571) ||
 	    (adapter->hw.mac.type == e1000_82572)) {
@@ -3741,6 +3814,10 @@
 
 	adapter->num_tx_desc_avail--;
 	adapter->next_avail_tx_desc = curr_txd;
+
+	adapter->tx_counter=0;
+	adapter->tx_counter_watchdog_mark=0;
+	adapter->tx_tdh_watchdog_mark=0;
 }
 
 
@@ -3952,13 +4029,35 @@
 				bus_dmamap_unload(adapter->txtag,
 				    tx_buffer->map);
 
-                        	m_freem(tx_buffer->m_head);
+        			adapter->num_tx_desc_avail = num_avail;
+	                	if (++first == adapter->num_tx_desc)
+					first = 0;
+        			adapter->next_tx_to_clean = first;
+        			/*
+   			      	* If we have enough room, clear IFF_DRV_OACTIVE to tell the stack
+         			* that it is OK to send packets.
+         			*/
+        			if ((ifp -> if_drv_flags & IFF_DRV_OACTIVE) && (num_avail > EM_TX_CLEANUP_THRESHOLD)) {
+#ifndef EM_LEGACY_IRQ
+					if (!adapter->use_txd_low)
+						em_disable_intr_tx (adapter);
+#endif
+                			ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+        				if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
+                				em_start_locked(ifp);
+        			}
+				struct mbuf *m = tx_buffer->m_head;
                         	tx_buffer->m_head = NULL;
-                	}
-			tx_buffer->next_eop = -1;
-
-	                if (++first == adapter->num_tx_desc)
-				first = 0;
+				tx_buffer->next_eop = -1;
+				EM_TX_UNLOCK(adapter,0);
+                        	m_freem(m);
+				EM_TX_LOCK(adapter);
+        			num_avail = adapter->num_tx_desc_avail;
+        			first = adapter->next_tx_to_clean;
+                	} else {
+	                	if (++first == adapter->num_tx_desc)
+					first = 0;
+			}
 
 	                tx_buffer = &adapter->tx_buffer_area[first];
 			tx_desc = &adapter->tx_desc_base[first];
@@ -3978,22 +4077,6 @@
 
         adapter->next_tx_to_clean = first;
 
-        /*
-         * If we have enough room, clear IFF_DRV_OACTIVE to tell the stack
-         * that it is OK to send packets.
-         * If there are no pending descriptors, clear the timeout. Otherwise,
-         * if some descriptors have been freed, restart the timeout.
-         */
-        if (num_avail > EM_TX_CLEANUP_THRESHOLD) {                
-                ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
-		/* All clean, turn off the timer */
-                if (num_avail == adapter->num_tx_desc) {
-			adapter->watchdog_timer = 0;
-		} else
-		/* Some cleaned, reset the timer */
-                if (num_avail != adapter->num_tx_desc_avail)
-			adapter->watchdog_timer = EM_TX_TIMEOUT;
-        }
         adapter->num_tx_desc_avail = num_avail;
 	return;
 }
@@ -4009,15 +4092,17 @@
 static void
 em_tx_purge(struct adapter *adapter)
 {
+#if 0
 	if ((!adapter->link_active) && (adapter->watchdog_timer)) {
 		EM_TX_LOCK(adapter);
 		em_txeof(adapter);
-		EM_TX_UNLOCK(adapter);
+		EM_TX_UNLOCK(adapter,0);
 		if (adapter->watchdog_timer) { /* Still not clean? */
 			adapter->watchdog_timer = 0;
 			em_init_locked(adapter);
 		}
 	}
+#endif
 }
 
 /*********************************************************************
@@ -4035,6 +4120,7 @@
 	int			error, nsegs;
 
 	m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
+
 	if (m == NULL) {
 		adapter->mbuf_cluster_failed++;
 		return (ENOBUFS);
@@ -4216,7 +4302,7 @@
 		 * Set the interrupt throttling rate. Value is calculated
 		 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns)
 		 */
-		E1000_WRITE_REG(&adapter->hw, E1000_ITR, DEFAULT_ITR);
+//		E1000_WRITE_REG(&adapter->hw, E1000_ITR, DEFAULT_ITR);
 	}
 
 	/*
@@ -4373,7 +4459,7 @@
  *
  *********************************************************************/
 static int
-em_rxeof(struct adapter *adapter, int count)
+em_rxeof(struct adapter *adapter, int count, int myKthreadNo)
 {
 	struct ifnet	*ifp = adapter->ifp;;
 	struct mbuf	*mp;
@@ -4448,7 +4534,8 @@
 			if (em_get_buf(adapter, i) != 0) {
 				ifp->if_iqdrops++;
 				goto discard;
-			}
+			} else
+                                E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), i);
 
 			/* Assign correct length to the current fragment */
 			mp->m_len = len;
@@ -4718,6 +4805,10 @@
 		E1000_WRITE_REG(hw, EM_EIAC, EM_MSIX_MASK);
 		ims_mask |= EM_MSIX_MASK;
 	} 
+
+	if (adapter->use_txd_low)
+		ims_mask |= E1000_IMS_TXD_LOW;
+
 	E1000_WRITE_REG(hw, E1000_IMS, ims_mask);
 }
 
@@ -4731,6 +4822,31 @@
 	E1000_WRITE_REG(&adapter->hw, E1000_IMC, 0xffffffff);
 }
 
+#ifndef EM_DISABLE_IRQ
+static void
+em_enable_intr_rx(struct adapter *adapter)
+{
+        E1000_WRITE_REG(&adapter->hw, E1000_IMS, E1000_IMS_RXT0 | E1000_IMS_RXDMT0 | E1000_IMS_RXO );
+}
+
+static void
+em_disable_intr_rx(struct adapter *adapter)
+{
+        E1000_WRITE_REG(&adapter->hw, E1000_IMC, E1000_IMS_RXT0 | E1000_IMS_RXDMT0 | E1000_IMS_RXO );
+}
+static void 	 
+em_enable_intr_tx(struct adapter *adapter) 	 
+{ 	 
+	E1000_WRITE_REG(&adapter->hw, E1000_IMS, E1000_IMS_TXDW); 	 
+} 	 
+  	 
+static void 	 
+em_disable_intr_tx(struct adapter *adapter) 	 
+{ 	 
+	E1000_WRITE_REG(&adapter->hw, E1000_IMC, E1000_IMS_TXDW); 	 
+} 	 
+#endif
+
 /*
  * Bit of a misnomer, what this really means is
  * to enable OS management of the system... aka
@@ -5092,6 +5208,14 @@
 	    adapter->dropped_pkts);
 	device_printf(dev, "Driver tx dma failure in encap = %ld\n",
 		adapter->no_tx_dma_setup);
+#ifndef EM_LEGACY_IRQ
+	device_printf(dev, "Packets pended due to reorder = %ld\n",
+		adapter->reorder_cnt);
+	device_printf(dev, "RX interrupts has been masked = %ld\n",
+		adapter -> rx_intrs_dis_count);
+	device_printf(dev, "TX interrupts has been generated = %ld\n",
+		adapter -> tx_interrupts);
+#endif
 }
 
 static void
@@ -5250,6 +5374,7 @@
 	adapter = info->adapter;
 	
 	EM_CORE_LOCK(adapter);
+	EM_TX_LOCK(adapter);
 	regval = E1000_READ_OFFSET(&adapter->hw, info->offset);
 	regval = (regval & ~0xffff) | (ticks & 0xffff);
 	/* Handle a few special cases. */
@@ -5266,10 +5391,44 @@
 		break;
 	}
 	E1000_WRITE_OFFSET(&adapter->hw, info->offset, regval);
+	EM_TX_UNLOCK(adapter,0);
 	EM_CORE_UNLOCK(adapter);
 	return (0);
 }
 
+#ifndef EM_LEGACY_IRQ
+
+static int
+em_sysctl_rx_kthreads(SYSCTL_HANDLER_ARGS)
+{
+	struct adapter *adapter = (struct adapter *)arg1;
+        int error;
+        int result;
+
+        result = adapter->rxKthreadNum;
+        error = sysctl_handle_int(oidp, &result, 0, req);
+
+        if (error || !req->newptr)
+                return (error);
+
+        if (result > 0 && result <= EM_RX_MAXKTHREADS) {
+
+		EM_CORE_LOCK(adapter);
+		if (result < adapter->rxKthreadNum) {
+			adapter->rxKthreadNum = result;
+			wakeup (&adapter->wakeup_rxthread);
+		} else { 
+			for (int i = adapter->rxKthreadNum; i < result; i++) {
+				kthread_create (em_kthread_rx, adapter, NULL, INTR_TYPE_NET | INTR_FAST | INTR_MPSAFE, 
+					0, "%s_rx_kthread_%d",device_get_nameunit(adapter->dev),i);
+			}
+        	}
+		EM_CORE_UNLOCK(adapter);
+	}
+        return (error);
+}
+
+#endif
 static void
 em_add_int_delay_sysctl(struct adapter *adapter, const char *name,
 	const char *description, struct em_int_delay_info *info,
@@ -5286,7 +5445,7 @@
 
 #ifndef EM_LEGACY_IRQ
 static void
-em_add_rx_process_limit(struct adapter *adapter, const char *name,
+em_add_int_rx_kthread_priority(struct adapter *adapter, const char *name,
 	const char *description, int *limit, int value)
 {
 	*limit = value;
Index: if_em.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/if_em.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 if_em.h
--- if_em.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ if_em.h	30 Apr 2009 19:54:57 -0000
@@ -30,12 +30,20 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/if_em.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/if_em.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 
 #ifndef _EM_H_DEFINED_
 #define _EM_H_DEFINED_
 
+#define EM_FAST_IRQ 
+
+#ifndef EM_LEGACY_IRQ
+#ifdef DEVICE_POLL
+#error Polling isnt compatible w/em_intr_fast
+#endif
+#endif
+
 /* Tunables */
 
 /*
@@ -83,7 +91,11 @@
  *   system is reporting dropped transmits, this value may be set too high
  *   causing the driver to run out of available transmit descriptors.
  */
+#ifndef EM_LEGACY_IRQ
+#define EM_TIDV                         0
+#else
 #define EM_TIDV                         64
+#endif
 
 /*
  * EM_TADV - Transmit Absolute Interrupt Delay Value
@@ -134,11 +146,6 @@
 #define EM_RADV                         64
 
 /*
- * This parameter controls the duration of transmit watchdog timer.
- */
-#define EM_TX_TIMEOUT                   5
-
-/*
  * This parameter controls when the driver calls the routine to reclaim
  * transmit descriptors.
  */
@@ -181,7 +188,6 @@
 #define EM_DEFAULT_PBA                  0x00000030
 #define EM_SMARTSPEED_DOWNSHIFT         3
 #define EM_SMARTSPEED_MAX               15
-#define EM_MAX_INTR			10
 
 #define MAX_NUM_MULTICAST_ADDRESSES     128
 #define PCI_ANY_ID                      (~0U)
@@ -189,10 +195,6 @@
 #define EM_FC_PAUSE_TIME		0x0680
 #define EM_EEPROM_APME			0x400;
 
-/* Code compatilbility between 6 and 7 */
-#ifndef ETHER_BPF_MTAP
-#define ETHER_BPF_MTAP			BPF_MTAP
-#endif
 
 /*
  * TDBA/RDBA should be aligned on 16 byte boundary. But TDLEN/RDLEN should be
@@ -322,7 +324,9 @@
 	struct ifmedia	media;
 	struct callout	timer;
 	struct callout	tx_fifo_timer;
-	int		watchdog_timer;
+ 	unsigned	tx_counter;
+ 	unsigned	tx_counter_watchdog_mark;
+ 	unsigned	tx_tdh_watchdog_mark;
 	int		msi;
 	int		if_flags;
 	int		max_frame_size;
@@ -332,12 +336,21 @@
 	struct mtx	rx_mtx;
 	int		em_insert_vlan_header;
 
-	/* Task for FAST handling */
-	struct task     link_task;
-	struct task     rxtx_task;
-	struct task     rx_task;
-	struct task     tx_task;
-	struct taskqueue *tq;           /* private task queue */
+#define EM_RX_KTHREADS_DEFAULT	2
+#define EM_RX_MAXKTHREADS	8
+#define EM_MAX_SPARE_MBUFS	4096
+	int		rx_shutdown_flag;
+
+	int		wakeup_rxthread;
+	int		wakeup_txcleaner;
+	int		wakeup_link;
+
+	in_addr_t	rxIpBeingProcessed [EM_RX_MAXKTHREADS];
+	int	waitedBy [EM_RX_MAXKTHREADS];
+	unsigned	rxKthreadNum;
+	unsigned long	reorder_cnt;
+	unsigned 	idle_rx_threads;
+	unsigned long  	rx_intrs_dis_count;
 
 #ifdef EM_HW_VLAN_SUPPORT
 	eventhandler_tag vlan_attach;
@@ -377,6 +390,10 @@
 	struct em_buffer	*tx_buffer_area;
 	bus_dma_tag_t		txtag;		/* dma tag for tx */
 	uint32_t	   	tx_tso;		/* last tx was tso */
+#ifndef	EM_LEGACY_IRQ
+        unsigned long  	tx_interrupts;
+#endif
+	int		use_txd_low;	/* driver uses TXD_LOW instead of TXDW */
 
 	/* 
 	 * Receive definitions
@@ -391,7 +408,7 @@
 	uint32_t		next_rx_desc_to_check;
 	uint32_t		rx_buffer_len;
 	uint16_t		num_rx_desc;
-	int			rx_process_limit;
+	int			rx_kthread_priority;
 	struct em_buffer	*rx_buffer_area;
 	bus_dma_tag_t		rxtag;
 	bus_dmamap_t		rx_sparemap;
@@ -484,9 +501,19 @@
 #define	EM_RX_LOCK_DESTROY(_sc)		mtx_destroy(&(_sc)->rx_mtx)
 #define	EM_CORE_LOCK(_sc)		mtx_lock(&(_sc)->core_mtx)
 #define	EM_TX_LOCK(_sc)			mtx_lock(&(_sc)->tx_mtx)
+#define EM_TX_TRYLOCK(_sc)                      mtx_trylock(&(_sc)->tx_mtx)
 #define	EM_RX_LOCK(_sc)			mtx_lock(&(_sc)->rx_mtx)
 #define	EM_CORE_UNLOCK(_sc)		mtx_unlock(&(_sc)->core_mtx)
-#define	EM_TX_UNLOCK(_sc)		mtx_unlock(&(_sc)->tx_mtx)
+#define EM_TX_UNLOCK(_sc,_dontcheck)\
+        {\
+                mtx_unlock(&(_sc)->tx_mtx);\
+\
+                if (!(_dontcheck)\
+                   && (((_sc)->ifp->if_drv_flags & (IFF_DRV_RUNNING|IFF_DRV_OACTIVE)) == IFF_DRV_RUNNING)\
+                   && (_sc)->link_active\
+                   && !IFQ_DRV_IS_EMPTY(&(_sc)->ifp->if_snd))\
+                        wakeup (&adapter->wakeup_txcleaner);\
+        }
 #define	EM_RX_UNLOCK(_sc)		mtx_unlock(&(_sc)->rx_mtx)
 #define	EM_CORE_LOCK_ASSERT(_sc)	mtx_assert(&(_sc)->core_mtx, MA_OWNED)
 #define	EM_TX_LOCK_ASSERT(_sc)		mtx_assert(&(_sc)->tx_mtx, MA_OWNED)
Index: if_igb.c
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/if_igb.c,v
retrieving revision 1.3.2.1.2.2
diff -u -r1.3.2.1.2.2 if_igb.c
--- if_igb.c	30 Nov 2008 04:41:25 -0000	1.3.2.1.2.2
+++ if_igb.c	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/if_igb.c,v 1.3.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/if_igb.c,v 1.3.2.3 2009/01/13 21:19:02 gnn Exp $*/
 
 #ifdef HAVE_KERNEL_OPTION_HEADERS
 #include "opt_device_polling.h"
@@ -281,7 +281,7 @@
 static int igb_low_latency = IGB_LOW_LATENCY;
 TUNABLE_INT("hw.igb.low_latency", &igb_low_latency);
 static int igb_ave_latency = IGB_AVE_LATENCY;
-TUNABLE_INT("hw.igb.ave_latency", &igb_low_latency);
+TUNABLE_INT("hw.igb.ave_latency", &igb_ave_latency);
 static int igb_bulk_latency = IGB_BULK_LATENCY;
 TUNABLE_INT("hw.igb.bulk_latency", &igb_bulk_latency);
                 
Index: if_igb.h
===================================================================
RCS file: /home/ncvs/src/sys/dev/e1000/if_igb.h,v
retrieving revision 1.1.2.1.2.2
diff -u -r1.1.2.1.2.2 if_igb.h
--- if_igb.h	30 Nov 2008 04:41:25 -0000	1.1.2.1.2.2
+++ if_igb.h	30 Apr 2009 19:54:57 -0000
@@ -30,7 +30,7 @@
   POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
-/*$FreeBSD: src/sys/dev/e1000/if_igb.h,v 1.1.2.1.2.2 2008/11/30 04:41:25 jfv Exp $*/
+/*$FreeBSD: src/sys/dev/e1000/if_igb.h,v 1.1.2.2 2008/12/01 07:13:52 jfv Exp $*/
 
 #ifndef _IGB_H_DEFINED_
 #define _IGB_H_DEFINED_
