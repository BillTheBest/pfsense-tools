Index: Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/Makefile,v
retrieving revision 1.26
diff -u -r1.26 Makefile
--- Makefile	21 Dec 2004 12:32:13 -0000	1.26
+++ Makefile	5 Nov 2006 22:03:02 -0000
@@ -1,12 +1,14 @@
-# $FreeBSD: src/sys/boot/Makefile,v 1.26 2004/12/21 12:32:13 ru Exp $
+# $FreeBSD: src/sys/boot/Makefile,v 1.32 2006/11/05 22:03:02 marcel Exp $
 
-.if !defined(NO_FORTH)
+.include <bsd.own.mk>
+
+.if ${MK_FORTH} != "no"
 # Build the add-in FORTH interpreter.
 SUBDIR+=		ficl
 .endif
 
 # Build EFI library.
-.if ${MACHINE_ARCH} == "ia64"
+.if ${MACHINE_ARCH} == "amd64" || ${MACHINE_ARCH} == "i386" || ${MACHINE_ARCH} == "ia64"
 SUBDIR+=		efi
 .endif
 
@@ -16,12 +18,6 @@
 .endif
 
 # Pick the machine-dependent subdir based on the target architecture.
-SUBDIR+=		${MACHINE:S/amd64/i386/}
-
-# Build ARC / AlphaBIOS executable on the Alpha
-# (this is a WIP (work in progress)).
-#.if ${MACHINE_ARCH} == "alpha"
-#SUBDIR+=		arc
-#.endif
+SUBDIR+=		${MACHINE:S/amd64/i386/:S/sun4v/sparc64/}
 
 .include <bsd.subdir.mk>
Index: arm/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/Makefile,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 Makefile
--- arm/Makefile	17 Aug 2006 22:57:06 -0000	1.1.2.1
+++ arm/Makefile	23 Oct 2006 00:05:28 -0000
@@ -1,4 +1,4 @@
-# $FreeBSD: src/sys/boot/arm/Makefile,v 1.1.2.1 2006/08/17 22:57:06 imp Exp $
+# $FreeBSD: src/sys/boot/arm/Makefile,v 1.3 2006/10/23 00:05:28 imp Exp $
 
 SUBDIR=
 
Index: arm/at91/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/Makefile,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 Makefile
--- arm/at91/Makefile	17 Aug 2006 22:57:07 -0000	1.2.2.1
+++ arm/at91/Makefile	9 Nov 2006 20:45:21 -0000
@@ -1,5 +1,5 @@
-# $FreeBSD: src/sys/boot/arm/at91/Makefile,v 1.2.2.1 2006/08/17 22:57:07 imp Exp $
+# $FreeBSD: src/sys/boot/arm/at91/Makefile,v 1.3 2006/11/09 20:45:21 imp Exp $
 
-SUBDIR=		libat91 boot0 boot0iic boot0spi bootiic bootspi
+SUBDIR=		libat91 boot0 boot0iic boot0spi boot2 bootiic bootspi
 
 .include <bsd.subdir.mk>
Index: arm/at91/Makefile.inc
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/Makefile.inc,v
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 Makefile.inc
--- arm/at91/Makefile.inc	17 Aug 2006 22:57:07 -0000	1.3.2.1
+++ arm/at91/Makefile.inc	20 Dec 2006 17:47:54 -0000
@@ -1,11 +1,14 @@
-# $FreeBSD: src/sys/boot/arm/at91/Makefile.inc,v 1.3.2.1 2006/08/17 22:57:07 imp Exp $
+# $FreeBSD: src/sys/boot/arm/at91/Makefile.inc,v 1.6 2006/12/20 17:47:54 imp Exp $
 
 .if !target(__at91_boot_Makefile.inc__)
 .PATH:	${.CURDIR}/../../../../libkern ${.CURDIR}/../../../../libkern/arm
 
 __at91_boot_Makefile.inc__:
 
-CFLAGS=-O2 -mcpu=arm9 -ffreestanding \
+# tsc, bwct, kb920x are the supported flavors
+BOOT_FLAVOR=kb920x
+
+CFLAGS=-Os -mcpu=arm9 -ffreestanding \
 	-I${.CURDIR}/../libat91 \
 	-I${.CURDIR}/../../../.. \
 	-I${.CURDIR}/../../../../arm \
@@ -13,13 +16,12 @@
 	-Wall -Waggregate-return  \
 	-Wnested-externs \
 	-Wpointer-arith -Wshadow -Wwrite-strings \
-	-Werror
-# -Wmissing-prototypes
-# -Wmissing-declarations 
+	-Werror \
+	-Wmissing-prototypes \
+	-Wmissing-declarations 
 # -Wstrict-prototypes 
 
-#CFLAGS+=-DBOOT_TSC
-CFLAGS+=-DBOOT_KB9202
+CFLAGS+=-DBOOT_${BOOT_FLAVOR:U}
 
 LIBAT91=${.OBJDIR}/../libat91/libat91.a
 
@@ -44,10 +46,10 @@
 MK_TAG_LIST:=no
 .endif
 
-.if defined(WITHOUT_FPGA)
-MK_FPGA:=no
-.else
+.if defined(WITH_FPGA)
 MK_FPGA:=yes
+.else
+MK_FPGA:=no
 .endif
 
 .endif
Index: arm/at91/linker.cfg
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/linker.cfg,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 linker.cfg
--- arm/at91/linker.cfg	17 Aug 2006 22:57:07 -0000	1.1.2.1
+++ arm/at91/linker.cfg	19 Apr 2006 17:16:48 -0000
@@ -18,7 +18,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/linker.cfg,v 1.1.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/linker.cfg,v 1.1 2006/04/19 17:16:48 imp Exp $
  ******************************************************************************/
 OUTPUT_FORMAT("elf32-littlearm", "elf32-bigarm",
 	      "elf32-littlearm")
Index: arm/at91/boot0/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0/Makefile,v
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 Makefile
--- arm/at91/boot0/Makefile	17 Aug 2006 22:57:07 -0000	1.3.2.1
+++ arm/at91/boot0/Makefile	16 Nov 2006 00:53:27 -0000
@@ -1,11 +1,14 @@
-#  $FreeBSD: src/sys/boot/arm/at91/boot0/Makefile,v 1.3.2.1 2006/08/17 22:57:07 imp Exp $
+#  $FreeBSD: src/sys/boot/arm/at91/boot0/Makefile,v 1.5 2006/11/16 00:53:27 imp Exp $
+
+.PATH:	${.CURDIR}/../libat91
 
 P=boot0
 FILES=${P}
-SRCS=arm_init.s main.c
+SRCS=arm_init.S main.c
 NO_MAN=
-LDFLAGS=-e 0 -T linker.cfg
+LDFLAGS=-e 0 -T ${.CURDIR}/linker.cfg
 OBJS+=  ${SRCS:N*.h:R:S/$/.o/g}
 
 .include <bsd.prog.mk>
 
+CFLAGS+=-DBOOT_BOOT0
Index: arm/at91/boot0/README
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0/README,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 README
--- arm/at91/boot0/README	17 Aug 2006 22:57:07 -0000	1.1.2.1
+++ arm/at91/boot0/README	12 Apr 2006 21:22:44 -0000
@@ -4,4 +4,4 @@
 the program at a 1MB offset into SDRAM.  Programs are expected to be
 smaller than this and copy themselves to the right location.
 
-$FreeBSD: src/sys/boot/arm/at91/boot0/README,v 1.1.2.1 2006/08/17 22:57:07 imp Exp $
+$FreeBSD: src/sys/boot/arm/at91/boot0/README,v 1.1 2006/04/12 21:22:44 imp Exp $
Index: arm/at91/boot0/linker.cfg
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0/linker.cfg,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 linker.cfg
--- arm/at91/boot0/linker.cfg	17 Aug 2006 22:57:07 -0000	1.1.2.1
+++ arm/at91/boot0/linker.cfg	12 Apr 2006 21:22:44 -0000
@@ -18,7 +18,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/boot0/linker.cfg,v 1.1.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/boot0/linker.cfg,v 1.1 2006/04/12 21:22:44 imp Exp $
  ******************************************************************************/
 OUTPUT_FORMAT("elf32-littlearm", "elf32-bigarm",
 	      "elf32-littlearm")
Index: arm/at91/boot0/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0/main.c,v
retrieving revision 1.4.2.1
diff -u -r1.4.2.1 main.c
--- arm/at91/boot0/main.c	17 Aug 2006 22:57:07 -0000	1.4.2.1
+++ arm/at91/boot0/main.c	21 Apr 2006 07:45:57 -0000
@@ -21,7 +21,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/arm/at91/boot0/main.c,v 1.4.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/boot0/main.c,v 1.4 2006/04/21 07:45:57 imp Exp $
  */
 
 #include "at91rm9200.h"
Index: arm/at91/boot0iic/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0iic/Makefile,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 Makefile
--- arm/at91/boot0iic/Makefile	17 Aug 2006 22:57:07 -0000	1.2.2.1
+++ arm/at91/boot0iic/Makefile	16 Nov 2006 00:53:27 -0000
@@ -1,12 +1,14 @@
-#  $FreeBSD: src/sys/boot/arm/at91/boot0iic/Makefile,v 1.2.2.1 2006/08/17 22:57:07 imp Exp $
+#  $FreeBSD: src/sys/boot/arm/at91/boot0iic/Makefile,v 1.3 2006/11/16 00:53:27 imp Exp $
 
-.PATH:	${.CURDIR}/../boot0
+.PATH:	${.CURDIR}/../libat91
 
 P=boot0iic
 FILES=${P}
-SRCS=arm_init.s main.c
+SRCS=arm_init.S main.c
 NO_MAN=
 LDFLAGS=-e 0 -T ${.CURDIR}/../linker.cfg
 OBJS+=  ${SRCS:N*.h:R:S/$/.o/g}
 
 .include <bsd.prog.mk>
+
+CFLAGS+=-DBOOT_BOOT0
Index: arm/at91/boot0iic/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0iic/main.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 main.c
--- arm/at91/boot0iic/main.c	17 Aug 2006 22:57:07 -0000	1.2.2.1
+++ arm/at91/boot0iic/main.c	16 Nov 2006 00:49:50 -0000
@@ -21,7 +21,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/arm/at91/boot0iic/main.c,v 1.2.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/boot0iic/main.c,v 1.4 2006/11/16 00:49:50 imp Exp $
  */
 
 #include "at91rm9200.h"
@@ -32,12 +32,19 @@
 main(void)
 {
 	char *addr = (char *)SDRAM_BASE + (1 << 20); /* Load to base + 1MB */
+	int len, sec;
 
-	while (xmodem_rx(addr) == -1)
+	printf("\nSend data to be written into EEPROM\n");
+	while ((len = xmodem_rx(addr)) == -1)
 		continue;
+	sec = GetSeconds() + 1;
+	while (sec >= GetSeconds())
+		continue;
+	printf("\nWriting EEPROM from 0x%x to addr 0, 0x%x bytes\n", addr,
+	    len);
 	InitEEPROM();
-	printf("Writing EEPROM from 0x%x to addr 0\r\n", addr);
-	WriteEEPROM(0, addr, 8192);
-	printf("Write complete.  Press reset\r\n");
+	printf("init done\n");
+	WriteEEPROM(0, addr, len);
+	printf("\nWrote %d bytes.  Press reset\n", len);
 	return (1);
 }
Index: arm/at91/boot0spi/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0spi/Makefile,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 Makefile
--- arm/at91/boot0spi/Makefile	17 Aug 2006 22:57:07 -0000	1.2.2.1
+++ arm/at91/boot0spi/Makefile	16 Nov 2006 00:53:27 -0000
@@ -1,13 +1,14 @@
-#  $FreeBSD: src/sys/boot/arm/at91/boot0spi/Makefile,v 1.2.2.1 2006/08/17 22:57:07 imp Exp $
+#  $FreeBSD: src/sys/boot/arm/at91/boot0spi/Makefile,v 1.3 2006/11/16 00:53:27 imp Exp $
 
-.PATH:	${.CURDIR}/../boot0
+.PATH:	${.CURDIR}/../libat91
 
 P=boot0spi
 FILES=${P}
-SRCS=arm_init.s main.c
+SRCS=arm_init.S main.c
 NO_MAN=
 LDFLAGS=-e 0 -T ${.CURDIR}/../linker.cfg
 OBJS+=  ${SRCS:N*.h:R:S/$/.o/g}
 
 .include <bsd.prog.mk>
 
+CFLAGS+=-DBOOT_BOOT0
Index: arm/at91/boot0spi/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/boot0spi/main.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 main.c
--- arm/at91/boot0spi/main.c	17 Aug 2006 22:57:07 -0000	1.2.2.1
+++ arm/at91/boot0spi/main.c	20 Dec 2006 17:50:02 -0000
@@ -21,7 +21,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/arm/at91/boot0spi/main.c,v 1.2.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/boot0spi/main.c,v 1.5 2006/12/20 17:50:02 imp Exp $
  */
 
 #include "at91rm9200.h"
@@ -29,23 +29,25 @@
 #include "at91rm9200_lowlevel.h"
 #include "spi_flash.h"
 
-#define OFFSET 0
+#define LOADER_OFFSET 0
+#define FPGA_OFFSET  (15 * FLASH_PAGE_SIZE)
+#define OFFSET FPGA_OFFSET
 
 int
 main(void)
 {
-	int len, i, j, off;
-	char *addr = (char *)SDRAM_BASE + (1 << 20); /* Load to base + 1MB */
-	char *addr2 = (char *)SDRAM_BASE + (2 << 20); /* Load to base + 2MB */
-	char *addr3 = (char *)SDRAM_BASE + (3 << 20); /* Load to base + 2MB */
+	int len, i, j, off, sec;
+	char *addr = (char *)SDRAM_BASE + (1 << 20); /* download at + 1MB */
+	char *addr2 = (char *)SDRAM_BASE + (2 << 20); /* readback to + 2MB */
+	char *addr3 = (char *)SDRAM_BASE + (3 << 20); /* extra copy at + 3MB */
 
 	SPI_InitFlash();
-	printf("Waiting for data\r\n");
+	printf("Waiting for data\n");
 	while ((len = xmodem_rx(addr)) == -1)
 		continue;
-	printf("\r\nDownloaded %u bytes.\r\n", len);
-	p_memcpy(addr3, addr, (len + FLASH_PAGE_SIZE - 1) / FLASH_PAGE_SIZE * FLASH_PAGE_SIZE);
-	printf("Writing %u bytes to flash at %u\r\n", len, OFFSET);
+	// Need extra copy at addr3
+	memcpy(addr3, addr, (len + FLASH_PAGE_SIZE - 1) / FLASH_PAGE_SIZE * FLASH_PAGE_SIZE);
+	printf("Writing %u bytes to flash at %u\n", len, OFFSET);
 	for (i = 0; i < len; i+= FLASH_PAGE_SIZE) {
 		for (j = 0; j < 10; j++) {
 			off = i + OFFSET;
@@ -55,7 +57,12 @@
 				break;
 		}
 		if (j >= 10)
-			printf("Bad Readback at %u\r\n", i);
+			printf("Bad Readback at %u\n", i);
 	}
+	sec = GetSeconds() + 2;
+	while (sec <= GetSeconds())
+	    continue;
+	printf("Done\n");
+	reset();
 	return (1);
 }
Index: arm/at91/bootiic/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootiic/Makefile,v
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 Makefile
--- arm/at91/bootiic/Makefile	17 Aug 2006 22:57:07 -0000	1.3.2.1
+++ arm/at91/bootiic/Makefile	16 Nov 2006 00:53:27 -0000
@@ -1,4 +1,6 @@
-#  $FreeBSD: src/sys/boot/arm/at91/bootiic/Makefile,v 1.3.2.1 2006/08/17 22:57:07 imp Exp $
+#  $FreeBSD: src/sys/boot/arm/at91/bootiic/Makefile,v 1.5 2006/11/16 00:53:27 imp Exp $
+
+.PATH:	${.CURDIR}/../libat91
 
 P=bootiic
 FILES=${P}
@@ -8,3 +10,5 @@
 OBJS+=  ${SRCS:N*.h:R:S/$/.o/g}
 
 .include <bsd.prog.mk>
+
+CFLAGS += -DBOOT_IIC -DBOOT_COMMANDS
Index: arm/at91/bootiic/README
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootiic/README,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 README
--- arm/at91/bootiic/README	17 Aug 2006 22:57:07 -0000	1.1.2.1
+++ arm/at91/bootiic/README	19 Apr 2006 17:16:48 -0000
@@ -1,4 +1,4 @@
-$FreeBSD: src/sys/boot/arm/at91/bootiic/README,v 1.1.2.1 2006/08/17 22:57:07 imp Exp $
+$FreeBSD: src/sys/boot/arm/at91/bootiic/README,v 1.1 2006/04/19 17:16:48 imp Exp $
 
 This image is intended to be programmed into boot EEPROM.  The image is nearly
 0x4000 so it will not fit in KB9200's 0x2000.  It is intended for KB9201 or
Index: arm/at91/bootiic/env_vars.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootiic/env_vars.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 env_vars.c
--- arm/at91/bootiic/env_vars.c	17 Aug 2006 22:57:07 -0000	1.1.2.1
+++ arm/at91/bootiic/env_vars.c	21 Oct 2006 22:43:39 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootiic/env_vars.c,v 1.1.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootiic/env_vars.c,v 1.2 2006/10/21 22:43:39 imp Exp $
  *****************************************************************************/
 
 #include "env_vars.h"
@@ -93,7 +93,7 @@
 		if (size < 0) {
 			continue;
 		}
-		p_memcpy(cPtr, boot_commands[i], copySize);
+		memcpy(cPtr, boot_commands[i], copySize);
 		cPtr += copySize;
 		*cPtr++ = 0;
 	}
Index: arm/at91/bootiic/env_vars.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootiic/env_vars.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 env_vars.h
--- arm/at91/bootiic/env_vars.h	17 Aug 2006 22:57:07 -0000	1.1.2.1
+++ arm/at91/bootiic/env_vars.h	10 Aug 2006 19:55:52 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootiic/env_vars.h,v 1.1.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootiic/env_vars.h,v 1.1 2006/08/10 19:55:52 imp Exp $
  *****************************************************************************/
 
 #ifndef _ENV_VARS_H_
Index: arm/at91/bootiic/loader_prompt.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootiic/loader_prompt.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 loader_prompt.c
--- arm/at91/bootiic/loader_prompt.c	17 Aug 2006 22:57:07 -0000	1.2.2.1
+++ arm/at91/bootiic/loader_prompt.c	21 Oct 2006 22:43:39 -0000
@@ -19,7 +19,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootiic/loader_prompt.c,v 1.2.2.1 2006/08/17 22:57:07 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootiic/loader_prompt.c,v 1.3 2006/10/21 22:43:39 imp Exp $
  *****************************************************************************/
 
 #include "at91rm9200_lowlevel.h"
@@ -93,7 +93,7 @@
 	int	i;
 
 	for (i = 0; CommandTable[i].command != COMMAND_FINAL_FLAG; ++i)
-		if (!p_strcmp(CommandTable[i].c_string, cPtr))
+		if (!strcmp(CommandTable[i].c_string, cPtr))
 			return (CommandTable[i].command);
 
 	return (COMMAND_INVALID);
@@ -188,7 +188,7 @@
 			to = (char *)p_ASCIIToHex(argv[1]);
 			from = (char *)p_ASCIIToHex(argv[2]);
 			size = p_ASCIIToHex(argv[3]);
-			p_memcpy(to, from, size);
+			memcpy(to, from, size);
 		}
 		break;
 	}
@@ -234,20 +234,20 @@
 
 	case COMMAND_HELP:
 		// dump command info
-		printf("Commands:\r\n"
-		"\tc\r\n"
-		"\td\r\n"
-		"\te\r\n"
-		"\tip\r\n"
-		"\tserver_ip\r\n"
-		"\tm\r\n"
-		"\ttftp\r\n"
-		"\ts\r\n"
+		printf("Commands:\n"
+		"\tc\n"
+		"\td\n"
+		"\te\n"
+		"\tip\n"
+		"\tserver_ip\n"
+		"\tm\n"
+		"\ttftp\n"
+		"\ts\n"
 #ifdef SUPPORT_TAG_LIST
-		"\tt\r\n"
+		"\tt\n"
 #endif
-		"\tw\r\n"
-		"\tx\r\n");
+		"\tw\n"
+		"\tx\n");
 		break;
 
 	case COMMAND_LOCAL_IP:
@@ -315,7 +315,7 @@
 		break;
 	}
 
-	printf("\r\n");
+	printf("\n");
 }
 
 
@@ -324,7 +324,7 @@
  * void ServicePrompt(char)
  *  This private function process each character checking for valid commands.
  * This function is only executed if the character is considered valid.
- * Each command is terminated with NULL (0) or '\r'.
+ * Each command is terminated with NULL (0) or ''.
  * .KB_C_FN_DEFINITION_END
  */
 static void
@@ -346,11 +346,11 @@
 		putchar(p_char);
 	}
 	if (!p_char) {
-		printf("\r\n");
+		printf("\n");
 		ParseCommand(inputBuffer);
 		p_memset(inputBuffer, 0, MAX_INPUT_SIZE);
 		buffCount = 0;
-		printf("\r\n>");
+		printf("\n>");
 	}
 }
 
@@ -379,7 +379,7 @@
 		inputFunction = getc;
 	}
 
-	printf("\r\n>");
+	printf("\n>");
 
 	while (1)
 		if ((ch = ((*inputFunction)(0))) > 0)
Index: arm/at91/bootiic/loader_prompt.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootiic/loader_prompt.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 loader_prompt.h
--- arm/at91/bootiic/loader_prompt.h	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/bootiic/loader_prompt.h	10 Aug 2006 19:55:52 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootiic/loader_prompt.h,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootiic/loader_prompt.h,v 1.1 2006/08/10 19:55:52 imp Exp $
  *****************************************************************************/
 
 #ifndef _LOADER_PROMPT_H_
Index: arm/at91/bootiic/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootiic/main.c,v
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 main.c
--- arm/at91/bootiic/main.c	17 Aug 2006 22:57:08 -0000	1.3.2.1
+++ arm/at91/bootiic/main.c	10 Aug 2006 19:55:52 -0000
@@ -19,7 +19,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootiic/main.c,v 1.3.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootiic/main.c,v 1.3 2006/08/10 19:55:52 imp Exp $
  ******************************************************************************/
 
 #include "env_vars.h"
Index: arm/at91/bootspi/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootspi/Makefile,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 Makefile
--- arm/at91/bootspi/Makefile	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/bootspi/Makefile	16 Nov 2006 00:53:27 -0000
@@ -1,14 +1,17 @@
-#  $FreeBSD: src/sys/boot/arm/at91/bootspi/Makefile,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+#  $FreeBSD: src/sys/boot/arm/at91/bootspi/Makefile,v 1.6 2006/11/16 00:53:27 imp Exp $
+
+.PATH:	${.CURDIR}/../libat91
 
 P=bootspi
 FILES=${P}
-SRCS=arm_init.S main.c loader_prompt.c env_vars.c
+SRCS=arm_init.S main.c loader_prompt.c env_vars.c ee.c
 NO_MAN=
 LDFLAGS=-e 0 -T ${.CURDIR}/../linker.cfg
 OBJS+=  ${SRCS:N*.h:R:S/$/.o/g}
 
 .include <bsd.prog.mk>
 
-.if ${MK_FPGA} != "no"
+.if ${MK_FPGA} == "yes"
 CFLAGS += -DTSC_FPGA
 .endif
+CFLAGS += -DBOOT_COMMANDS
Index: arm/at91/bootspi/README
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootspi/README,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 README
--- arm/at91/bootspi/README	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/bootspi/README	19 Apr 2006 17:16:48 -0000
@@ -1,4 +1,4 @@
-$FreeBSD: src/sys/boot/arm/at91/bootspi/README,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+$FreeBSD: src/sys/boot/arm/at91/bootspi/README,v 1.1 2006/04/19 17:16:48 imp Exp $
 
 This image is intended to be programmed into boot EEPROM.  The image is nearly
 0x4000 so it will not fit in KB9200's 0x2000.  It is intended for KB9201 or
Index: arm/at91/bootspi/env_vars.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootspi/env_vars.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 env_vars.c
--- arm/at91/bootspi/env_vars.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/bootspi/env_vars.c	21 Oct 2006 22:44:26 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootspi/env_vars.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootspi/env_vars.c,v 1.2 2006/10/21 22:44:26 imp Exp $
  *****************************************************************************/
 
 #include "env_vars.h"
@@ -82,7 +82,7 @@
 	int	i;
 
 	for (i = 0; boot_commands[i][0]; i++)
-		printf("0x%x : %s[E]\r\n", i, boot_commands[i]);
+		printf("0x%x : %s[E]\n", i, boot_commands[i]);
 }
 
 
@@ -125,6 +125,6 @@
 	currentOffset = 0;
 
 	DumpBootCommands();
-	printf("Autoboot...\r\n");
+	printf("Autoboot...\n");
 	Bootloader(ReadCharFromEnvironment);
 }
Index: arm/at91/bootspi/env_vars.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootspi/env_vars.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 env_vars.h
--- arm/at91/bootspi/env_vars.h	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/bootspi/env_vars.h	16 Aug 2006 23:39:58 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootspi/env_vars.h,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootspi/env_vars.h,v 1.1 2006/08/16 23:39:58 imp Exp $
  *****************************************************************************/
 
 #ifndef _ENV_VARS_H_
Index: arm/at91/bootspi/loader_prompt.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootspi/loader_prompt.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 loader_prompt.c
--- arm/at91/bootspi/loader_prompt.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/bootspi/loader_prompt.c	15 Mar 2007 03:31:48 -0000
@@ -19,7 +19,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootspi/loader_prompt.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootspi/loader_prompt.c,v 1.4 2007/03/15 03:31:48 imp Exp $
  *****************************************************************************/
 
 #include "at91rm9200_lowlevel.h"
@@ -29,6 +29,7 @@
 #include "env_vars.h"
 #include "lib.h"
 #include "spi_flash.h"
+#include "ee.h"
 
 /******************************* GLOBALS *************************************/
 
@@ -42,8 +43,6 @@
 static char	*argv[MAX_COMMAND_PARAMS];
 
 #define FLASH_OFFSET (0 * FLASH_PAGE_SIZE)
-#define FPGA_OFFSET  (15 * FLASH_PAGE_SIZE)
-#define FPGA_LEN     (212608)
 #define KERNEL_OFFSET (220 * FLASH_PAGE_SIZE)
 #define KERNEL_LEN (6 * 1024 * FLASH_PAGE_SIZE)
 static const char *backspaceString = "\010 \010";
@@ -60,7 +59,6 @@
 	{COMMAND_LOAD_SPI_KERNEL, "k"},
 	{COMMAND_REPLACE_KERNEL_VIA_XMODEM, "K"},
 	{COMMAND_REPLACE_FLASH_VIA_XMODEM, "I"},
-	{COMMAND_REPLACE_FPGA_VIA_XMODEM, "F"},
 	{COMMAND_REPLACE_ID_EEPROM, "E"},
 	{COMMAND_FINAL_FLAG, 0}
 };
@@ -93,7 +91,7 @@
 	int	i;
 
 	for (i = 0; CommandTable[i].command != COMMAND_FINAL_FLAG; ++i)
-		if (!p_strcmp(CommandTable[i].c_string, cPtr))
+		if (!strcmp(CommandTable[i].c_string, cPtr))
 			return (CommandTable[i].command);
 
 	return (COMMAND_INVALID);
@@ -150,7 +148,7 @@
 
 	while ((len = xmodem_rx(addr)) == -1)
 		continue;
-	printf("\r\nDownloaded %u bytes.\r\n", len);
+	printf("\nDownloaded %u bytes.\n", len);
 	WriteEEPROM(eeaddr, 0, addr, len);
 }
 #endif
@@ -163,7 +161,7 @@
 
 	while ((len = xmodem_rx(addr)) == -1)
 		continue;
-	printf("\r\nDownloaded %u bytes.\r\n", len);
+	printf("\nDownloaded %u bytes.\n", len);
 	for (i = 0; i < len; i+= FLASH_PAGE_SIZE) {
 		off = i + offset;
 		SPI_WriteFlash(off, addr + i, FLASH_PAGE_SIZE);
@@ -270,29 +268,34 @@
 		break;
 
 	case COMMAND_RESET:
-		printf("Reset\r\n");
+		printf("Reset\n");
 		reset();
 		while (1) continue;
 		break;
 
 	case COMMAND_REPLACE_KERNEL_VIA_XMODEM:
-		printf("Updating KERNEL image\r\n");
+		printf("Updating KERNEL image\n");
 		UpdateFlash(KERNEL_OFFSET);
 		break;
-	case COMMAND_REPLACE_FPGA_VIA_XMODEM:
-		printf("Updating FPGA image\r\n");
-		UpdateFlash(FPGA_OFFSET);
-		break;
 	case COMMAND_REPLACE_FLASH_VIA_XMODEM: 
-		printf("Updating FLASH image\r\n");
+		printf("Updating FLASH image\n");
 		UpdateFlash(FLASH_OFFSET);
 		break;
 
+	case COMMAND_REPLACE_ID_EEPROM: 
+	{
+	    char buf[25];
+		printf("Testing Config EEPROM\n");
+		EEWrite(0, "This is a test", 15);
+		EERead(0, buf, 15);
+		printf("Found '%s'\n", buf);
+		break;
+	}
 	default:
 		break;
 	}
 
-	printf("\r\n");
+	printf("\n");
 }
 
 
@@ -301,7 +304,7 @@
  * void ServicePrompt(char)
  *  This private function process each character checking for valid commands.
  * This function is only executed if the character is considered valid.
- * Each command is terminated with NULL (0) or '\r'.
+ * Each command is terminated with NULL (0) or ''.
  * .KB_C_FN_DEFINITION_END
  */
 static void
@@ -323,11 +326,11 @@
 		putchar(p_char);
 	}
 	if (!p_char) {
-		printf("\r\n");
+		printf("\n");
 		ParseCommand(inputBuffer);
 		p_memset(inputBuffer, 0, MAX_INPUT_SIZE);
 		buffCount = 0;
-		printf("\r\n>");
+		printf("\n>");
 	}
 }
 
@@ -352,7 +355,7 @@
 	p_memset((void*)inputBuffer, 0, sizeof(inputBuffer));
 	buffCount = 0;
 
-	printf("\r\n>");
+	printf("\n>");
 
 	while (1)
 		if ((ch = ((*inputFunction)(0))) > 0)
Index: arm/at91/bootspi/loader_prompt.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootspi/loader_prompt.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 loader_prompt.h
--- arm/at91/bootspi/loader_prompt.h	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/bootspi/loader_prompt.h	16 Aug 2006 23:39:58 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootspi/loader_prompt.h,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootspi/loader_prompt.h,v 1.1 2006/08/16 23:39:58 imp Exp $
  *****************************************************************************/
 
 #ifndef _LOADER_PROMPT_H_
Index: arm/at91/bootspi/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/bootspi/main.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 main.c
--- arm/at91/bootspi/main.c	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/bootspi/main.c	21 Oct 2006 22:44:26 -0000
@@ -31,7 +31,7 @@
  * owners.  This software is not copyrighted and is intended for reference
  * only.
  *
- * $FreeBSD: src/sys/boot/arm/at91/bootspi/main.c,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/bootspi/main.c,v 1.3 2006/10/21 22:44:26 imp Exp $
  */
 
 #include "env_vars.h"
@@ -41,12 +41,17 @@
 #include "emac.h"
 #include "lib.h"
 #include "spi_flash.h"
+#include "ee.h"
 
 int
 main(void)
 {
-	printf("\r\nBoot\r\n");
+	printf("\nBoot\n");
+	EEInit();
 	SPI_InitFlash();
+#ifdef TSC_FPGA
+	fpga_load();
+#endif
 	EMAC_Init();
 	LoadBootCommands();
 	if (getc(1) == -1) {
Index: arm/at91/libat91/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/Makefile,v
retrieving revision 1.4.2.1
diff -u -r1.4.2.1 Makefile
--- arm/at91/libat91/Makefile	17 Aug 2006 22:57:08 -0000	1.4.2.1
+++ arm/at91/libat91/Makefile	15 Mar 2007 03:31:49 -0000
@@ -1,12 +1,14 @@
-#  $FreeBSD: src/sys/boot/arm/at91/libat91/Makefile,v 1.4.2.1 2006/08/17 22:57:08 imp Exp $
+#  $FreeBSD: src/sys/boot/arm/at91/libat91/Makefile,v 1.8 2007/03/15 03:31:49 imp Exp $
 
 .include "${.CURDIR}/../Makefile.inc"
 
 LIB=		at91
 INTERNALLIB=
 SRCS=at91rm9200_lowlevel.c delay.c eeprom.c emac.c emac_init.c getc.c \
-	p_string.c putchar.c printf.c reset.c spi_flash.c xmodem.c \
-	sd-card.c mci_device.c
+	putchar.c printf.c reset.c spi_flash.c xmodem.c \
+	sd-card.c strcvt.c strlen.c strcmp.c memcpy.c strcpy.c \
+	memset.c memcmp.c
+SRCS+=ashldi3.c divsi3.S
 NO_MAN=
 
 .if ${MK_TAG_LIST} != "no"
Index: arm/at91/libat91/at91rm9200.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/at91rm9200.h,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 at91rm9200.h
--- arm/at91/libat91/at91rm9200.h	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/at91rm9200.h	20 Oct 2006 09:12:05 -0000
@@ -7,7 +7,7 @@
 //  fitness for any particular purpose, or against the infringements of
 //  intellectual property rights of others.
 // ----------------------------------------------------------------------------
-// $FreeBSD: src/sys/boot/arm/at91/libat91/at91rm9200.h,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+// $FreeBSD: src/sys/boot/arm/at91/libat91/at91rm9200.h,v 1.3 2006/10/20 09:12:05 imp Exp $
 //
 // File Name           : AT91RM9200.h
 // Object              : AT91RM9200 definitions
@@ -1156,28 +1156,6 @@
 #define	AT91C_MCI_SCDSEL      (0x1u <<  0) // (MCI) SD Card Selector
 #define	AT91C_MCI_SCDBUS      (0x1u <<  7) // (MCI) SD Card Bus Width
 // -------- MCI_CMDR : (MCI Offset: 0x14) MCI Command Register -------- 
-#define	AT91C_MCI_CMDNB       (0x1Fu <<  0) // (MCI) Command Number
-#define	AT91C_MCI_RSPTYP      (0x3u <<  6) // (MCI) Response Type
-#define		AT91C_MCI_RSPTYP_NO                   (0x0u <<  6) // (MCI) No response
-#define		AT91C_MCI_RSPTYP_48                   (0x1u <<  6) // (MCI) 48-bit response
-#define		AT91C_MCI_RSPTYP_136                  (0x2u <<  6) // (MCI) 136-bit response
-#define	AT91C_MCI_SPCMD       (0x7u <<  8) // (MCI) Special CMD
-#define		AT91C_MCI_SPCMD_NONE                 (0x0u <<  8) // (MCI) Not a special CMD
-#define		AT91C_MCI_SPCMD_INIT                 (0x1u <<  8) // (MCI) Initialization CMD
-#define		AT91C_MCI_SPCMD_SYNC                 (0x2u <<  8) // (MCI) Synchronized CMD
-#define		AT91C_MCI_SPCMD_IT_CMD               (0x4u <<  8) // (MCI) Interrupt command
-#define		AT91C_MCI_SPCMD_IT_REP               (0x5u <<  8) // (MCI) Interrupt response
-#define	AT91C_MCI_OPDCMD      (0x1u << 11) // (MCI) Open Drain Command
-#define	AT91C_MCI_MAXLAT      (0x1u << 12) // (MCI) Maximum Latency for Command to respond
-#define	AT91C_MCI_TRCMD       (0x3u << 16) // (MCI) Transfer CMD
-#define		AT91C_MCI_TRCMD_NO                   (0x0u << 16) // (MCI) No transfer
-#define		AT91C_MCI_TRCMD_START                (0x1u << 16) // (MCI) Start transfer
-#define		AT91C_MCI_TRCMD_STOP                 (0x2u << 16) // (MCI) Stop transfer
-#define	AT91C_MCI_TRDIR       (0x1u << 18) // (MCI) Transfer Direction
-#define	AT91C_MCI_TRTYP       (0x3u << 19) // (MCI) Transfer Type
-#define		AT91C_MCI_TRTYP_BLOCK                (0x0u << 19) // (MCI) Block Transfer type
-#define		AT91C_MCI_TRTYP_MULTIPLE             (0x1u << 19) // (MCI) Multiple Block transfer type
-#define		AT91C_MCI_TRTYP_STREAM               (0x2u << 19) // (MCI) Stream transfer type
 // -------- MCI_SR : (MCI Offset: 0x40) MCI Status Register -------- 
 #define	AT91C_MCI_CMDRDY      (0x1u <<  0) // (MCI) Command Ready flag
 #define	AT91C_MCI_RXRDY       (0x1u <<  1) // (MCI) RX Ready flag
Index: arm/at91/libat91/at91rm9200_lowlevel.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/at91rm9200_lowlevel.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 at91rm9200_lowlevel.c
--- arm/at91/libat91/at91rm9200_lowlevel.c	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/at91rm9200_lowlevel.c	28 Mar 2007 22:40:37 -0000
@@ -24,12 +24,15 @@
  * This software is derived from software provide by Kwikbyte who specifically
  * disclaimed copyright on the code.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/at91rm9200_lowlevel.c,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/at91rm9200_lowlevel.c,v 1.5 2007/03/28 22:40:37 imp Exp $
  */
 
 #include "at91rm9200.h"
 #include "at91rm9200_lowlevel.h"
 
+extern int __bss_start__[];
+extern int __bss_end__[];
+
 #define BAUD	115200
 #define AT91C_US_ASYNC_MODE (AT91C_US_USMODE_NORMAL | AT91C_US_NBSTOP_1_BIT | \
 		AT91C_US_PAR_NONE | AT91C_US_CHRL_8_BITS | AT91C_US_CLKS_CLOCK)
@@ -42,12 +45,15 @@
 void
 _init(void)
 {
+	int *i;
+
 	AT91PS_USART pUSART = (AT91PS_USART)AT91C_BASE_DBGU;
 	AT91PS_PDC pPDC = (AT91PS_PDC)&(pUSART->US_RPR);
 
 	register unsigned	value;
 	volatile sdram_size_t *p = (sdram_size_t *)SDRAM_BASE;
 
+	AT91C_BASE_ST->ST_RTMR = 1;
 #ifdef BOOT_TSC
 	// For the TSC board, we turn ON the one LED we have while
 	// early in boot.
@@ -56,6 +62,16 @@
 	AT91C_BASE_PIOC->PIO_CODR = AT91C_PIO_PC10;
 #endif
 
+#ifdef BOOT_KB920X
+	AT91C_BASE_PIOC->PIO_PER = AT91C_PIO_PC18 | AT91C_PIO_PC19 |
+	  AT91C_PIO_PC20;
+	AT91C_BASE_PIOC->PIO_OER = AT91C_PIO_PC18 | AT91C_PIO_PC19 |
+	  AT91C_PIO_PC20;
+	AT91C_BASE_PIOC->PIO_SODR = AT91C_PIO_PC18 | AT91C_PIO_PC19 |
+	  AT91C_PIO_PC20;
+	AT91C_BASE_PIOC->PIO_CODR = AT91C_PIO_PC18;
+#endif
+
 	// configure clocks
 	// assume:
 	//    main osc = 10Mhz
@@ -93,7 +109,7 @@
 	while (!(AT91C_BASE_PMC->PMC_SR & AT91C_PMC_MCKRDY))
 		continue;
 
-#ifdef BOOT_KB9202
+#ifdef BOOT_KB920X
 	// setup flash access (allow ample margin)
 	// 9 wait states, 1 setup, 1 hold, 1 float for 8-bit device
 	((AT91PS_SMC2)AT91C_BASE_SMC2)->SMC2_CSR[0] =
@@ -195,4 +211,9 @@
 	pUSART->US_MR = AT91C_US_ASYNC_MODE;
 	pUSART->US_CR = AT91C_US_TXEN;
 	pUSART->US_CR = AT91C_US_RXEN;
+
+	/* Zero BSS now that we have memory setup */
+	i = (int *)__bss_start__;
+	while (i < (int *)__bss_end__)
+		*i++ = 0;
 }
Index: arm/at91/libat91/at91rm9200_lowlevel.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/at91rm9200_lowlevel.h,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 at91rm9200_lowlevel.h
--- arm/at91/libat91/at91rm9200_lowlevel.h	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/at91rm9200_lowlevel.h	28 Mar 2007 22:40:37 -0000
@@ -21,7 +21,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/at91rm9200_lowlevel.h,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/at91rm9200_lowlevel.h,v 1.5 2007/03/28 22:40:37 imp Exp $
  */
 
 #ifndef _AT91RM9200_LOWLEVEL_H_
@@ -31,7 +31,7 @@
 
 #define SDRAM_BASE		0x20000000
 
-#ifdef BOOT_KB9202
+#ifdef BOOT_KB920X
 /* The following divisor sets PLLA frequency: e.g. 10/5 * 90 = 180MHz */
 #define OSC_MAIN_FREQ_DIV	5	/* for 10MHz osc */
 #define SDRAM_WIDTH	AT91C_SDRC_DBW_16_BITS
@@ -39,6 +39,14 @@
 #define OSC_MAIN_MULT		90
 #endif
 
+#ifdef BOOT_BWCT
+/* The following divisor sets PLLA frequency: e.g. 16/4 * 45 = 180MHz */
+#define OSC_MAIN_FREQ_DIV	4	/* for 16MHz osc */
+#define SDRAM_WIDTH	AT91C_SDRC_DBW_32_BITS
+typedef unsigned int sdram_size_t;
+#define OSC_MAIN_MULT		45
+#endif
+
 #ifdef BOOT_TSC
 /* The following divisor sets PLLA frequency: e.g. 16/4 * 45 = 180MHz */
 #define OSC_MAIN_FREQ_DIV	4	/* for 16MHz osc */
@@ -50,7 +58,8 @@
 /* Master clock frequency at power-up */
 #define AT91C_MASTER_CLOCK 60000000
 
-#define GetSeconds() (AT91C_BASE_RTC->RTC_TIMR & AT91C_RTC_SEC)
+/* #define GetSeconds() (AT91C_BASE_RTC->RTC_TIMR & AT91C_RTC_SEC) */
+#define GetSeconds() (AT91C_BASE_ST->ST_CRTR >> 15)
 
 extern void _init(void);
 
Index: arm/at91/libat91/delay.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/delay.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 delay.c
--- arm/at91/libat91/delay.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/delay.c	16 Aug 2006 23:39:58 -0000
@@ -24,7 +24,7 @@
  * This software is derived from software provide by Kwikbyte who specifically
  * disclaimed copyright on the code.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/delay.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/delay.c,v 1.1 2006/08/16 23:39:58 imp Exp $
  */
 
 #include "at91rm9200.h"
Index: arm/at91/libat91/eeprom.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/eeprom.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 eeprom.c
--- arm/at91/libat91/eeprom.c	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/eeprom.c	20 Dec 2006 18:19:52 -0000
@@ -18,7 +18,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/eeprom.c,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/eeprom.c,v 1.3 2006/12/20 18:19:52 imp Exp $
  *****************************************************************************/
 
 #include "at91rm9200_lowlevel.h"
@@ -82,11 +82,12 @@
  * This function does not utilize the page read mode to simplify the code.
  * .KB_C_FN_DEFINITION_END
  */
-void
+int
 ReadEEPROM(unsigned ee_off, char *data_addr, unsigned size)
 {
 	const AT91PS_TWI 	twiPtr = AT91C_BASE_TWI;
 	unsigned int status;
+	unsigned int count;
 
 	status = twiPtr->TWI_SR;
 	status = twiPtr->TWI_RHR;
@@ -104,10 +105,12 @@
 	status = twiPtr->TWI_SR;
 
 	while (size-- > 1){
-
 		// Wait RHR Holding register is full
-		while (!(twiPtr->TWI_SR & AT91C_TWI_RXRDY))
+		count = 1000000;
+		while (!(twiPtr->TWI_SR & AT91C_TWI_RXRDY) && --count > 0)
 			continue;
+		if (count <= 0)
+			return -1;
 
 		// Read byte
 		*(data_addr++) = twiPtr->TWI_RHR;
@@ -123,6 +126,7 @@
 
 	// Read last byte
 	*data_addr = twiPtr->TWI_RHR;
+	return 0;
 }
 
 
Index: arm/at91/libat91/emac.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/emac.c,v
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 emac.c
--- arm/at91/libat91/emac.c	17 Aug 2006 22:57:08 -0000	1.3.2.1
+++ arm/at91/libat91/emac.c	28 Mar 2007 22:40:37 -0000
@@ -19,7 +19,7 @@
  * only.
  * END_BLOCK
  * 
- * $FreeBSD: src/sys/boot/arm/at91/libat91/emac.c,v 1.3.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/emac.c,v 1.7 2007/03/28 22:40:37 imp Exp $
  ******************************************************************************/
 
 #include "at91rm9200.h"
@@ -31,7 +31,13 @@
 
 /* ********************** PRIVATE FUNCTIONS/DATA ******************************/
 
-static char serverMACAddr[6];
+static receive_descriptor_t *p_rxBD;
+static unsigned short localPort;
+static unsigned short serverPort;
+static unsigned serverMACSet;
+static unsigned localIPSet, serverIPSet;
+static unsigned	lastSize;
+static unsigned char serverMACAddr[6];
 static unsigned char localIPAddr[4], serverIPAddr[4];
 static int	ackBlock;
 static char *dlAddress;
@@ -75,7 +81,7 @@
 
 	p_memset((char*)p_ARP->dest_mac, 0xFF, 6);
 
-	p_memcpy((char*)p_ARP->src_mac, (char*)localMACAddr, 6);
+	memcpy(p_ARP->src_mac, localMACAddr, 6);
 
 	p_ARP->frame_type = SWAP16(PROTOCOL_ARP);
 	p_ARP->hard_type  = SWAP16(1);
@@ -84,13 +90,10 @@
 	p_ARP->prot_size  = 4;
 	p_ARP->operation  = SWAP16(ARP_REQUEST);
 
-	p_memcpy((char*)p_ARP->sender_mac, (char*)localMACAddr, 6);
-
-	p_memcpy((char*)p_ARP->sender_ip, (char*)localIPAddr, 4);
-
+	memcpy(p_ARP->sender_mac, localMACAddr, 6);
+	memcpy(p_ARP->sender_ip, localIPAddr, 4);
 	p_memset((char*)p_ARP->target_mac, 0, 6);
-
-	p_memcpy((char*)p_ARP->target_ip, (char*)serverIPAddr, 4);
+	memcpy(p_ARP->target_ip, serverIPAddr, 4);
 
 	// wait until transmit is available
 	while (!(*AT91C_EMAC_TSR & AT91C_EMAC_BNQ)) ;
@@ -115,10 +118,8 @@
 	udp_header_t		*udpHdr;
 	unsigned		t_checksum;
 
-	p_memcpy((char*)macHdr->dest_mac, (char*)serverMACAddr, 6);
-
-	p_memcpy((char*)macHdr->src_mac, (char*)localMACAddr, 6);
-
+	memcpy(macHdr->dest_mac, serverMACAddr, 6);
+	memcpy(macHdr->src_mac, localMACAddr, 6);
 	macHdr->proto_mac = SWAP16(PROTOCOL_IP);
 
 	ipHdr = (ip_header_t*)&macHdr->packet_length;
@@ -132,9 +133,8 @@
 	ipHdr->ip_p = PROTOCOL_UDP;
 	ipHdr->ip_sum = 0;
 
-	p_memcpy((char*)ipHdr->ip_src, (char*)localIPAddr, 4);
-
-	p_memcpy((char*)ipHdr->ip_dst, (char*)serverIPAddr, 4);
+	memcpy(ipHdr->ip_src, localIPAddr, 4);
+	memcpy(ipHdr->ip_dst, serverIPAddr, 4);
 
 	ipHdr->ip_sum = SWAP16(IP_checksum((unsigned short*)ipHdr, 20));
 
@@ -145,7 +145,7 @@
 	udpHdr->udp_len   = SWAP16(8 + tftpLength);
 	udpHdr->udp_cksum = 0;
 
-	p_memcpy((char*)udpHdr+8, tftpData, tftpLength);
+	memcpy((char *)udpHdr+8, tftpData, tftpLength);
 
 	t_checksum = IP_checksum((unsigned short*)ipHdr + 6, (16 + tftpLength));
 
@@ -182,8 +182,8 @@
 
 	cPtr = (char*)&(tftpHeader.block_num);
 
-	ePtr = p_strcpy(cPtr, filename);
-	mPtr = p_strcpy(ePtr, "octet");
+	ePtr = strcpy(cPtr, filename);
+	mPtr = strcpy(ePtr, "octet");
 
 	length = mPtr - cPtr;
 	length += 2;
@@ -205,7 +205,7 @@
 
 	if (block_num == (ackBlock + 1)) {
 		++ackBlock;
-		p_memcpy(dlAddress, data, len);
+		memcpy(dlAddress, data, len);
 		dlAddress += len;
 		lastSize += len;
 		if (ackBlock % 128 == 0)
@@ -216,7 +216,7 @@
 	Send_TFTP_Packet((char*)&tftpHeader, 4);
 	if (len < 512) {
 		ackBlock = -2;
-		printf("tftp: %u byte\r\n", lastSize);
+		printf("tftp: %u byte\n", lastSize);
 	}
 }
 
@@ -249,7 +249,6 @@
 		
 	if (!process)
 		return (0);
-						
 	process = i;
 		
 	pFrameType = (unsigned short *)((p_rxBD[i].address & 0xFFFFFFFC) + 12);
@@ -266,9 +265,7 @@
 					(char*)serverIPAddr, 4)))) {
 
 				serverMACSet = 1;
-
-				p_memcpy((char*)serverMACAddr,
-					(char*)p_ARP->sender_mac, 6);
+				memcpy(serverMACAddr, p_ARP->sender_mac, 6);
 			}
 		} else if (p_ARP->operation == SWAP16(ARP_REQUEST)) {
 			// ARP REPLY operation
@@ -299,7 +296,7 @@
 		break;
 	case SWAP16(PROTOCOL_IP):
 		pIpHeader = (ip_header_t*)(pData + 14);			
-		p_memcpy((char*)pHeader, (char*)pIpHeader,sizeof(ip_header_t));
+		memcpy(pHeader, pIpHeader, sizeof(ip_header_t));
 		
 		if (pIpHeader->ip_p == PROTOCOL_UDP) {
 			udp_header_t	*udpHdr;
@@ -340,6 +337,7 @@
  *  This private function reads the PHY device.
  * .KB_C_FN_DEFINITION_END
  */
+#ifndef BOOT_BWCT
 static unsigned short
 AT91F_MII_ReadPhy (AT91PS_EMAC pEmac, unsigned char addr)
 {
@@ -351,11 +349,12 @@
 	pEmac->EMAC_CTL &= ~AT91C_EMAC_MPE;
 	return (pEmac->EMAC_MAN & 0x0000ffff);
 }
+#endif
 
 /*
  * .KB_C_FN_DEFINITION_START
- * unsigned short AT91F_MII_ReadPhy (AT91PS_EMAC pEmac, unsigned char addr)
- *  This private function reads the PHY device.
+ * unsigned short AT91F_MII_WritePhy (AT91PS_EMAC pEmac, unsigned char addr, unsigned short s)
+ *  This private function writes the PHY device.
  * .KB_C_FN_DEFINITION_END
  */
 #ifdef BOOT_TSC
@@ -381,13 +380,21 @@
 static void
 MII_GetLinkSpeed(AT91PS_EMAC pEmac)
 {
+#if defined(BOOT_TSC) | defined(BOOT_KB920X)
 	unsigned short stat2; 
+#endif
 	unsigned update;
 #ifdef BOOT_TSC
 	unsigned sec;
 	int i;
 #endif
-#ifdef BOOT_KB9202
+#ifdef BOOT_BWCT
+	/* hardcoded link speed since we connect a switch via MII */
+	update = pEmac->EMAC_CFG & ~(AT91C_EMAC_SPD | AT91C_EMAC_FD);
+	update |= AT91C_EMAC_SPD;
+	update |= AT91C_EMAC_FD;
+#endif
+#ifdef BOOT_KB920X
 	stat2 = AT91F_MII_ReadPhy(pEmac, MII_STS2_REG);
 	if (!(stat2 & MII_STS2_LINK))
 		return ;
@@ -405,7 +412,8 @@
 				break;
 			printf(".");
 			sec = GetSeconds();
-			while (GetSeconds() <= sec) continue;
+			while (GetSeconds() == sec)
+			    continue;
 		}
 		if (stat2 & MII_STS_LINK_STAT)
 			break;
@@ -424,7 +432,7 @@
 		printf(" FDX");
 		update |= AT91C_EMAC_FD;
 	}
-	printf("\r\n");
+	printf("\n");
 #endif
 	pEmac->EMAC_CFG = update;
 }
@@ -443,6 +451,9 @@
 	char		*pRxPacket = (char*)RX_DATA_START;
 	AT91PS_EMAC	pEmac = AT91C_BASE_EMAC;
 
+	p_rxBD = (receive_descriptor_t*)RX_BUFFER_START;
+	localPort = SWAP16(0x8002);
+
 	for (i = 0; i < MAX_RX_PACKETS; ++i) {
 
 		p_rxBD[i].address = (unsigned)pRxPacket;
@@ -531,7 +542,7 @@
 	dlAddress = (char*)address;
 	lastSize = 0;
 	timeout = 10;
-	thisSeconds = GetSeconds() + 1;
+	thisSeconds = (GetSeconds() + 2) % 32;
 	serverPort = SWAP16(69);
 	++localPort;
 	ackBlock = -1;
@@ -541,10 +552,10 @@
 			if (ackBlock == -2)
 				break;
 			timeout = 10;
-			thisSeconds = GetSeconds() + 1;
-		} else if (GetSeconds() > thisSeconds) {
+			thisSeconds = (GetSeconds() + 2) % 32;
+		} else if (GetSeconds() == thisSeconds) {
 			--timeout;
-			thisSeconds = GetSeconds() + 1;
+			thisSeconds = (GetSeconds() + 2) % 32;
 			if (!serverMACSet)
 				GetServerAddress();
 			else if (ackBlock == -1)
@@ -553,10 +564,10 @@
 				// Be sure to send a NAK, which is done by
 				// ACKing the last block we got.
 				TFTP_ACK_Data(0, ackBlock, 512);
-				printf("\nNAK %u\r\n", ackBlock);
+				printf("\nNAK %u\n", ackBlock);
 			}
 		}
 	}
 	if (timeout == 0)
-		printf("TFTP TIMEOUT!\r\n");
+		printf("TFTP TIMEOUT!\n");
 }
Index: arm/at91/libat91/emac.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/emac.h,v
retrieving revision 1.3.2.1
diff -u -r1.3.2.1 emac.h
--- arm/at91/libat91/emac.h	17 Aug 2006 22:57:08 -0000	1.3.2.1
+++ arm/at91/libat91/emac.h	9 Nov 2006 20:32:36 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/emac.h,v 1.3.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/emac.h,v 1.5 2006/11/09 20:32:36 imp Exp $
  *****************************************************************************/
 
 
@@ -114,7 +114,7 @@
 /* MII registers definition */
 #define MII_STS_REG	0x01
 #define MII_STS_LINK_STAT	0x04
-#ifdef BOOT_KB9202
+#ifdef BOOT_KB920X
 #define MII_STS2_REG	0x11
 #define MII_STS2_LINK	0x400
 #define MII_STS2_100TX	0x4000
@@ -129,10 +129,7 @@
 
 extern unsigned char localMACAddr[6];
 extern unsigned localMAClow, localMAChigh;
-extern unsigned localMACSet, serverMACSet;
-extern receive_descriptor_t *p_rxBD;
-extern unsigned	lastSize;
-extern unsigned localIPSet, serverIPSet;
-extern unsigned short	serverPort, localPort;
+extern unsigned localMACSet;
+#define EMAC_Init()
 
 #endif /* _EMAC_H_ */
Index: arm/at91/libat91/emac_init.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/emac_init.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 emac_init.c
--- arm/at91/libat91/emac_init.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/emac_init.c	20 Dec 2006 18:26:37 -0000
@@ -24,7 +24,7 @@
  * This software is derived from software provide by Kwikbyte who specifically
  * disclaimed copyright on the code.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/emac_init.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/emac_init.c,v 1.4 2006/12/20 18:26:37 imp Exp $
  */
 
 /******************************************************************************
@@ -56,13 +56,9 @@
 
 /* ****************************** GLOBALS *************************************/
 
-unsigned	lastSize;
-unsigned localMACSet, serverMACSet;
+unsigned localMACSet;
 unsigned char localMACAddr[6];
 unsigned localMAClow, localMAChigh;
-unsigned localIPSet, serverIPSet;
-unsigned short	serverPort, localPort;
-receive_descriptor_t *p_rxBD;
 
 /* ********************** PRIVATE FUNCTIONS/DATA ******************************/
 
@@ -82,7 +78,7 @@
 	/* enable the peripheral clock before using EMAC */
 	pPMC->PMC_PCER = ((unsigned) 1 << AT91C_ID_EMAC);
 
-	p_memcpy(localMACAddr, mac, 6);
+	memcpy(localMACAddr, mac, 6);
 	localMAClow = (mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5];
 	localMAChigh = (mac[0] << 8) | mac[1];
 	localMACSet = 1;
@@ -98,7 +94,7 @@
 	  AT91C_PA8_ETXEN | AT91C_PA16_EMDIO | AT91C_PA9_ETX0 |
 	  AT91C_PA10_ETX1 | AT91C_PA11_ECRS_ECRSDV | AT91C_PA15_EMDC |
 	  AT91C_PA7_ETXCK_EREFCK;
-#ifdef BOOT_KB9202	/* Really !RMII */
+#if defined(BOOT_KB920X) | defined(BOOT_BWCT)	/* Really !RMII */
 	AT91C_BASE_PIOB->PIO_BSR =
 	  AT91C_PB12_ETX2 | AT91C_PB13_ETX3 | AT91C_PB14_ETXER |
 	  AT91C_PB15_ERX2 | AT91C_PB16_ERX3 | AT91C_PB17_ERXDV |
@@ -119,21 +115,3 @@
 	pEmac->EMAC_SA1L = localMAClow;
 	pEmac->EMAC_SA1H = localMAChigh;
 }
-
-/*
- * .KB_C_FN_DEFINITION_START
- * void EMAC_Init(void)
- *  This global function initializes variables used in tftp transfers.
- * .KB_C_FN_DEFINITION_END
- */
-void
-EMAC_Init(void)
-{
-	p_rxBD = (receive_descriptor_t*)RX_BUFFER_START;
-	localMACSet = 0;
-	serverMACSet = 0;
-	localIPSet = 0;
-	serverIPSet = 0;
-	localPort = SWAP16(0x8002);
-	lastSize = 0;
-}
Index: arm/at91/libat91/getc.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/getc.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 getc.c
--- arm/at91/libat91/getc.c	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/getc.c	28 Mar 2007 22:40:37 -0000
@@ -31,7 +31,7 @@
  * owners.  This software is not copyrighted and is intended for reference
  * only.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/getc.c,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/getc.c,v 1.3 2007/03/28 22:40:37 imp Exp $
  */
 
 #include "at91rm9200.h"
@@ -50,13 +50,15 @@
 	AT91PS_USART pUSART = (AT91PS_USART)AT91C_BASE_DBGU;
 	unsigned	thisSecond;
 
+	// Clamp to 20s
+	if (seconds > 20)
+	    seconds = 20;
 	thisSecond = GetSeconds();
 	seconds = thisSecond + seconds;
-
 	do {
 		if ((pUSART->US_CSR & AT91C_US_RXRDY))
 			return (pUSART->US_RHR & 0xFF);
 		thisSecond = GetSeconds();
-	} while (thisSecond < seconds);
+	} while (thisSecond != seconds);
 	return (-1);
 }
Index: arm/at91/libat91/lib.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/lib.h,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 lib.h
--- arm/at91/libat91/lib.h	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/lib.h	20 Dec 2006 18:19:52 -0000
@@ -21,7 +21,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/lib.h,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/lib.h,v 1.4 2006/12/20 18:19:52 imp Exp $
  */
 
 #ifndef ARM_BOOT_LIB_H
@@ -29,11 +29,12 @@
 
 int getc(int);
 void putchar(int);
+void xputchar(int);
 void printf(const char *fmt,...);
 
 /* The following function write eeprom at ee_addr using data 	*/
 /*  from data_add for size bytes.				*/
-void ReadEEPROM(unsigned eeoff, char *data_addr, unsigned size);
+int ReadEEPROM(unsigned eeoff, char *data_addr, unsigned size);
 void WriteEEPROM(unsigned eeoff, char *data_addr, unsigned size);
 void InitEEPROM(void);
 
@@ -56,9 +57,9 @@
 
 void p_memset(char *buffer, char value, int size);
 int p_strlen(const char *buffer);
-char *p_strcpy(char *to, const char *from);
-void p_memcpy(char *to, const char *from, unsigned size);
+char *strcpy(char *to, const char *from);
+void memcpy(void *to, const void *from, unsigned size);
 int p_memcmp(const char *to, const char *from, unsigned size);
-int p_strcmp(const char *to, const char *from);
+int strcmp(const char *to, const char *from);
 
 #endif
Index: arm/at91/libat91/lib_AT91RM9200.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/lib_AT91RM9200.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 lib_AT91RM9200.h
--- arm/at91/libat91/lib_AT91RM9200.h	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/lib_AT91RM9200.h	20 Oct 2006 09:12:05 -0000
@@ -24,7 +24,7 @@
  * This software is derived from software provide by Kwikbyte who specifically
  * disclaimed copyright on the code.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/lib_AT91RM9200.h,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/lib_AT91RM9200.h,v 1.2 2006/10/20 09:12:05 imp Exp $
  */
 
 #ifndef __LIBAT91RM9200_H
@@ -38,10 +38,10 @@
 //*----------------------------------------------------------------------------
 static inline void
 AT91F_PMC_EnablePeriphClock (
-	AT91PS_PMC pPMC, // \arg pointer to PMC controller
-	unsigned int periphIds)  // \arg IDs of peripherals to enable
+       AT91PS_PMC pPMC, // \arg pointer to PMC controller
+       unsigned int periphIds)  // \arg IDs of peripherals to enable
 {
-	pPMC->PMC_PCER = periphIds;
+       pPMC->PMC_PCER = periphIds;
 }
 
 /* *****************************************************************************
@@ -58,20 +58,16 @@
 	unsigned int periphBEnable)  // \arg PERIPH B to enable
 
 {
-	pPio->PIO_ASR = periphAEnable;
-	pPio->PIO_BSR = periphBEnable;
+	if (periphAEnable)
+		pPio->PIO_ASR = periphAEnable;
+	if (periphBEnable)
+		pPio->PIO_BSR = periphBEnable;
 	pPio->PIO_PDR = (periphAEnable | periphBEnable); // Set in Periph mode
 }
 
 /* *****************************************************************************
                 SOFTWARE API FOR MCI
    ***************************************************************************** */
-//* Classic MCI Mode Register Configuration with PDC mode enabled and MCK = MCI Clock
-#define AT91C_MCI_MR_PDCMODE	(AT91C_MCI_CLKDIV |\
-                                AT91C_MCI_PWSDIV |\
-                                (AT91C_MCI_PWSDIV<<1) |\
-                                AT91C_MCI_PDCMODE) 
-
 //* Classic MCI Data Timeout Register Configuration with 1048576 MCK cycles between 2 data transfer
 #define AT91C_MCI_DTOR_1MEGA_CYCLES	(AT91C_MCI_DTOCYC | AT91C_MCI_DTOMUL)
 
@@ -117,242 +113,6 @@
 }
 
 //*----------------------------------------------------------------------------
-//* \fn    AT91F_MCI_EnableIt
-//* \brief Enable MCI IT
-//*----------------------------------------------------------------------------
-static inline
-void AT91F_MCI_EnableIt(
-        AT91PS_MCI pMCI, // \arg pointer to a MCI controller
-        unsigned int flag)   // \arg IT to be enabled
-{
-    //* Write to the IER register
-    pMCI->MCI_IER = flag;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_MCI_DisableIt
-//* \brief Disable MCI IT
-//*----------------------------------------------------------------------------
-static inline
-void AT91F_MCI_DisableIt(
-        AT91PS_MCI pMCI, // \arg pointer to a MCI controller
-        unsigned int flag)   // \arg IT to be disabled
-{
-    //* Write to the IDR register
-    pMCI->MCI_IDR = flag;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_MCI_Enable_Interface
-//* \brief Enable the MCI Interface
-//*----------------------------------------------------------------------------
-static inline
-void AT91F_MCI_Enable_Interface(
-        AT91PS_MCI pMCI)     // \arg pointer to a MCI controller
-{
-    //* Enable the MCI
-    pMCI->MCI_CR = AT91C_MCI_MCIEN;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_MCI_Disable_Interface
-//* \brief Disable the MCI Interface
-//*----------------------------------------------------------------------------
-static inline
-void AT91F_MCI_Disable_Interface(
-        AT91PS_MCI pMCI)     // \arg pointer to a MCI controller
-{
-    //* Disable the MCI
-    pMCI->MCI_CR = AT91C_MCI_MCIDIS;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_MCI_Cfg_ModeRegister
-//* \brief Configure the MCI Mode Register
-//*----------------------------------------------------------------------------
-static inline
-void AT91F_MCI_Cfg_ModeRegister(
-        AT91PS_MCI pMCI, // \arg pointer to a MCI controller
-        unsigned int mode_register)   // \arg value to set in the mode register
-{
-    //* Configure the MCI MR
-    pMCI->MCI_MR = mode_register;
-}
-
-/* *****************************************************************************
-                SOFTWARE API FOR AIC
-   ***************************************************************************** */
-#define AT91C_AIC_BRANCH_OPCODE ((void (*) ()) 0xE51FFF20) // ldr, pc, [pc, #-&F20]
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_ConfigureIt
-//* \brief Interrupt Handler Initialization
-//*----------------------------------------------------------------------------
-static inline unsigned int
-AT91F_AIC_ConfigureIt(
-	AT91PS_AIC pAic,  // \arg pointer to the AIC registers
-	unsigned int irq_id,     // \arg interrupt number to initialize
-	unsigned int priority,   // \arg priority to give to the interrupt
-	unsigned int src_type,   // \arg activation and sense of activation
-	void (*newHandler) (void) ) // \arg address of the interrupt handler
-{
-	unsigned int oldHandler;
-    unsigned int mask ;
-
-    oldHandler = pAic->AIC_SVR[irq_id];
-
-    mask = 0x1 << irq_id ;
-    //* Disable the interrupt on the interrupt controller
-    pAic->AIC_IDCR = mask ;
-    //* Save the interrupt handler routine pointer and the interrupt priority
-    pAic->AIC_SVR[irq_id] = (unsigned int) newHandler ;
-    //* Store the Source Mode Register
-    pAic->AIC_SMR[irq_id] = src_type | priority  ;
-    //* Clear the interrupt on the interrupt controller
-    pAic->AIC_ICCR = mask ;
-
-	return oldHandler;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_EnableIt
-//* \brief Enable corresponding IT number
-//*----------------------------------------------------------------------------
-static inline
-void AT91F_AIC_EnableIt(
-	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
-	unsigned int irq_id ) // \arg interrupt number to initialize
-{
-    //* Enable the interrupt on the interrupt controller
-    pAic->AIC_IECR = 0x1 << irq_id ;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_DisableIt
-//* \brief Disable corresponding IT number
-//*----------------------------------------------------------------------------
-static inline void
-AT91F_AIC_DisableIt(
-	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
-	unsigned int irq_id ) // \arg interrupt number to initialize
-{
-    unsigned int mask = 0x1 << irq_id;
-    //* Disable the interrupt on the interrupt controller
-    pAic->AIC_IDCR = mask ;
-    //* Clear the interrupt on the Interrupt Controller ( if one is pending )
-    pAic->AIC_ICCR = mask ;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_ClearIt
-//* \brief Clear corresponding IT number
-//*----------------------------------------------------------------------------
-static inline void
-AT91F_AIC_ClearIt(
-	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
-	unsigned int irq_id) // \arg interrupt number to initialize
-{
-    //* Clear the interrupt on the Interrupt Controller ( if one is pending )
-    pAic->AIC_ICCR = (0x1 << irq_id);
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_AcknowledgeIt
-//* \brief Acknowledge corresponding IT number
-//*----------------------------------------------------------------------------
-static inline void
-AT91F_AIC_AcknowledgeIt(
-	AT91PS_AIC pAic)     // \arg pointer to the AIC registers
-{
-    pAic->AIC_EOICR = pAic->AIC_EOICR;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_SetExceptionVector
-//* \brief Configure vector handler
-//*----------------------------------------------------------------------------
-static inline unsigned int
-AT91F_AIC_SetExceptionVector(
-	unsigned int *pVector, // \arg pointer to the AIC registers
-	void (*Handler)(void) )   // \arg Interrupt Handler
-{
-	unsigned int oldVector = *pVector;
-
-	if ((unsigned int) Handler == (unsigned int) AT91C_AIC_BRANCH_OPCODE)
-		*pVector = (unsigned int) AT91C_AIC_BRANCH_OPCODE;
-	else
-		*pVector = (((((unsigned int) Handler) - ((unsigned int) pVector) - 0x8) >> 2) & 0x00FFFFFF) | 0xEA000000;
-
-	return oldVector;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_Trig
-//* \brief Trig an IT
-//*----------------------------------------------------------------------------
-static inline void
-AT91F_AIC_Trig(
-	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
-	unsigned int irq_id) // \arg interrupt number
-{
-	pAic->AIC_ISCR = (0x1 << irq_id) ;
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_IsActive
-//* \brief Test if an IT is active
-//*----------------------------------------------------------------------------
-static inline unsigned int
-AT91F_AIC_IsActive(
-	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
-	unsigned int irq_id) // \arg Interrupt Number
-{
-	return (pAic->AIC_ISR & (0x1 << irq_id));
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_IsPending
-//* \brief Test if an IT is pending
-//*----------------------------------------------------------------------------
-static inline unsigned int
-AT91F_AIC_IsPending(
-	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
-	unsigned int irq_id) // \arg Interrupt Number
-{
-	return (pAic->AIC_IPR & (0x1 << irq_id));
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_AIC_Open
-//* \brief Set exception vectors and AIC registers to default values
-//*----------------------------------------------------------------------------
-static inline void
-AT91F_AIC_Open(
-	AT91PS_AIC pAic,        // \arg pointer to the AIC registers
-	void (*IrqHandler)(void),  // \arg Default IRQ vector exception
-	void (*FiqHandler)(void),  // \arg Default FIQ vector exception
-	void (*DefaultHandler)(void), // \arg Default Handler set in ISR
-	void (*SpuriousHandler)(void), // \arg Default Spurious Handler
-	unsigned int protectMode)   // \arg Debug Control Register
-{
-	int i;
-
-	// Disable all interrupts and set IVR to the default handler
-	for (i = 0; i < 32; ++i) {
-		AT91F_AIC_DisableIt(pAic, i);
-		AT91F_AIC_ConfigureIt(pAic, i, AT91C_AIC_PRIOR_LOWEST, AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE, DefaultHandler);
-	}
-
-	// Set the IRQ exception vector
-	AT91F_AIC_SetExceptionVector((unsigned int *) 0x18, IrqHandler);
-	// Set the Fast Interrupt exception vector
-	AT91F_AIC_SetExceptionVector((unsigned int *) 0x1C, FiqHandler);
-
-	pAic->AIC_SPU = (unsigned int) SpuriousHandler;
-	pAic->AIC_DCR = protectMode;
-}
-
-//*----------------------------------------------------------------------------
 //* \fn    AT91F_MCI_CfgPMC
 //* \brief Enable Peripheral clock in PMC for  MCI
 //*----------------------------------------------------------------------------
@@ -492,50 +252,6 @@
 }
 
 //*----------------------------------------------------------------------------
-//* \fn    AT91F_PDC_IsTxEmpty
-//* \brief Test if the current transfer descriptor has been sent
-//*----------------------------------------------------------------------------
-static inline int
-AT91F_PDC_IsTxEmpty( // \return return 1 if transfer is complete
-	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
-{
-	return !(pPDC->PDC_TCR);
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_PDC_IsNextTxEmpty
-//* \brief Test if the next transfer descriptor has been moved to the current td
-//*----------------------------------------------------------------------------
-static inline int
-AT91F_PDC_IsNextTxEmpty( // \return return 1 if transfer is complete
-	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
-{
-	return !(pPDC->PDC_TNCR);
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_PDC_IsRxEmpty
-//* \brief Test if the current transfer descriptor has been filled
-//*----------------------------------------------------------------------------
-static inline int
-AT91F_PDC_IsRxEmpty( // \return return 1 if transfer is complete
-	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
-{
-	return !(pPDC->PDC_RCR);
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_PDC_IsNextRxEmpty
-//* \brief Test if the next transfer descriptor has been moved to the current td
-//*----------------------------------------------------------------------------
-static inline int
-AT91F_PDC_IsNextRxEmpty( // \return return 1 if transfer is complete
-	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
-{
-	return !(pPDC->PDC_RNCR);
-}
-
-//*----------------------------------------------------------------------------
 //* \fn    AT91F_PDC_Open
 //* \brief Open PDC: disable TX and RX reset transfer descriptors, re-enable RX and TX
 //*----------------------------------------------------------------------------
@@ -558,82 +274,4 @@
 	AT91F_PDC_EnableTx(pPDC);
 }
 
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_PDC_Close
-//* \brief Close PDC: disable TX and RX reset transfer descriptors
-//*----------------------------------------------------------------------------
-static inline void
-AT91F_PDC_Close(
-	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
-{
-    //* Disable the RX and TX PDC transfer requests
-	AT91F_PDC_DisableRx(pPDC);
-	AT91F_PDC_DisableTx(pPDC);
-
-	//* Reset all Counter register Next buffer first
-	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
-	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
-	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
-	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
-
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_PDC_SendFrame
-//* \brief Close PDC: disable TX and RX reset transfer descriptors
-//*----------------------------------------------------------------------------
-static inline unsigned int
-AT91F_PDC_SendFrame(
-	AT91PS_PDC pPDC,
-	char *pBuffer,
-	unsigned int szBuffer,
-	char *pNextBuffer,
-	unsigned int szNextBuffer )
-{
-	if (AT91F_PDC_IsTxEmpty(pPDC)) {
-		//* Buffer and next buffer can be initialized
-		AT91F_PDC_SetTx(pPDC, pBuffer, szBuffer);
-		AT91F_PDC_SetNextTx(pPDC, pNextBuffer, szNextBuffer);
-		return 2;
-	}
-	else if (AT91F_PDC_IsNextTxEmpty(pPDC)) {
-		//* Only one buffer can be initialized
-		AT91F_PDC_SetNextTx(pPDC, pBuffer, szBuffer);
-		return 1;
-	}
-	else {
-		//* All buffer are in use...
-		return 0;
-	}
-}
-
-//*----------------------------------------------------------------------------
-//* \fn    AT91F_PDC_ReceiveFrame
-//* \brief Close PDC: disable TX and RX reset transfer descriptors
-//*----------------------------------------------------------------------------
-static inline unsigned int
-AT91F_PDC_ReceiveFrame(
-	AT91PS_PDC pPDC,
-	char *pBuffer,
-	unsigned int szBuffer,
-	char *pNextBuffer,
-	unsigned int szNextBuffer )
-{
-	if (AT91F_PDC_IsRxEmpty(pPDC)) {
-		//* Buffer and next buffer can be initialized
-		AT91F_PDC_SetRx(pPDC, pBuffer, szBuffer);
-		AT91F_PDC_SetNextRx(pPDC, pNextBuffer, szNextBuffer);
-		return 2;
-	}
-	else if (AT91F_PDC_IsNextRxEmpty(pPDC)) {
-		//* Only one buffer can be initialized
-		AT91F_PDC_SetNextRx(pPDC, pBuffer, szBuffer);
-		return 1;
-	}
-	else {
-		//* All buffer are in use...
-		return 0;
-	}
-}
-
 #endif
Index: arm/at91/libat91/mci_device.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/mci_device.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 mci_device.h
--- arm/at91/libat91/mci_device.h	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/mci_device.h	9 Nov 2006 20:32:36 -0000
@@ -24,7 +24,7 @@
  * This software is derived from software provide by Kwikbyte who specifically
  * disclaimed copyright on the code.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/mci_device.h,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/mci_device.h,v 1.3 2006/11/09 20:32:36 imp Exp $
  */
 
 //*---------------------------------------------------------------------------
@@ -46,10 +46,11 @@
 #ifndef __MCI_Device_h
 #define __MCI_Device_h
 
+#include <sys/types.h>
 
 typedef unsigned int AT91S_MCIDeviceStatus;
 
-/////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
 
 #define AT91C_CARD_REMOVED			0
 #define AT91C_MMC_CARD_INSERTED		1
@@ -76,191 +77,215 @@
 /* TimeOut */
 #define AT91C_TIMEOUT_CMDRDY		30
 
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-// MMC & SDCard Structures 
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-
-/*-----------------------------------------------*/
-/* SDCard Device Descriptor Structure Definition */
-/*-----------------------------------------------*/
-typedef struct	_AT91S_MciDeviceDesc
-{
-    volatile unsigned char	state;
-	unsigned char			SDCard_bus_width;
 
-} AT91S_MciDeviceDesc, *AT91PS_MciDeviceDesc;
 
-/*---------------------------------------------*/
-/* MMC & SDCard Structure Device Features	   */
-/*---------------------------------------------*/
-typedef struct	_AT91S_MciDeviceFeatures
-{
-	unsigned char	Card_Inserted;				// (0=AT91C_CARD_REMOVED) (1=AT91C_MMC_CARD_INSERTED) (2=AT91C_SD_CARD_INSERTED)
-	unsigned int 	Relative_Card_Address;		// RCA
-	unsigned int	READ_BL_LEN;
-	unsigned int	WRITE_BL_LEN;
-	unsigned int 	Max_Read_DataBlock_Length;	// 2^(READ_BL_LEN) in CSD 
-	unsigned int 	Max_Write_DataBlock_Length;	// 2^(WRITE_BL_LEN) in CSD
-	unsigned char	Read_Partial;				// READ_BL_PARTIAL
-	unsigned char	Write_Partial;				// WRITE_BL_PARTIAL
-	unsigned char	Erase_Block_Enable;			// ERASE_BLK_EN
-	unsigned char	Read_Block_Misalignment;	// READ_BLK_MISALIGN
-	unsigned char	Write_Block_Misalignment;	// WRITE_BLK_MISALIGN
-	unsigned char	Sector_Size;				// SECTOR_SIZE
-	unsigned int	Memory_Capacity;			// Size in bits of the device
-	
-}	AT91S_MciDeviceFeatures, *AT91PS_MciDeviceFeatures ;
+///////////////////////////////////////////////////////////////////////////////
+// MMC & SDCard Structures 
+///////////////////////////////////////////////////////////////////////////////
 
 /*---------------------------------------------*/
 /* MCI Device Structure Definition 			   */
 /*---------------------------------------------*/
 typedef struct _AT91S_MciDevice
 {
-	AT91PS_MciDeviceDesc		 	pMCI_DeviceDesc;	// MCI device descriptor
-	AT91PS_MciDeviceFeatures		pMCI_DeviceFeatures;// Pointer on a MCI device features array  
-}AT91S_MciDevice, *AT91PS_MciDevice;
+	volatile unsigned char	state;
+	unsigned char	SDCard_bus_width;
+	unsigned int 	RCA;		// RCA
+	unsigned int	READ_BL_LEN;
+#ifdef REPORT_SIZE
+	unsigned int	Memory_Capacity;
+#endif
+} AT91S_MciDevice;
+
+#include <dev/mmc/mmcreg.h>
+
+///////////////////////////////////////////////////////////////////////////////
+// Functions returnals
+///////////////////////////////////////////////////////////////////////////////
+#define AT91C_CMD_SEND_OK		0		// Command ok
+#define AT91C_CMD_SEND_ERROR		-1		// Command failed
+#define AT91C_INIT_OK			2		// Init Successfull
+#define AT91C_INIT_ERROR		3		// Init Failed
+#define AT91C_READ_OK			4		// Read Successfull
+#define AT91C_READ_ERROR		5		// Read Failed
+#define AT91C_WRITE_OK			6		// Write Successfull
+#define AT91C_WRITE_ERROR		7		// Write Failed
+#define AT91C_ERASE_OK			8		// Erase Successfull
+#define AT91C_ERASE_ERROR		9		// Erase Failed
+#define AT91C_CARD_SELECTED_OK		10		// Card Selection Successfull
+#define AT91C_CARD_SELECTED_ERROR	11		// Card Selection Failed
+
+#define AT91C_MCI_SR_ERROR (AT91C_MCI_UNRE | AT91C_MCI_OVRE | AT91C_MCI_DTOE | \
+	AT91C_MCI_DCRCE | AT91C_MCI_RTOE | AT91C_MCI_RENDE | AT91C_MCI_RCRCE | \
+	AT91C_MCI_RDIRE | AT91C_MCI_RINDE)
+
+#define	MMC_CMDNB       (0x1Fu <<  0)		// Command Number
+#define	MMC_RSPTYP      (0x3u <<  6)		// Response Type
+#define	    MMC_RSPTYP_NO      (0x0u <<  6)	// No response
+#define	    MMC_RSPTYP_48      (0x1u <<  6)	// 48-bit response
+#define	    MMC_RSPTYP_136     (0x2u <<  6)	// 136-bit response
+#define	MMC_SPCMD       (0x7u <<  8)		// Special CMD
+#define	    MMC_SPCMD_NONE     (0x0u <<  8)	// Not a special CMD
+#define	    MMC_SPCMD_INIT     (0x1u <<  8)	// Initialization CMD
+#define	    MMC_SPCMD_SYNC     (0x2u <<  8)	// Synchronized CMD
+#define	    MMC_SPCMD_IT_CMD   (0x4u <<  8)	// Interrupt command
+#define	    MMC_SPCMD_IT_REP   (0x5u <<  8)	// Interrupt response
+#define	MMC_OPDCMD      (0x1u << 11)		// Open Drain Command
+#define	MMC_MAXLAT      (0x1u << 12)		// Maximum Latency for Command to respond
+#define	MMC_TRCMD       (0x3u << 16)		// Transfer CMD
+#define	    MMC_TRCMD_NO       (0x0u << 16)	// No transfer
+#define	    MMC_TRCMD_START    (0x1u << 16)	// Start transfer
+#define	    MMC_TRCMD_STOP     (0x2u << 16)	// Stop transfer
+#define	MMC_TRDIR       (0x1u << 18)		// Transfer Direction
+#define	MMC_TRTYP       (0x3u << 19)		// Transfer Type
+#define	    MMC_TRTYP_BLOCK    (0x0u << 19)	// Block Transfer type
+#define	    MMC_TRTYP_MULTIPLE (0x1u << 19)	// Multiple Block transfer type
+#define	    MMC_TRTYP_STREAM   (0x2u << 19)	// Stream transfer type
 
-/////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
 // MCI_CMD Register Value 
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-#define AT91C_POWER_ON_INIT						(0	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_INIT | AT91C_MCI_OPDCMD)
+///////////////////////////////////////////////////////////////////////////////
+#define POWER_ON_INIT	\
+    (0 | MMC_TRCMD_NO | MMC_SPCMD_INIT | MMC_OPDCMD)
 
 /////////////////////////////////////////////////////////////////	
 // Class 0 & 1 commands: Basic commands and Read Stream commands
 /////////////////////////////////////////////////////////////////
 
-#define AT91C_GO_IDLE_STATE_CMD					(0 	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE )
-#define AT91C_MMC_GO_IDLE_STATE_CMD				(0 	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE  | AT91C_MCI_OPDCMD)
-#define AT91C_MMC_SEND_OP_COND_CMD				(1	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48 | AT91C_MCI_OPDCMD)
-#define AT91C_ALL_SEND_CID_CMD					(2	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_136 )
-#define AT91C_MMC_ALL_SEND_CID_CMD				(2	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_136 | AT91C_MCI_OPDCMD)
-#define AT91C_SET_RELATIVE_ADDR_CMD				(3	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48		| AT91C_MCI_MAXLAT )
-#define AT91C_MMC_SET_RELATIVE_ADDR_CMD			(3	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48		| AT91C_MCI_MAXLAT | AT91C_MCI_OPDCMD)
-
-#define AT91C_SET_DSR_CMD						(4	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_NO		| AT91C_MCI_MAXLAT )	// no tested
-
-#define AT91C_SEL_DESEL_CARD_CMD				(7	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48  		| AT91C_MCI_MAXLAT )
-#define AT91C_SEND_CSD_CMD						(9	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_136 		| AT91C_MCI_MAXLAT )
-#define AT91C_SEND_CID_CMD						(10	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_136 		| AT91C_MCI_MAXLAT )
-#define AT91C_MMC_READ_DAT_UNTIL_STOP_CMD		(11	| AT91C_MCI_TRTYP_STREAM| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRDIR	| AT91C_MCI_TRCMD_START | AT91C_MCI_MAXLAT )
-
-#define AT91C_STOP_TRANSMISSION_CMD				(12	| AT91C_MCI_TRCMD_STOP 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48 		| AT91C_MCI_MAXLAT )
-#define AT91C_STOP_TRANSMISSION_SYNC_CMD		(12	| AT91C_MCI_TRCMD_STOP 	| AT91C_MCI_SPCMD_SYNC	| AT91C_MCI_RSPTYP_48 		| AT91C_MCI_MAXLAT )
-#define AT91C_SEND_STATUS_CMD					(13	| AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48 		| AT91C_MCI_MAXLAT )
-#define AT91C_GO_INACTIVE_STATE_CMD				(15	| AT91C_MCI_RSPTYP_NO )
+#define GO_IDLE_STATE_CMD	\
+    (0 | MMC_TRCMD_NO | MMC_SPCMD_NONE )
+#define MMC_GO_IDLE_STATE_CMD \
+    (0 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_OPDCMD)
+#define MMC_SEND_OP_COND_CMD \
+    (1 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_48 | \
+     MMC_OPDCMD)
+
+#define ALL_SEND_CID_CMD \
+    (2 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_136)
+#define MMC_ALL_SEND_CID_CMD \
+    (2 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_136 | \
+    MMC_OPDCMD)
+
+#define SET_RELATIVE_ADDR_CMD \
+    (3 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_48 | \
+     MMC_MAXLAT)
+#define MMC_SET_RELATIVE_ADDR_CMD \
+    (3 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_48 | \
+     MMC_MAXLAT | MMC_OPDCMD)
+
+#define SET_DSR_CMD \
+    (4 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_NO | \
+     MMC_MAXLAT)	// no tested
+
+#define SEL_DESEL_CARD_CMD \
+    (7 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_48 | \
+     MMC_MAXLAT)
+#define SEND_CSD_CMD \
+    (9 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_136 | \
+     MMC_MAXLAT)
+#define SEND_CID_CMD \
+    (10 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_136 | \
+     MMC_MAXLAT)
+#define MMC_READ_DAT_UNTIL_STOP_CMD \
+    (11 | MMC_TRTYP_STREAM | MMC_SPCMD_NONE | \
+     MMC_RSPTYP_48 | MMC_TRDIR | MMC_TRCMD_START | \
+     MMC_MAXLAT)
+
+#define STOP_TRANSMISSION_CMD \
+    (12 | MMC_TRCMD_STOP | MMC_SPCMD_NONE | MMC_RSPTYP_48 | \
+     MMC_MAXLAT)
+#define STOP_TRANSMISSION_SYNC_CMD \
+    (12 | MMC_TRCMD_STOP | MMC_SPCMD_SYNC | MMC_RSPTYP_48 | \
+     MMC_MAXLAT)
+#define SEND_STATUS_CMD \
+    (13 | MMC_TRCMD_NO | MMC_SPCMD_NONE | MMC_RSPTYP_48 | \
+     MMC_MAXLAT)
+#define GO_INACTIVE_STATE_CMD \
+     (15 | MMC_RSPTYP_NO)
 
 //*------------------------------------------------
 //* Class 2 commands: Block oriented Read commands
 //*------------------------------------------------
 
-#define AT91C_SET_BLOCKLEN_CMD					(16 | AT91C_MCI_TRCMD_NO 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48		| AT91C_MCI_MAXLAT )
-#define AT91C_READ_SINGLE_BLOCK_CMD				(17 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48 	| AT91C_MCI_TRCMD_START	| AT91C_MCI_TRTYP_BLOCK	| AT91C_MCI_TRDIR	| AT91C_MCI_MAXLAT)
-#define AT91C_READ_MULTIPLE_BLOCK_CMD			(18 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48 	| AT91C_MCI_TRCMD_START	| AT91C_MCI_TRTYP_MULTIPLE	| AT91C_MCI_TRDIR	| AT91C_MCI_MAXLAT)
+#define SET_BLOCKLEN_CMD					(16 | MMC_TRCMD_NO 	| MMC_SPCMD_NONE	| MMC_RSPTYP_48		| MMC_MAXLAT )
+#define READ_SINGLE_BLOCK_CMD				(17 | MMC_SPCMD_NONE	| MMC_RSPTYP_48 	| MMC_TRCMD_START	| MMC_TRTYP_BLOCK	| MMC_TRDIR	| MMC_MAXLAT)
+#define READ_MULTIPLE_BLOCK_CMD			(18 | MMC_SPCMD_NONE	| MMC_RSPTYP_48 	| MMC_TRCMD_START	| MMC_TRTYP_MULTIPLE	| MMC_TRDIR	| MMC_MAXLAT)
 
 //*--------------------------------------------
 //* Class 3 commands: Sequential write commands
 //*--------------------------------------------
 
-#define AT91C_MMC_WRITE_DAT_UNTIL_STOP_CMD		(20 | AT91C_MCI_TRTYP_STREAM| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48 & ~(AT91C_MCI_TRDIR) | AT91C_MCI_TRCMD_START | AT91C_MCI_MAXLAT )	// MMC
+#define MMC_WRITE_DAT_UNTIL_STOP_CMD		(20 | MMC_TRTYP_STREAM| MMC_SPCMD_NONE	| MMC_RSPTYP_48 & ~(MMC_TRDIR) | MMC_TRCMD_START | MMC_MAXLAT )	// MMC
 
 //*------------------------------------------------
 //* Class 4 commands: Block oriented write commands
 //*------------------------------------------------
 	
-#define AT91C_WRITE_BLOCK_CMD					(24 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_START	| (AT91C_MCI_TRTYP_BLOCK 	&  ~(AT91C_MCI_TRDIR))	| AT91C_MCI_MAXLAT)
-#define AT91C_WRITE_MULTIPLE_BLOCK_CMD			(25 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_START	| (AT91C_MCI_TRTYP_MULTIPLE	&  ~(AT91C_MCI_TRDIR)) 	| AT91C_MCI_MAXLAT)
-#define AT91C_PROGRAM_CSD_CMD					(27 | AT91C_MCI_RSPTYP_48 )
+#define WRITE_BLOCK_CMD					(24 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_START	| (MMC_TRTYP_BLOCK 	&  ~(MMC_TRDIR))	| MMC_MAXLAT)
+#define WRITE_MULTIPLE_BLOCK_CMD			(25 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_START	| (MMC_TRTYP_MULTIPLE	&  ~(MMC_TRDIR)) 	| MMC_MAXLAT)
+#define PROGRAM_CSD_CMD					(27 | MMC_RSPTYP_48 )
 
 
 //*----------------------------------------
 //* Class 6 commands: Group Write protect
 //*----------------------------------------
 
-#define AT91C_SET_WRITE_PROT_CMD				(28	| AT91C_MCI_RSPTYP_48 )
-#define AT91C_CLR_WRITE_PROT_CMD				(29	| AT91C_MCI_RSPTYP_48 )
-#define AT91C_SEND_WRITE_PROT_CMD				(30	| AT91C_MCI_RSPTYP_48 )
+#define SET_WRITE_PROT_CMD				(28	| MMC_RSPTYP_48 )
+#define CLR_WRITE_PROT_CMD				(29	| MMC_RSPTYP_48 )
+#define SEND_WRITE_PROT_CMD				(30	| MMC_RSPTYP_48 )
 
 
 //*----------------------------------------
 //* Class 5 commands: Erase commands
 //*----------------------------------------
 
-#define AT91C_TAG_SECTOR_START_CMD				(32 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-#define AT91C_TAG_SECTOR_END_CMD  				(33 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-#define AT91C_MMC_UNTAG_SECTOR_CMD				(34 | AT91C_MCI_RSPTYP_48 )
-#define AT91C_MMC_TAG_ERASE_GROUP_START_CMD		(35 | AT91C_MCI_RSPTYP_48 )
-#define AT91C_MMC_TAG_ERASE_GROUP_END_CMD		(36 | AT91C_MCI_RSPTYP_48 )
-#define AT91C_MMC_UNTAG_ERASE_GROUP_CMD			(37 | AT91C_MCI_RSPTYP_48 )
-#define AT91C_ERASE_CMD							(38 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT )
+#define TAG_SECTOR_START_CMD				(32 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+#define TAG_SECTOR_END_CMD  				(33 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+#define MMC_UNTAG_SECTOR_CMD				(34 | MMC_RSPTYP_48 )
+#define MMC_TAG_ERASE_GROUP_START_CMD		(35 | MMC_RSPTYP_48 )
+#define MMC_TAG_ERASE_GROUP_END_CMD		(36 | MMC_RSPTYP_48 )
+#define MMC_UNTAG_ERASE_GROUP_CMD			(37 | MMC_RSPTYP_48 )
+#define ERASE_CMD							(38 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT )
 
 //*----------------------------------------
 //* Class 7 commands: Lock commands
 //*----------------------------------------
 
-#define AT91C_LOCK_UNLOCK						(42 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)	// no tested
+#define LOCK_UNLOCK						(42 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)	// no tested
 
 //*-----------------------------------------------
 // Class 8 commands: Application specific commands
 //*-----------------------------------------------
 
-#define AT91C_APP_CMD							(55 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO | AT91C_MCI_MAXLAT)
-#define AT91C_GEN_CMD							(56 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO | AT91C_MCI_MAXLAT)	// no tested
+#define APP_CMD							(55 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO | MMC_MAXLAT)
+#define GEN_CMD							(56 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO | MMC_MAXLAT)	// no tested
 
-#define AT91C_SDCARD_SET_BUS_WIDTH_CMD			(6 	| AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-#define AT91C_SDCARD_STATUS_CMD					(13 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-#define AT91C_SDCARD_SEND_NUM_WR_BLOCKS_CMD		(22 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-#define AT91C_SDCARD_SET_WR_BLK_ERASE_COUNT_CMD	(23 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-#define AT91C_SDCARD_APP_OP_COND_CMD			(41 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO )
-#define AT91C_SDCARD_SET_CLR_CARD_DETECT_CMD	(42 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-#define AT91C_SDCARD_SEND_SCR_CMD				(51 | AT91C_MCI_SPCMD_NONE	| AT91C_MCI_RSPTYP_48	| AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
-
-#define AT91C_SDCARD_APP_ALL_CMD				(AT91C_SDCARD_SET_BUS_WIDTH_CMD +\
-												AT91C_SDCARD_STATUS_CMD +\
-												AT91C_SDCARD_SEND_NUM_WR_BLOCKS_CMD +\
-												AT91C_SDCARD_SET_WR_BLK_ERASE_COUNT_CMD +\
-												AT91C_SDCARD_APP_OP_COND_CMD +\
-												AT91C_SDCARD_SET_CLR_CARD_DETECT_CMD +\
-												AT91C_SDCARD_SEND_SCR_CMD)
+#define SDCARD_SET_BUS_WIDTH_CMD			(6 	| MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+#define SDCARD_STATUS_CMD					(13 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+#define SDCARD_SEND_NUM_WR_BLOCKS_CMD		(22 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+#define SDCARD_SET_WR_BLK_ERASE_COUNT_CMD	(23 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+#define SDCARD_APP_OP_COND_CMD			(41 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO )
+#define SDCARD_SET_CLR_CARD_DETECT_CMD	(42 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+#define SDCARD_SEND_SCR_CMD				(51 | MMC_SPCMD_NONE	| MMC_RSPTYP_48	| MMC_TRCMD_NO	| MMC_MAXLAT)
+
+#define SDCARD_APP_ALL_CMD				(SDCARD_SET_BUS_WIDTH_CMD +\
+												SDCARD_STATUS_CMD +\
+												SDCARD_SEND_NUM_WR_BLOCKS_CMD +\
+												SDCARD_SET_WR_BLK_ERASE_COUNT_CMD +\
+												SDCARD_APP_OP_COND_CMD +\
+												SDCARD_SET_CLR_CARD_DETECT_CMD +\
+												SDCARD_SEND_SCR_CMD)
 
 //*----------------------------------------
 //* Class 9 commands: IO Mode commands
 //*----------------------------------------
 
-#define AT91C_MMC_FAST_IO_CMD					(39 | AT91C_MCI_SPCMD_NONE | AT91C_MCI_RSPTYP_48 | AT91C_MCI_MAXLAT)
-#define AT91C_MMC_GO_IRQ_STATE_CMD				(40 | AT91C_MCI_SPCMD_NONE | AT91C_MCI_RSPTYP_48 | AT91C_MCI_TRCMD_NO	| AT91C_MCI_MAXLAT)
+#define MMC_FAST_IO_CMD					(39 | MMC_SPCMD_NONE | MMC_RSPTYP_48 | MMC_MAXLAT)
+#define MMC_GO_IRQ_STATE_CMD				(40 | MMC_SPCMD_NONE | MMC_RSPTYP_48 | MMC_TRCMD_NO	| MMC_MAXLAT)
 
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-// Functions returnals
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-#define AT91C_CMD_SEND_OK					0		// Command ok
-#define AT91C_CMD_SEND_ERROR				-1		// Command failed
-#define AT91C_INIT_OK						2		// Init Successfull
-#define AT91C_INIT_ERROR					3		// Init Failed
-#define AT91C_READ_OK						4		// Read Successfull
-#define AT91C_READ_ERROR					5		// Read Failed
-#define AT91C_WRITE_OK						6		// Write Successfull
-#define AT91C_WRITE_ERROR					7		// Write Failed
-#define AT91C_ERASE_OK						8		// Erase Successfull
-#define AT91C_ERASE_ERROR					9		// Erase Failed
-#define AT91C_CARD_SELECTED_OK				10		// Card Selection Successfull
-#define AT91C_CARD_SELECTED_ERROR			11		// Card Selection Failed
-
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-// MCI_SR Errors
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-#define 	AT91C_MCI_SR_ERROR		(AT91C_MCI_UNRE |\
-									 AT91C_MCI_OVRE |\
-									 AT91C_MCI_DTOE |\
-									 AT91C_MCI_DCRCE |\
-									 AT91C_MCI_RTOE |\
-									 AT91C_MCI_RENDE |\
-									 AT91C_MCI_RCRCE |\
-									 AT91C_MCI_RDIRE |\
-									 AT91C_MCI_RINDE)
-
-////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
 // OCR Register
-////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
 #define AT91C_VDD_16_17					(1 << 4)
 #define AT91C_VDD_17_18					(1 << 5)
 #define AT91C_VDD_18_19					(1 << 6)
@@ -283,16 +308,12 @@
 #define AT91C_VDD_35_36					(1 << 23)
 #define AT91C_CARD_POWER_UP_BUSY		(1 << 31)
 
-#define AT91C_MMC_HOST_VOLTAGE_RANGE	(AT91C_VDD_27_28 +\
-										AT91C_VDD_28_29 +\
-										AT91C_VDD_29_30 +\
-										AT91C_VDD_30_31 +\
-										AT91C_VDD_31_32 +\
-										AT91C_VDD_32_33)
+#define AT91C_MMC_HOST_VOLTAGE_RANGE	(AT91C_VDD_27_28 | AT91C_VDD_28_29  | \
+    AT91C_VDD_29_30 | AT91C_VDD_30_31 | AT91C_VDD_31_32 | AT91C_VDD_32_33)
 
-////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
 // CURRENT_STATE & READY_FOR_DATA in SDCard Status Register definition (response type R1)
-////////////////////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
 #define AT91C_SR_READY_FOR_DATA				(1 << 8)	// corresponds to buffer empty signalling on the bus
 #define AT91C_SR_IDLE						(0 << 9)
 #define AT91C_SR_READY						(1 << 9)
@@ -306,112 +327,103 @@
 
 #define AT91C_SR_CARD_SELECTED				(AT91C_SR_READY_FOR_DATA + AT91C_SR_TRAN)
 
-/////////////////////////////////////////////////////////////////////////////////////////////////////
+#define MMC_FIRST_RCA				0xCAFE
+
+///////////////////////////////////////////////////////////////////////////////
 // MMC CSD register header File					
-// AT91C_CSD_xxx_S	for shift value
-// AT91C_CSD_xxx_M	for mask  value
-/////////////////////////////////////////////////////////////////////////////////////////////////////
+// CSD_x_xxx_S	for shift value for word x
+// CSD_x_xxx_M	for mask  value for word x
+///////////////////////////////////////////////////////////////////////////////
 
 // First Response INT <=> CSD[3] : bits 0 to 31
-#define	AT91C_CSD_BIT0_S			0		// [0:0]			
-#define	AT91C_CSD_BIT0_M			0x01				
-#define	AT91C_CSD_CRC_S				1		// [7:1]
-#define	AT91C_CSD_CRC_M				0x7F
-#define	AT91C_CSD_MMC_ECC_S			8		// [9:8]		reserved for MMC compatibility
-#define	AT91C_CSD_MMC_ECC_M			0x03
-#define	AT91C_CSD_FILE_FMT_S		10		// [11:10]
-#define	AT91C_CSD_FILE_FMT_M		0x03
-#define	AT91C_CSD_TMP_WP_S			12		// [12:12]
-#define	AT91C_CSD_TMP_WP_M			0x01
-#define	AT91C_CSD_PERM_WP_S 		13		// [13:13]
-#define	AT91C_CSD_PERM_WP_M 		0x01
-#define	AT91C_CSD_COPY_S	 		14		// [14:14]
-#define	AT91C_CSD_COPY_M 			0x01
-#define	AT91C_CSD_FILE_FMT_GRP_S	15		// [15:15]
-#define	AT91C_CSD_FILE_FMT_GRP_M	0x01
-//	reserved						16		// [20:16]
-//	reserved						0x1F
-#define	AT91C_CSD_WBLOCK_P_S 		21		// [21:21]
-#define	AT91C_CSD_WBLOCK_P_M 		0x01
-#define	AT91C_CSD_WBLEN_S 			22		// [25:22]
-#define	AT91C_CSD_WBLEN_M 			0x0F
-#define	AT91C_CSD_R2W_F_S 			26		// [28:26]
-#define	AT91C_CSD_R2W_F_M 			0x07
-#define	AT91C_CSD_MMC_DEF_ECC_S		29		// [30:29]		reserved for MMC compatibility
-#define	AT91C_CSD_MMC_DEF_ECC_M		0x03
-#define	AT91C_CSD_WP_GRP_EN_S		31		// [31:31]
-#define	AT91C_CSD_WP_GRP_EN_M 		0x01
+#define	CSD_3_BIT0_S		0		// [0:0]			
+#define	CSD_3_BIT0_M		0x01				
+#define	CSD_3_CRC_S		1		// [7:1]
+#define	CSD_3_CRC_M		0x7F
+#define	CSD_3_MMC_ECC_S		8		// [9:8] reserved for MMC compatibility
+#define	CSD_3_MMC_ECC_M		0x03
+#define	CSD_3_FILE_FMT_S	10		// [11:10]
+#define	CSD_3_FILE_FMT_M	0x03
+#define	CSD_3_TMP_WP_S		12		// [12:12]
+#define	CSD_3_TMP_WP_M		0x01
+#define	CSD_3_PERM_WP_S 	13		// [13:13]
+#define	CSD_3_PERM_WP_M 	0x01
+#define	CSD_3_COPY_S		14		// [14:14]
+#define	CSD_3_COPY_M 		0x01
+#define	CSD_3_FILE_FMT_GRP_S	15		// [15:15]
+#define	CSD_3_FILE_FMT_GRP_M	0x01
+//	reserved		16		// [20:16]
+//	reserved		0x1F
+#define	CSD_3_WBLOCK_P_S	21		// [21:21]
+#define	CSD_3_WBLOCK_P_M	0x01
+#define	CSD_3_WBLEN_S 		22		// [25:22]
+#define	CSD_3_WBLEN_M 		0x0F
+#define	CSD_3_R2W_F_S 		26		// [28:26]
+#define	CSD_3_R2W_F_M 		0x07
+#define	CSD_3_MMC_DEF_ECC_S	29		// [30:29] reserved for MMC compatibility
+#define	CSD_3_MMC_DEF_ECC_M	0x03
+#define	CSD_3_WP_GRP_EN_S	31		// [31:31]
+#define	CSD_3_WP_GRP_EN_M 	0x01
 
 // Seconde Response INT <=> CSD[2] : bits 32 to 63
-#define	AT91C_CSD_v21_WP_GRP_SIZE_S	0		// [38:32]				
-#define	AT91C_CSD_v21_WP_GRP_SIZE_M	0x7F				
-#define	AT91C_CSD_v21_SECT_SIZE_S	7		// [45:39]
-#define	AT91C_CSD_v21_SECT_SIZE_M	0x7F
-#define	AT91C_CSD_v21_ER_BLEN_EN_S	14		// [46:46]
-#define	AT91C_CSD_v21_ER_BLEN_EN_M	0x01
-
-#define	AT91C_CSD_v22_WP_GRP_SIZE_S	0		// [36:32]				
-#define	AT91C_CSD_v22_WP_GRP_SIZE_M	0x1F				
-#define	AT91C_CSD_v22_ER_GRP_SIZE_S	5		// [41:37]
-#define	AT91C_CSD_v22_ER_GRP_SIZE_M	0x1F
-#define	AT91C_CSD_v22_SECT_SIZE_S	10		// [46:42]
-#define	AT91C_CSD_v22_SECT_SIZE_M	0x1F
-
-#define	AT91C_CSD_C_SIZE_M_S		15		// [49:47]
-#define	AT91C_CSD_C_SIZE_M_M		0x07
-#define	AT91C_CSD_VDD_WMAX_S 		18		// [52:50]
-#define	AT91C_CSD_VDD_WMAX_M 		0x07
-#define	AT91C_CSD_VDD_WMIN_S	 	21		// [55:53]
-#define	AT91C_CSD_VDD_WMIN_M 		0x07
-#define	AT91C_CSD_RCUR_MAX_S 		24		// [58:56]
-#define	AT91C_CSD_RCUR_MAX_M 		0x07
-#define	AT91C_CSD_RCUR_MIN_S 		27		// [61:59]
-#define	AT91C_CSD_RCUR_MIN_M 		0x07
-#define	AT91C_CSD_CSIZE_L_S 		30		// [63:62] <=> 2 LSB of CSIZE
-#define	AT91C_CSD_CSIZE_L_M 		0x03
+#define	CSD_2_v21_WP_GRP_SIZE_S	0		// [38:32]				
+#define	CSD_2_v21_WP_GRP_SIZE_M	0x7F				
+#define	CSD_2_v21_SECT_SIZE_S	7		// [45:39]
+#define	CSD_2_v21_SECT_SIZE_M	0x7F
+#define	CSD_2_v21_ER_BLEN_EN_S	14		// [46:46]
+#define	CSD_2_v21_ER_BLEN_EN_M	0x01
+
+#define	CSD_2_v22_WP_GRP_SIZE_S	0		// [36:32]				
+#define	CSD_2_v22_WP_GRP_SIZE_M	0x1F				
+#define	CSD_2_v22_ER_GRP_SIZE_S	5		// [41:37]
+#define	CSD_2_v22_ER_GRP_SIZE_M	0x1F
+#define	CSD_2_v22_SECT_SIZE_S	10		// [46:42]
+#define	CSD_2_v22_SECT_SIZE_M	0x1F
+
+#define	CSD_2_C_SIZE_M_S	15		// [49:47]
+#define	CSD_2_C_SIZE_M_M	0x07
+#define	CSD_2_VDD_WMAX_S	18		// [52:50]
+#define	CSD_2_VDD_WMAX_M	0x07
+#define	CSD_2_VDD_WMIN_S 	21		// [55:53]
+#define	CSD_2_VDD_WMIN_M	0x07
+#define	CSD_2_RCUR_MAX_S	24		// [58:56]
+#define	CSD_2_RCUR_MAX_M	0x07
+#define	CSD_2_RCUR_MIN_S	27		// [61:59]
+#define	CSD_2_RCUR_MIN_M	0x07
+#define	CSD_2_CSIZE_L_S		30		// [63:62] <=> 2 LSB of CSIZE
+#define	CSD_2_CSIZE_L_M		0x03
 
 // Third Response INT <=> CSD[1] : bits 64 to 95
-#define	AT91C_CSD_CSIZE_H_S 		0		// [73:64]	<=> 10 MSB of CSIZE
-#define	AT91C_CSD_CSIZE_H_M 		0x03FF
-// reserved							10		// [75:74]
-// reserved							0x03		
-#define	AT91C_CSD_DSR_I_S 			12		// [76:76]
-#define	AT91C_CSD_DSR_I_M 			0x01
-#define	AT91C_CSD_RD_B_MIS_S 		13		// [77:77]
-#define	AT91C_CSD_RD_B_MIS_M 		0x01
-#define	AT91C_CSD_WR_B_MIS_S 		14		// [78:78]
-#define	AT91C_CSD_WR_B_MIS_M 		0x01
-#define	AT91C_CSD_RD_B_PAR_S 		15		// [79:79]
-#define	AT91C_CSD_RD_B_PAR_M 		0x01
-#define	AT91C_CSD_RD_B_LEN_S 		16		// [83:80]
-#define	AT91C_CSD_RD_B_LEN_M 		0x0F
-#define	AT91C_CSD_CCC_S	 			20		// [95:84]
-#define	AT91C_CSD_CCC_M 			0x0FFF
+#define	CSD_1_CSIZE_H_S		0	// [73:64]	<=> 10 MSB of CSIZE
+#define	CSD_1_CSIZE_H_M		0x03FF
+// reserved			10		// [75:74]
+// reserved			0x03		
+#define	CSD_1_DSR_I_S 		12		// [76:76]
+#define	CSD_1_DSR_I_M 		0x01
+#define	CSD_1_RD_B_MIS_S	13		// [77:77]
+#define	CSD_1_RD_B_MIS_M	0x01
+#define	CSD_1_WR_B_MIS_S	14		// [78:78]
+#define	CSD_1_WR_B_MIS_M	0x01
+#define	CSD_1_RD_B_PAR_S	15		// [79:79]
+#define	CSD_1_RD_B_PAR_M	0x01
+#define	CSD_1_RD_B_LEN_S	16		// [83:80]
+#define	CSD_1_RD_B_LEN_M	0x0F
+#define	CSD_1_CCC_S		20		// [95:84]
+#define	CSD_1_CCC_M 		0x0FFF
 
 // Fourth Response INT <=> CSD[0] : bits 96 to 127
-#define	AT91C_CSD_TRANS_SPEED_S 	0		// [103:96]
-#define	AT91C_CSD_TRANS_SPEED_M 	0xFF
-#define	AT91C_CSD_NSAC_S 			8		// [111:104]
-#define	AT91C_CSD_NSAC_M 			0xFF
-#define	AT91C_CSD_TAAC_S 			16		// [119:112]
-#define	AT91C_CSD_TAAC_M 			0xFF
-//	reserved						24		// [121:120]
-//	reserved						0x03
-#define	AT91C_CSD_MMC_SPEC_VERS_S	26		// [125:122]	reserved for MMC compatibility
-#define	AT91C_CSD_MMC_SPEC_VERS_M	0x0F
-#define	AT91C_CSD_STRUCT_S			30		// [127:126]
-#define	AT91C_CSD_STRUCT_M 			0x03
-
-/////////////////////////////////////////////////////////////////////////////////////////////////////
-
-void 				AT91F_MCI_Device_Handler(AT91PS_MciDevice,unsigned int);
-AT91S_MCIDeviceStatus 	AT91F_MCI_SDCard_Init (AT91PS_MciDevice);
-AT91S_MCIDeviceStatus 	AT91F_MCI_SetBlocklength(unsigned int);
-AT91S_MCIDeviceStatus 	AT91F_MCI_ReadBlock(AT91PS_MciDevice,int,unsigned int *,int);
-AT91S_MCIDeviceStatus 	AT91F_MCI_WriteBlock(AT91PS_MciDevice,int,unsigned int *,int);
-#if 0
-AT91S_MCIDeviceStatus AT91F_MCI_MMC_Init (AT91PS_MciDevice pMCI_Device);
-AT91S_MCIDeviceStatus AT91F_MCI_MMC_SelectCard(AT91PS_MciDevice pMCI_Device, unsigned int relative_card_address);
-#endif
+#define	CSD_0_TRANS_SPEED_S 	0		// [103:96]
+#define	CSD_0_TRANS_SPEED_M 	0xFF
+#define	CSD_0_NSAC_S		8		// [111:104]
+#define	CSD_0_NSAC_M		0xFF
+#define	CSD_0_TAAC_S		16		// [119:112]
+#define	CSD_0_TAAC_M 		0xFF
+//	reserved		24		// [121:120]
+//	reserved		0x03
+#define	CSD_0_MMC_SPEC_VERS_S	26		// [125:122]	reserved for MMC compatibility
+#define	CSD_0_MMC_SPEC_VERS_M	0x0F
+#define	CSD_0_STRUCT_S		30	// [127:126]
+#define	CSD_0_STRUCT_M 		0x03
 
+///////////////////////////////////////////////////////////////////////////////
 #endif
Index: arm/at91/libat91/p_string.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/p_string.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 p_string.c
--- arm/at91/libat91/p_string.c	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/p_string.c	20 Oct 2006 09:12:05 -0000
@@ -20,48 +20,13 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/p_string.c,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/p_string.c,v 1.3 2006/10/20 09:12:05 imp Exp $
  *****************************************************************************/
 
 #include "lib.h"
 
 /*
  * .KB_C_FN_DEFINITION_START
- * int p_IsWhiteSpace(char)
- *  This global function returns true if the character is not considered
- * a non-space character.
- * .KB_C_FN_DEFINITION_END
- */
-int
-p_IsWhiteSpace(char cValue)
-{
-	return ((cValue == ' ') ||
-		(cValue == '\t') ||
-		(cValue == 0) ||
-		(cValue == '\r') ||
-		(cValue == '\n'));
-}
-
-
-/*
- * .KB_C_FN_DEFINITION_START
- * unsigned p_HexCharValue(char)
- *  This global function returns the decimal value of the validated hex char.
- * .KB_C_FN_DEFINITION_END
- */
-unsigned
-p_HexCharValue(char cValue)
-{
-	if (cValue < ('9' + 1))
-		return (cValue - '0');
-	if (cValue < ('F' + 1))
-		return (cValue - 'A' + 10);
-	return (cValue - 'a' + 10);
-}
-
-
-/*
- * .KB_C_FN_DEFINITION_START
  * void p_memset(char *buffer, char value, int size)
  *  This global function sets memory at the pointer for the specified
  * number of bytes to value.
@@ -74,104 +39,6 @@
 		*buffer++ = value;
 }
 
-
-/*
- * .KB_C_FN_DEFINITION_START
- * int p_strlen(char *)
- *  This global function returns the number of bytes starting at the pointer
- * before (not including) the string termination character ('/0').
- * .KB_C_FN_DEFINITION_END
- */
-int
-p_strlen(const char *buffer)
-{
-	int	len = 0;
-	if (buffer)
-		while (buffer[len])
-			len++;
-	return (len);
-}
-
-
-/*
- * .KB_C_FN_DEFINITION_START
- * char *p_strcpy(char *to, char *from)
- *  This global function returns a pointer to the end of the destination string
- * after the copy operation (after the '/0').
- * .KB_C_FN_DEFINITION_END
- */
-char *
-p_strcpy(char *to, const char *from)
-{
-	while (*from)
-		*to++ = *from++;
-	*to++ = '\0';
-	return (to);
-}
-
-
-/*
- * .KB_C_FN_DEFINITION_START
- * unsigned p_ASCIIToHex(char *)
- *  This global function set the unsigned value equal to the converted
- * hex number passed as a string.  No error checking is performed; the
- * string must be valid hex value, point at the start of string, and be
- * NULL-terminated.
- * .KB_C_FN_DEFINITION_END
- */
-unsigned
-p_ASCIIToHex(const char *buf)
-{
-	unsigned	lValue = 0;
-
-	if ((*buf == '0') && ((buf[1] == 'x') || (buf[1] == 'X')))
-		buf += 2;
-
-	while (*buf) {
-		lValue <<= 4;
-		lValue += p_HexCharValue(*buf++);
-	}
-	return (lValue);
-}
-
-
-/*
- * .KB_C_FN_DEFINITION_START
- * unsigned p_ASCIIToDec(char *)
- *  This global function set the unsigned value equal to the converted
- * decimal number passed as a string.  No error checking is performed; the
- * string must be valid decimal value, point at the start of string, and be
- * NULL-terminated.
- * .KB_C_FN_DEFINITION_END
- */
-unsigned
-p_ASCIIToDec(const char *buf)
-{
-	unsigned v = 0;
-
-	while (*buf) {
-		v *= 10;
-		v += (*buf++) - '0';
-	}
-	return (v);
-}
-
-
-/*
- * .KB_C_FN_DEFINITION_START
- * void p_memcpy(char *, char *, unsigned)
- *  This global function copies data from the first pointer to the second
- * pointer for the specified number of bytes.
- * .KB_C_FN_DEFINITION_END
- */
-void
-p_memcpy(char *to, const char *from, unsigned size)
-{
-	while (size--)
-		*to++ = *from++;
-}
-
-
 /*
  * .KB_C_FN_DEFINITION_START
  * int p_memcmp(char *to, char *from, unsigned size)
@@ -188,23 +55,3 @@
 
 	return (*to != *from);
 }
-
-
-/*
- * .KB_C_FN_DEFINITION_START
- * int p_strcmp(char *to, char *from)
- *  This global function compares string at to against string at from.
- * Returns 0 if the locations are equal.
- * .KB_C_FN_DEFINITION_END
- */
-int
-p_strcmp(const char *to, const char *from)
-{
-
-	while (*to && *from && (*to == *from)) {
-		++to;
-		++from;
-	}
-
-	return (!((!*to) && (*to == *from)));
-}
Index: arm/at91/libat91/printf.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/printf.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 printf.c
--- arm/at91/libat91/printf.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/printf.c	20 Oct 2006 09:12:05 -0000
@@ -14,7 +14,7 @@
  * warranties of merchantability and fitness for a particular
  * purpose.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/printf.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/printf.c,v 1.2 2006/10/20 09:12:05 imp Exp $
  */
 
 #include <stdarg.h>
@@ -36,12 +36,13 @@
 			c = *fmt++;
 			switch (c) {
 			case 'c':
-				putchar(va_arg(ap, int));
+				xputchar(va_arg(ap, int));
 				continue;
 			case 's':
 				for (s = va_arg(ap, char *); *s; s++)
-					putchar(*s);
+					xputchar(*s);
 				continue;
+			case 'd':	/* A lie, always prints unsigned */
 			case 'u':
 				u = va_arg(ap, unsigned);
 				s = buf;
@@ -50,7 +51,7 @@
 				while (u /= 10U);
 			dumpbuf:;
 				while (--s >= buf)
-					putchar(*s);
+					xputchar(*s);
 				continue;
 			case 'x':
 				u = va_arg(ap, unsigned);
@@ -61,7 +62,7 @@
 				goto dumpbuf;
 			}
 		}
-		putchar(c);
+		xputchar(c);
 	}
 	va_end(ap);
 
Index: arm/at91/libat91/putchar.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/putchar.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 putchar.c
--- arm/at91/libat91/putchar.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/putchar.c	20 Oct 2006 09:12:05 -0000
@@ -31,7 +31,7 @@
  * owners.  This software is not copyrighted and is intended for reference
  * only.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/putchar.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/putchar.c,v 1.2 2006/10/20 09:12:05 imp Exp $
  */
 
 #include "at91rm9200.h"
@@ -52,3 +52,11 @@
 		continue;
 	pUSART->US_THR = (ch & 0xFF);
 }
+
+void
+xputchar(int ch)
+{
+    if (ch == '\n')
+	putchar('\r');
+    putchar(ch);
+}
Index: arm/at91/libat91/reset.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/reset.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 reset.c
--- arm/at91/libat91/reset.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/reset.c	16 Aug 2006 23:39:58 -0000
@@ -21,7 +21,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/reset.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/reset.c,v 1.1 2006/08/16 23:39:58 imp Exp $
  */
 
 #include "at91rm9200.h"
Index: arm/at91/libat91/sd-card.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/sd-card.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 sd-card.c
--- arm/at91/libat91/sd-card.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/sd-card.c	28 Mar 2007 22:31:32 -0000
@@ -24,7 +24,7 @@
  * This software is derived from software provide by Kwikbyte who specifically
  * disclaimed copyright on the code.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/sd-card.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/sd-card.c,v 1.4 2007/03/28 22:31:32 imp Exp $
  */
 
 //*----------------------------------------------------------------------------
@@ -51,13 +51,7 @@
 #define BUFFER_SIZE_MCI_DEVICE	512
 #define MASTER_CLOCK		60000000
 
-//Private functions
-//static void initInts(void);
-static void AT91F_MCI_Handler(void);
-
 //* Global Variables
-AT91S_MciDeviceFeatures		MCI_Device_Features;
-AT91S_MciDeviceDesc		MCI_Device_Desc;
 AT91S_MciDevice			MCI_Device;
 char				Buffer[BUFFER_SIZE_MCI_DEVICE];
 
@@ -68,11 +62,11 @@
 #define MCI_UNSUPP_OFFSET_ERROR 6
 
 //*----------------------------------------------------------------------------
-//* \fn    AT91F_MCIDeviceWaitReady
+//* \fn    MCIDeviceWaitReady
 //* \brief Wait for MCI Device ready
 //*----------------------------------------------------------------------------
 static void
-AT91F_MCIDeviceWaitReady(unsigned int timeout)
+MCIDeviceWaitReady(unsigned int timeout)
 {
 	volatile int status;
 	
@@ -83,176 +77,147 @@
 	}
 	while( !(status & AT91C_MCI_NOTBUSY)  && (timeout>0) );	
 
-#if IMP_DEBUG
-	if (timeout == 0)
-	    printf("Timeout, status is 0x%x\r\n", status);
-#endif
-	
-	//TODO: Make interrupts work!
-	AT91F_MCI_Handler();
+	status = AT91C_BASE_MCI->MCI_SR;
+
+	// If End of Tx Buffer Empty interrupt occurred
+	if (MCI_Device.state == AT91C_MCI_TX_SINGLE_BLOCK && status & AT91C_MCI_TXBUFE) {
+		AT91C_BASE_MCI->MCI_IDR = AT91C_MCI_TXBUFE;
+ 		AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_TXTDIS;
+		MCI_Device.state = AT91C_MCI_IDLE;
+	}	// End of if AT91C_MCI_TXBUFF
+
+	// If End of Rx Buffer Full interrupt occurred
+	if (MCI_Device.state == AT91C_MCI_RX_SINGLE_BLOCK && status & AT91C_MCI_RXBUFF) {
+		AT91C_BASE_MCI->MCI_IDR = AT91C_MCI_RXBUFF;
+ 		AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTDIS;
+		MCI_Device.state = AT91C_MCI_IDLE;
+	}	// End of if AT91C_MCI_RXBUFF
 }
 
-#if 0
-int
-MCI_write (unsigned dest, char* source, unsigned length)
+inline static unsigned int
+swap(unsigned int a)
 {
-	unsigned sectorLength = MCI_Device.pMCI_DeviceFeatures->Max_Read_DataBlock_Lenfgth;
-	unsigned offset = dest % sectorLength;
-	AT91S_MCIDeviceStatus status;
-	int sizeToWrite;
-
-#if IMP_DEBUG
-	printf("\r\n");
-#endif
+    return (((a & 0xff) << 24) | ((a & 0xff00) << 8) | ((a & 0xff0000) >> 8)
+      | ((a & 0xff000000) >> 24));
+}
 
-	//See if we are requested to write partial sectors, and have the capability to do so
-	if ((length % sectorLength) && !(MCI_Device_Features.Write_Partial))
-		//Return error if appropriat
-		return MCI_UNSUPP_SIZE_ERROR;
-
-	//See if we are requested to write to anywhere but a sectors' boundary
-	//and have the capability to do so
-	if ((offset) && !(MCI_Device_Features.Write_Partial))
-		//Return error if appropriat
-		return MCI_UNSUPP_OFFSET_ERROR;
+inline static void
+wait_ready()
+{
+	int status;
 
-	//If the address we're trying to write != sector boundary
-	if (offset)
+	// wait for CMDRDY Status flag to read the response
+	do
 	{
-		//* Wait MCI Device Ready
-		AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
-
-		//Calculate the nr of bytes to write
-		sizeToWrite = sectorLength - offset;
-		//Do the writing
-		status = AT91F_MCI_WriteBlock(&MCI_Device, dest, (unsigned int*)source, sizeToWrite);
-		//TODO:Status checking
-
-		//Update counters & pointers
-		length -= sizeToWrite;
-		dest += sizeToWrite;
-		source += sizeToWrite;
-	}
+		status = AT91C_BASE_MCI->MCI_SR;
+	} while( !(status & AT91C_MCI_CMDRDY) );
+}
 
-	//As long as there is data to write
-	while (length)
-	{
-		//See if we've got at least a sector to write
-		if (length > sectorLength) 
-			sizeToWrite = sectorLength;
-		//Else just write the remainder
-		else
-			sizeToWrite = length;
+//*----------------------------------------------------------------------------
+//* \fn    MCI_SendCommand
+//* \brief Generic function to send a command to the MMC or SDCard
+//*----------------------------------------------------------------------------
+static int
+MCI_SendCommand(
+	unsigned int Cmd,
+	unsigned int Arg)
+{
+	unsigned int	error;
 
-		AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
-		//Do the writing
-		status = AT91F_MCI_WriteBlock(&MCI_Device, dest, (unsigned int*)source, sizeToWrite);
-		//TODO:Status checking
+	AT91C_BASE_MCI->MCI_ARGR = Arg;
+	AT91C_BASE_MCI->MCI_CMDR = Cmd;
 
-		//Update counters & pointers
-		length -= sizeToWrite;
-		dest += sizeToWrite;
-		source += sizeToWrite;
+//	printf("CMDR %x ARG %x\n", Cmd, Arg);
+	wait_ready();
+	// Test error  ==> if crc error and response R3 ==> don't check error
+	error = (AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR;
+	if (error != 0) {
+		if (error != AT91C_MCI_RCRCE)
+			return (1);
 	}
-
 	return 0;
 }
-#endif
 
-inline static unsigned int
-swap(unsigned int a)
+//*----------------------------------------------------------------------------
+//* \fn    MCI_GetStatus
+//* \brief Addressed card sends its status register
+//*----------------------------------------------------------------------------
+static unsigned int
+MCI_GetStatus()
 {
-    return (((a & 0xff) << 24) | ((a & 0xff00) << 8) | ((a & 0xff0000) >> 8)
-      | ((a & 0xff000000) >> 24));
+	if (MCI_SendCommand(SEND_STATUS_CMD, MCI_Device.RCA << 16))
+		return AT91C_CMD_SEND_ERROR;
+	return (AT91C_BASE_MCI->MCI_RSPR[0]);
+}
+
+//*----------------------------------------------------------------------------
+//* \fn    MCI_ReadBlock
+//* \brief Read an ENTIRE block or PARTIAL block
+//*----------------------------------------------------------------------------
+static int
+MCI_ReadBlock(int src, unsigned int *dataBuffer, int sizeToRead)
+{
+//	unsigned log2sl = MCI_Device.READ_BL_LEN;
+//	unsigned sectorLength = 1 << log2sl;
+	unsigned sectorLength = 512;
+
+	///////////////////////////////////////////////////////////////////////
+	if (MCI_Device.state != AT91C_MCI_IDLE)
+		return 1;
+    
+	if ((MCI_GetStatus() & AT91C_SR_READY_FOR_DATA) == 0)
+		return 1;
+
+	///////////////////////////////////////////////////////////////////////
+      
+        // Init Mode Register
+	AT91C_BASE_MCI->MCI_MR |= ((sectorLength << 16) | AT91C_MCI_PDCMODE);
+	 
+	sizeToRead = sizeToRead / 4;
+
+	AT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);
+	AT91C_BASE_PDC_MCI->PDC_RPR  = (unsigned int)dataBuffer;
+	AT91C_BASE_PDC_MCI->PDC_RCR  = sizeToRead;
+
+	// Send the Read single block command
+	if (MCI_SendCommand(READ_SINGLE_BLOCK_CMD, src))
+		return AT91C_READ_ERROR;
+	MCI_Device.state = AT91C_MCI_RX_SINGLE_BLOCK;
+
+	// Enable AT91C_MCI_RXBUFF Interrupt
+	AT91C_BASE_MCI->MCI_IER = AT91C_MCI_RXBUFF;
+
+	// (PDC) Receiver Transfer Enable
+	AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTEN;
+	
+	return 0;
 }
 
 int
 MCI_read(char* dest, unsigned source, unsigned length)
 {
-	unsigned sectorLength = MCI_Device.pMCI_DeviceFeatures->Max_Read_DataBlock_Length;
-	unsigned log2sl = MCI_Device.pMCI_DeviceFeatures->READ_BL_LEN;
-	unsigned slmask = ((1 << log2sl) - 1);
-//	unsigned sector = (unsigned)source >> log2sl;
-	unsigned offset = (unsigned)source & slmask;
-	AT91S_MCIDeviceStatus status;
+//	unsigned log2sl = MCI_Device.READ_BL_LEN;
+//	unsigned sectorLength = 1 << log2sl;
+	unsigned sectorLength = 512;
 	int sizeToRead;
 	unsigned int *walker;
 
-#if IMP_DEBUG
-	printf("Reading 0x%x bytes into ARM Addr 0x%x from card offset 0x%x\r\n",
-	  length, dest, source);
-#endif
-	
-
-	//See if we are requested to read partial sectors, and have the capability to do so
-	if ((length & slmask) && !(MCI_Device_Features.Read_Partial))
-		//Return error if appropriat
-		return MCI_UNSUPP_SIZE_ERROR;
-
-	//See if we are requested to read from anywhere but a sectors' boundary
-	//and have the capability to do so
-	if ((offset) && !(MCI_Device_Features.Read_Partial))
-		//Return error if appropriat
-		return MCI_UNSUPP_OFFSET_ERROR;
-
-	//If the address we're trying to read != sector boundary
-	if (offset) {
-		//* Wait MCI Device Ready
-		AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
-
-		//Calculate the nr of bytes to read
-		sizeToRead = sectorLength - offset;
-		//Do the writing
-		status = AT91F_MCI_ReadBlock(&MCI_Device, source, (unsigned int*)dest, sizeToRead);
-		//TODO:Status checking
-		if (status != AT91C_READ_OK) {
-#if IMP_DEBUG
-		    printf("STATUS is 0x%x\r\n", status);
-#endif
-		    return -1;
-		}
-		
-		//* Wait MCI Device Ready
-		AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
-		// Fix erratum in MCI part
-		for (walker = (unsigned int *)dest;
-		     walker < (unsigned int *)(dest + sizeToRead); walker++)
-		    *walker = swap(*walker);
-
-		//Update counters & pointers
-		length -= sizeToRead;
-		dest += sizeToRead;
-		source += sizeToRead;
-	}
-
 	//As long as there is data to read
 	while (length)
 	{
-		//See if we've got at least a sector to read
 		if (length > sectorLength)
 			sizeToRead = sectorLength;
-		//Else just write the remainder
 		else
 			sizeToRead = length;
 
-		AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
-		//Do the writing
-		status = AT91F_MCI_ReadBlock(&MCI_Device, source, (unsigned int*)dest, sizeToRead);
-#if IMP_DEBUG
-		printf("Reading 0x%x Addr 0x%x card 0x%x\r\n",
-		  sizeToRead, dest, source);
-#endif
-
-		//TODO:Status checking
-		if (status != AT91C_READ_OK) {
-#if IMP_DEBUG
-		        printf("STATUS is 0x%x\r\n", status);
-#endif
+		MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
+		//Do the reading
+		if (MCI_ReadBlock(source,
+			(unsigned int*)dest, sizeToRead))
 			return -1;
-		}
 
 		//* Wait MCI Device Ready
-		AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
+		MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
 
 		// Fix erratum in MCI part
 		for (walker = (unsigned int *)dest;
@@ -268,39 +233,113 @@
 	return 0;
 }
 
+//*----------------------------------------------------------------------------
+//* \fn    MCI_SDCard_SendAppCommand
+//* \brief Specific function to send a specific command to the SDCard
+//*----------------------------------------------------------------------------
+static int
+MCI_SDCard_SendAppCommand(
+	unsigned int Cmd_App,
+	unsigned int Arg)
+{
+	// Send the CMD55 for application specific command
+	AT91C_BASE_MCI->MCI_ARGR = (MCI_Device.RCA << 16 );
+	AT91C_BASE_MCI->MCI_CMDR = APP_CMD;
+
+	wait_ready();
+	// if an error occurs
+	if (AT91C_BASE_MCI->MCI_SR & AT91C_MCI_SR_ERROR)
+		return (1);
+	return (MCI_SendCommand(Cmd_App,Arg));
+}
 
 //*----------------------------------------------------------------------------
-//* \fn    AT91F_CfgDevice
-//* \brief This function is used to initialise MMC or SDCard Features
+//* \fn    MCI_GetCSD
+//* \brief Asks to the specified card to send its CSD
 //*----------------------------------------------------------------------------
-static void AT91F_CfgDevice(void)
+static int
+MCI_GetCSD(unsigned int rca, unsigned int *response)
 {
-	// Init Device Structure
+ 	
+ 	if (MCI_SendCommand(SEND_CSD_CMD, (rca << 16)))
+		return 1;
+	
+	response[0] = AT91C_BASE_MCI->MCI_RSPR[0];
+   	response[1] = AT91C_BASE_MCI->MCI_RSPR[1];
+	response[2] = AT91C_BASE_MCI->MCI_RSPR[2];
+	response[3] = AT91C_BASE_MCI->MCI_RSPR[3];
+    
+	return 0;
+}
+
+//*----------------------------------------------------------------------------
+//* \fn    MCI_SDCard_GetOCR
+//* \brief Asks to all cards to send their operations conditions
+//*----------------------------------------------------------------------------
+static int
+MCI_SDCard_GetOCR()
+{
+	unsigned int	response=0x0;
 
-	MCI_Device_Features.Relative_Card_Address 	= 0;
-	MCI_Device_Features.Card_Inserted 		= AT91C_SD_CARD_INSERTED;
-	MCI_Device_Features.Max_Read_DataBlock_Length	= 0;
-	MCI_Device_Features.Max_Write_DataBlock_Length 	= 0;
-	MCI_Device_Features.Read_Partial 		= 0;
-	MCI_Device_Features.Write_Partial 		= 0;
-	MCI_Device_Features.Erase_Block_Enable 		= 0;
-	MCI_Device_Features.Sector_Size 		= 0;
-	MCI_Device_Features.Memory_Capacity 		= 0;
-	MCI_Device_Desc.state				= AT91C_MCI_IDLE;
-	MCI_Device_Desc.SDCard_bus_width		= AT91C_MCI_SCDBUS;
-	MCI_Device.pMCI_DeviceDesc 			= &MCI_Device_Desc;
-	MCI_Device.pMCI_DeviceFeatures 			= &MCI_Device_Features;
+	// The RCA to be used for CMD55 in Idle state shall be the card's default RCA=0x0000.
+	MCI_Device.RCA = 0x0;
+ 	
+ 	while( (response & AT91C_CARD_POWER_UP_BUSY) != AT91C_CARD_POWER_UP_BUSY ) {
+		if (MCI_SDCard_SendAppCommand(SDCARD_APP_OP_COND_CMD,
+			AT91C_MMC_HOST_VOLTAGE_RANGE))
+			return 1;
+		response = AT91C_BASE_MCI->MCI_RSPR[0];
+	}
+	return (0);
+}
 
+//*----------------------------------------------------------------------------
+//* \fn    MCI_SDCard_GetCID
+//* \brief Asks to the SDCard on the chosen slot to send its CID
+//*----------------------------------------------------------------------------
+static int
+MCI_SDCard_GetCID(unsigned int *response)
+{
+	if (MCI_SendCommand(ALL_SEND_CID_CMD, AT91C_NO_ARGUMENT))
+		return 1;
+	
+	response[0] = AT91C_BASE_MCI->MCI_RSPR[0];
+   	response[1] = AT91C_BASE_MCI->MCI_RSPR[1];
+	response[2] = AT91C_BASE_MCI->MCI_RSPR[2];
+	response[3] = AT91C_BASE_MCI->MCI_RSPR[3];
+    
+	return 0;
 }
 
-static void AT91F_MCI_Handler(void)
+//*----------------------------------------------------------------------------
+//* \fn    MCI_SDCard_SetBusWidth
+//* \brief  Set bus width for SDCard
+//*----------------------------------------------------------------------------
+static int
+MCI_SDCard_SetBusWidth()
 {
-	int status;
+	volatile int	ret_value;
+	char			bus_width;
 
-//	status = ( AT91C_BASE_MCI->MCI_SR & AT91C_BASE_MCI->MCI_IMR );
-	status = AT91C_BASE_MCI->MCI_SR;
+	do {
+		ret_value=MCI_GetStatus();
+	}
+	while((ret_value > 0) && ((ret_value & AT91C_SR_READY_FOR_DATA) == 0));
 
-	AT91F_MCI_Device_Handler(&MCI_Device,status);
+	// Select Card
+	MCI_SendCommand(SEL_DESEL_CARD_CMD, (MCI_Device.RCA)<<16);
+
+	// Set bus width for Sdcard
+	if (MCI_Device.SDCard_bus_width == AT91C_MCI_SCDBUS)
+		bus_width = AT91C_BUS_WIDTH_4BITS;
+	else
+		bus_width = AT91C_BUS_WIDTH_1BIT;
+
+	if (MCI_SDCard_SendAppCommand(
+	      SDCARD_SET_BUS_WIDTH_CMD,bus_width) != AT91C_CMD_SEND_OK)
+		return 1;
+
+	return 0;
 }
 
 //*----------------------------------------------------------------------------
@@ -310,26 +349,64 @@
 int
 sdcard_init(void)
 {
-///////////////////////////////////////////////////////////////////////////////
-//  MCI Init : common to MMC and SDCard
-///////////////////////////////////////////////////////////////////////////////
-
-	//initInts();
+	unsigned int	tab_response[4];
+#ifdef REPORT_SIZE
+	unsigned int	mult,blocknr;
+#endif
+	int i;
 
 	// Init MCI for MMC and SDCard interface
 	AT91F_MCI_CfgPIO();	
 	AT91F_MCI_CfgPMC();
 	AT91F_PDC_Open(AT91C_BASE_PDC_MCI);
 
-	// Init MCI Device Structures
-	AT91F_CfgDevice();
+	// Init Device Structure
+	MCI_Device.state		= AT91C_MCI_IDLE;
+	MCI_Device.SDCard_bus_width	= AT91C_MCI_SCDBUS;
 
-	AT91F_MCI_Configure(AT91C_BASE_MCI,
-	    AT91C_MCI_DTOR_1MEGA_CYCLES,
-	    AT91C_MCI_MR_PDCMODE,			// 15MHz for MCK = 60MHz (CLKDIV = 1)
-	    AT91C_MCI_SDCARD_4BITS_SLOTA);
-	
-	if (AT91F_MCI_SDCard_Init(&MCI_Device) != AT91C_INIT_OK)
+	//* Reset the MCI
+	AT91C_BASE_MCI->MCI_CR = AT91C_MCI_MCIEN | AT91C_MCI_PWSEN;
+	AT91C_BASE_MCI->MCI_IDR = 0xFFFFFFFF;
+	AT91C_BASE_MCI->MCI_DTOR = AT91C_MCI_DTOR_1MEGA_CYCLES;
+	AT91C_BASE_MCI->MCI_MR = AT91C_MCI_PDCMODE;
+	AT91C_BASE_MCI->MCI_SDCR = AT91C_MCI_SDCARD_4BITS_SLOTA;
+	MCI_SendCommand(GO_IDLE_STATE_CMD, AT91C_NO_ARGUMENT);
+
+	for (i = 0; i < 100; i++) {
+		if (!MCI_SDCard_GetOCR(&MCI_Device))
+			break;
+		printf(".");
+	}
+	if (i >= 100)
+		return 0;
+	if (MCI_SDCard_GetCID(tab_response))
+		return 0;
+	if (MCI_SendCommand(SET_RELATIVE_ADDR_CMD, 0))
 		return 0;
+
+	MCI_Device.RCA = (AT91C_BASE_MCI->MCI_RSPR[0] >> 16);
+	if (MCI_GetCSD(MCI_Device.RCA,tab_response))
+		return 0;
+	MCI_Device.READ_BL_LEN = (tab_response[1] >> CSD_1_RD_B_LEN_S) &
+	    CSD_1_RD_B_LEN_M;
+#ifdef REPORT_SIZE
+	// compute MULT
+	mult = 1 << ( ((tab_response[2] >> CSD_2_C_SIZE_M_S) &
+	    CSD_2_C_SIZE_M_M) + 2 );
+	// compute MSB of C_SIZE
+	blocknr = ((tab_response[1] >> CSD_1_CSIZE_H_S) &
+	    CSD_1_CSIZE_H_M) << 2;
+	// compute MULT * (LSB of C-SIZE + MSB already computed + 1) = BLOCKNR
+	blocknr = mult * ((blocknr + ((tab_response[2] >> CSD_2_CSIZE_L_S) &
+	    CSD_2_CSIZE_L_M)) + 1);
+	MCI_Device.Memory_Capacity = (1 << MCI_Device.READ_BL_LEN) * blocknr;
+#endif
+	if (MCI_SDCard_SetBusWidth())
+		return 0;
+	if (MCI_SendCommand(SET_BLOCKLEN_CMD, 1 << MCI_Device.READ_BL_LEN))
+		return 0;
+#ifdef REPORT_SIZE
+	printf("Found SD card %u bytes\n", MCI_Device.Memory_Capacity);
+#endif
 	return 1;
 }
Index: arm/at91/libat91/sd-card.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/sd-card.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 sd-card.h
--- arm/at91/libat91/sd-card.h	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/sd-card.h	16 Aug 2006 23:39:58 -0000
@@ -24,7 +24,7 @@
  * This software is derived from software provide by Kwikbyte who specifically
  * disclaimed copyright on the code.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/sd-card.h,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/sd-card.h,v 1.1 2006/08/16 23:39:58 imp Exp $
  */
 
 #ifndef __SD_CARD_H
Index: arm/at91/libat91/spi_flash.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/spi_flash.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 spi_flash.c
--- arm/at91/libat91/spi_flash.c	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/spi_flash.c	28 Mar 2007 22:38:01 -0000
@@ -19,7 +19,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/spi_flash.c,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/spi_flash.c,v 1.4 2007/03/28 22:38:01 imp Exp $
  *****************************************************************************/
 
 #include "at91rm9200.h"
@@ -119,6 +119,23 @@
 	byteAddress = flash_addr % FLASH_PAGE_SIZE;
 
 	p_memset(tx_commandBuffer, 0, 8);
+#ifdef BOOT_BWCT
+	tx_commandBuffer[0] = 0xd2;
+	tx_commandBuffer[1] = ((pageAddress >> 6) & 0xFF);
+	tx_commandBuffer[2] = ((pageAddress << 2) & 0xFC) |
+				((byteAddress >> 8) & 0x3);
+	tx_commandBuffer[3] = byteAddress & 0xFF;
+	spi_command.tx_cmd = tx_commandBuffer;
+	spi_command.tx_cmd_size = 8;
+	spi_command.tx_data_size = size;
+	spi_command.tx_data = dest_addr;
+
+	p_memset(rx_commandBuffer, 0, 8);
+	spi_command.rx_cmd = rx_commandBuffer;
+	spi_command.rx_cmd_size = 8;
+	spi_command.rx_data_size = size;
+	spi_command.rx_data = dest_addr;
+#else
 	tx_commandBuffer[0] = CONTINUOUS_ARRAY_READ_HF;
 	tx_commandBuffer[1] = ((pageAddress >> 5) & 0xFF);
 	tx_commandBuffer[2] = ((pageAddress << 3) & 0xF8) |
@@ -134,6 +151,7 @@
 	spi_command.rx_cmd_size = 5;
 	spi_command.rx_data_size = size;
 	spi_command.rx_data = dest_addr;
+#endif
 
 	SendCommand(&spi_command);
 }
@@ -159,11 +177,19 @@
 	byteAddress = flash_addr % FLASH_PAGE_SIZE;
 
 	p_memset(tx_commandBuffer, 0, 8);
+#ifdef BOOT_BWCT
+	tx_commandBuffer[0] = 0x82;
+	tx_commandBuffer[1] = ((pageAddress >> 6) & 0xFF);
+	tx_commandBuffer[2] = ((pageAddress << 2) & 0xFC) |
+				((byteAddress >> 8) & 0x3);
+	tx_commandBuffer[3] = (byteAddress & 0xFF);
+#else
 	tx_commandBuffer[0] = PROGRAM_THROUGH_BUFFER;
 	tx_commandBuffer[1] = ((pageAddress >> 5) & 0xFF);
 	tx_commandBuffer[2] = ((pageAddress << 3) & 0xF8) |
 				((byteAddress >> 8) & 0x7);
 	tx_commandBuffer[3] = (byteAddress & 0xFF);
+#endif
 
 	p_memset(rx_commandBuffer, 0, 8);
 
@@ -230,9 +256,11 @@
 	value = pSPI->SPI_RDR;
 	value = pSPI->SPI_SR;
 
-	// Increment real time counter every SLCK
-	AT91C_BASE_ST->ST_RTMR = 1;
-
+#ifdef BOOT_BWCT
+	if (((value = GetFlashStatus()) & 0xFC) != 0xB4)
+		printf(" Bad SPI status: 0x%x\n", value);
+#else
 	if (((value = GetFlashStatus()) & 0xFC) != 0xBC)
-		printf(" Bad SPI status: 0x%x\r\n", value);
+		printf(" Bad SPI status: 0x%x\n", value);
+#endif
 }
Index: arm/at91/libat91/spi_flash.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/spi_flash.h,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 spi_flash.h
--- arm/at91/libat91/spi_flash.h	17 Aug 2006 22:57:08 -0000	1.1.2.1
+++ arm/at91/libat91/spi_flash.h	20 Dec 2006 18:25:16 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/spi_flash.h,v 1.1.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/spi_flash.h,v 1.2 2006/12/20 18:25:16 imp Exp $
  ******************************************************************************/
 
 #ifndef _SPI_FLASH_H_
@@ -40,7 +40,11 @@
 
 void SPI_GetId(unsigned *id);
 
+#ifdef BOOT_BWCT
+#define FLASH_PAGE_SIZE	528
+#else
 #define FLASH_PAGE_SIZE	1056
+#endif
 
 // Flash commands
 
Index: arm/at91/libat91/tag_list.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/tag_list.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 tag_list.c
--- arm/at91/libat91/tag_list.c	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/tag_list.c	21 Apr 2006 07:19:22 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/tag_list.c,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/tag_list.c,v 1.2 2006/04/21 07:19:22 imp Exp $
  *****************************************************************************/
 
 /******************************* GLOBALS *************************************/
Index: arm/at91/libat91/tag_list.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/tag_list.h,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 tag_list.h
--- arm/at91/libat91/tag_list.h	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/tag_list.h	21 Apr 2006 07:12:12 -0000
@@ -17,7 +17,7 @@
  * only.
  * END_BLOCK
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/tag_list.h,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/tag_list.h,v 1.2 2006/04/21 07:12:12 imp Exp $
  ****************************************************************************/
 
 #ifndef _TAG_LIST_H_
Index: arm/at91/libat91/xmodem.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/arm/at91/libat91/xmodem.c,v
retrieving revision 1.2.2.1
diff -u -r1.2.2.1 xmodem.c
--- arm/at91/libat91/xmodem.c	17 Aug 2006 22:57:08 -0000	1.2.2.1
+++ arm/at91/libat91/xmodem.c	10 Aug 2006 17:54:51 -0000
@@ -25,7 +25,7 @@
  * disclaimed copyright on the code.  This version of xmodem has been nearly
  * completely rewritten, but the CRC is from the original.
  *
- * $FreeBSD: src/sys/boot/arm/at91/libat91/xmodem.c,v 1.2.2.1 2006/08/17 22:57:08 imp Exp $
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/xmodem.c,v 1.2 2006/08/10 17:54:51 imp Exp $
  */
 
 #include "lib.h"
Index: common/Makefile.inc
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/Makefile.inc,v
retrieving revision 1.21
diff -u -r1.21 Makefile.inc
--- common/Makefile.inc	24 Oct 2004 12:32:41 -0000	1.21
+++ common/Makefile.inc	2 Nov 2006 00:26:44 -0000
@@ -1,6 +1,6 @@
-# $FreeBSD: src/sys/boot/common/Makefile.inc,v 1.21 2004/10/24 12:32:41 ru Exp $
+# $FreeBSD: src/sys/boot/common/Makefile.inc,v 1.23 2006/11/02 00:26:44 marcel Exp $
 
-SRCS+=	bcache.c boot.c commands.c console.c devopen.c interp.c 
+SRCS+=	boot.c commands.c console.c devopen.c interp.c 
 SRCS+=	interp_backslash.c interp_parse.c ls.c misc.c 
 SRCS+=	module.c panic.c
 
@@ -11,8 +11,7 @@
 SRCS+=	load_elf32.c load_elf32_obj.c reloc_elf32.c
 .elif ${MACHINE_ARCH} == "powerpc"
 SRCS+=	load_elf32.c reloc_elf32.c
-.elif ${MACHINE_ARCH} == "sparc64" || ${MACHINE_ARCH} == "ia64" || \
-    ${MACHINE_ARCH} == "alpha"
+.elif ${MACHINE_ARCH} == "sparc64" || ${MACHINE_ARCH} == "ia64"
 SRCS+=	load_elf64.c reloc_elf64.c
 .endif
 
@@ -20,6 +19,10 @@
 SRCS+=	dev_net.c
 .endif
 
+.if defined(HAVE_BCACHE)
+SRCS+=  bcache.c
+.endif
+
 # Machine-independant ISA PnP
 .if defined(HAVE_ISABUS)
 SRCS+=	isapnp.c
Index: common/bootstrap.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/bootstrap.h,v
retrieving revision 1.41.2.1
diff -u -r1.41.2.1 bootstrap.h
--- common/bootstrap.h	30 Dec 2005 22:13:58 -0000	1.41.2.1
+++ common/bootstrap.h	18 Dec 2006 07:35:14 -0000
@@ -23,7 +23,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/common/bootstrap.h,v 1.41.2.1 2005/12/30 22:13:58 marcel Exp $
+ * $FreeBSD: src/sys/boot/common/bootstrap.h,v 1.44 2006/12/18 07:35:14 kmacy Exp $
  */
 
 #include <sys/types.h>
@@ -43,6 +43,7 @@
 #define DEVT_DISK	1
 #define DEVT_NET	2
 #define	DEVT_CD		3
+    int			d_unit;
 };
 
 /* Commands and return values; nonzero return sets command_errmsg != NULL */
@@ -291,6 +292,8 @@
     /* Perform ISA byte port I/O (only for systems with ISA) */
     int		(*arch_isainb)(int port);
     void	(*arch_isaoutb)(int port, int value);
+    /* Pass in initial kernel memory size */
+    void        (*arch_maphint)(vm_offset_t va, size_t len);	
 };
 extern struct arch_switch archsw;
 
Index: common/console.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/console.c,v
retrieving revision 1.7.2.1
diff -u -r1.7.2.1 console.c
--- common/console.c	5 Aug 2005 00:36:59 -0000	1.7.2.1
+++ common/console.c	29 Jul 2005 12:47:42 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/console.c,v 1.7.2.1 2005/08/05 00:36:59 brian Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/console.c,v 1.8 2005/07/29 12:47:42 brian Exp $");
 
 #include <stand.h>
 #include <string.h>
Index: common/devopen.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/devopen.c,v
retrieving revision 1.4
diff -u -r1.4 devopen.c
--- common/devopen.c	25 Aug 2003 23:30:41 -0000	1.4
+++ common/devopen.c	2 Nov 2006 00:02:22 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/devopen.c,v 1.4 2003/08/25 23:30:41 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/devopen.c,v 1.5 2006/11/02 00:02:22 marcel Exp $");
 
 #include <stand.h>
 #include <string.h>
@@ -35,20 +35,25 @@
 int
 devopen(struct open_file *f, const char *fname, const char **file) 
 {
-    struct devdesc	*dev;
-    int			result;
+    struct devdesc *dev;
+    int result;
 
-    if ((result = archsw.arch_getdev((void *)&dev, fname, file)) == 0) {	/* get the device */
-	/* point to device-specific data so that device open can use it */
-	f->f_devdata = dev;
-	if ((result = dev->d_dev->dv_open(f, dev)) == 0) { 		/* try to open it */
-	    /* reference the devsw entry from the open_file structure */
-	    f->f_dev = dev->d_dev;
-	} else {
-	    free(dev);		/* release the device descriptor */
-	}
+    result = archsw.arch_getdev((void **)&dev, fname, file);
+    if (result)
+	return (result);
+
+    /* point to device-specific data so that device open can use it */
+    f->f_devdata = dev;
+    result = dev->d_dev->dv_open(f, dev);
+    if (result != 0) {
+	f->f_devdata = NULL;
+	free(dev);
+	return (result);
     }
-    return(result);
+
+    /* reference the devsw entry from the open_file structure */
+    f->f_dev = dev->d_dev;
+    return (0);
 }
 
 int
Index: common/load_elf.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/load_elf.c,v
retrieving revision 1.32.2.1
diff -u -r1.32.2.1 load_elf.c
--- common/load_elf.c	30 Dec 2005 22:13:58 -0000	1.32.2.1
+++ common/load_elf.c	2 Nov 2006 17:52:43 -0000
@@ -26,12 +26,13 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/load_elf.c,v 1.32.2.1 2005/12/30 22:13:58 marcel Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/load_elf.c,v 1.37 2006/11/02 17:52:43 ru Exp $");
 
 #include <sys/param.h>
 #include <sys/exec.h>
 #include <sys/linker.h>
 #include <sys/module.h>
+#include <sys/stdint.h>
 #include <string.h>
 #include <machine/elf.h>
 #include <stand.h>
@@ -266,7 +267,7 @@
 	off = - (off & 0xff000000u);	/* i386 relocates after locore */
 #endif
 #else
-	off = 0;		/* alpha is direct mapped for kernels */
+	off = 0;		/* other archs use direct mapped kernels */
 #endif
     }
     ef->off = off;
@@ -400,9 +401,9 @@
 	lastaddr += sizeof(size);
 
 #ifdef ELF_VERBOSE
-	printf("\n%s: 0x%lx@0x%lx -> 0x%lx-0x%lx", secname,
-	    shdr[i].sh_size, shdr[i].sh_offset,
-	    lastaddr, lastaddr + shdr[i].sh_size);
+	printf("\n%s: 0x%jx@0x%jx -> 0x%jx-0x%jx", secname,
+	    (uintmax_t)shdr[i].sh_size, (uintmax_t)shdr[i].sh_offset,
+	    (uintmax_t)lastaddr, (uintmax_t)(lastaddr + shdr[i].sh_size));
 #else
 	if (i == symstrindex)
 	    printf("+");
Index: common/load_elf_obj.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/load_elf_obj.c,v
retrieving revision 1.1.4.1
diff -u -r1.1.4.1 load_elf_obj.c
--- common/load_elf_obj.c	30 Dec 2005 22:13:58 -0000	1.1.4.1
+++ common/load_elf_obj.c	18 Dec 2005 04:52:35 -0000
@@ -27,7 +27,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/load_elf_obj.c,v 1.1.4.1 2005/12/30 22:13:58 marcel Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/load_elf_obj.c,v 1.2 2005/12/18 04:52:35 marcel Exp $");
 
 #include <sys/param.h>
 #include <sys/exec.h>
Index: common/loader.8
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/loader.8,v
retrieving revision 1.82.2.5.2.1
diff -u -r1.82.2.5.2.1 loader.8
--- common/loader.8	21 Dec 2006 12:43:02 -0000	1.82.2.5.2.1
+++ common/loader.8	9 May 2007 02:37:58 -0000
@@ -22,9 +22,9 @@
 .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 .\" SUCH DAMAGE.
 .\"
-.\" $FreeBSD: src/sys/boot/common/loader.8,v 1.82.2.5.2.1 2006/12/21 12:43:02 yar Exp $
+.\" $FreeBSD: src/sys/boot/common/loader.8,v 1.93 2007/05/09 02:37:58 sepotvin Exp $
 .\"
-.Dd November 29, 2006
+.Dd May 8, 2007
 .Dt LOADER 8
 .Os
 .Sh NAME
@@ -423,12 +423,63 @@
 .It Va currdev
 Selects the default device.
 Syntax for devices is odd.
+.It Va init_chroot
+If set to a valid directory in the root file system, it causes
+.Xr init 8
+to perform a
+.Xr chroot 2
+operation on that directory, making it the new root directory.
+That happens before entering single-user mode or multi-user
+mode (but after executing the
+.Va init_script
+if enabled).
 .It Va init_path
 Sets the list of binaries which the kernel will try to run as the initial
 process.
 The first matching binary is used.
 The default list is
 .Dq Li /sbin/init:/sbin/oinit:/sbin/init.bak:\:/rescue/init:/stand/sysinstall .
+.It Va init_script
+If set to a valid file name in the root file system,
+instructs
+.Xr init 8
+to run that script as the very first action,
+before doing anything else.
+Signal handling and exit code interpretation is similar to
+running the
+.Pa /etc/rc
+script.
+In particular, single-user operation is enforced
+if the script terminates with a non-zero exit code,
+or if a SIGTERM is delivered to the
+.Xr init 8
+process (PID 1).
+.It Va init_script
+Defines the shell binary to be used for executing the various shell scripts.
+The default is
+.Dq Li /bin/sh .
+It is used for running the
+.Va init_script
+if set, as well as for the
+.Pa /etc/rc
+and
+.Pa /etc/rc.shutdown
+scripts.
+The value of the corresponding
+.Xr kenv 2
+variable is evaluated every time
+.Xr init 8
+calls a shell script, so it can be changed later on using the
+.Xr kenv 1
+utility.
+In particular, if a non-default shell is used for running an
+.Va init_script ,
+it might be desirable to have that script reset the value of
+.Va init_shell
+back to the default, so that the
+.Pa /etc/rc
+script is executed with the standard shell
+.Pa /bin/sh .
 .It Va interpret
 Has the value
 .Dq Li OK
@@ -523,20 +574,19 @@
 meta information, which directly governs the
 maximum amount of swap the system can support.
 This value is specified in bytes of KVA space
-and defaults to around 70MBytes.
+and defaults to 32MBytes on i386 and amd64.
 Care should be taken
 to not reduce this value such that the actual
 amount of configured swap exceeds 1/2 the
 kernel-supported swap.
-The default 70MB allows
-the kernel to support a maximum of (approximately)
-14GB of configured swap.
-Only mess around with
+The default of 32MB allows
+the kernel to support a maximum of ~7GB of swap.
+Only change
 this parameter if you need to greatly extend the
 KVM reservation for other resources such as the
 buffer cache or
 .Va kern.ipc.nmbclusters .
-Modifies
+Modifies kernel option
 .Dv VM_SWZONE_SIZE_MAX .
 .It Va kern.maxbcache
 Limits the amount of KVM reserved for use by the
@@ -565,6 +615,15 @@
 This overrides the value determined when the kernel was compiled.
 Modifies
 .Dv VM_KMEM_SIZE .
+.It Va vm.kmem_size_min
+.It Va vm.kmem_size_max
+Sets the minimum and maximum (respectively) amount of kernel memory
+that will be automatically allocated by the kernel.
+These override the values determined when the kernel was compiled.
+Modifies
+.Dv VM_KMEM_SIZE_MIN
+and
+.Dv VM_KMEM_SIZE_MAX .
 .El
 .Ss BUILTIN PARSER
 When a builtin command is executed, the rest of the line is taken
@@ -801,9 +860,6 @@
 .It arch-i386
 .Ic TRUE
 if the architecture is IA32.
-.It arch-alpha
-.Ic TRUE
-if the architecture is AXP.
 .It FreeBSD_version
 .Fx
 version at compile time.
Index: common/merge_help.awk
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/merge_help.awk,v
retrieving revision 1.5.14.1
diff -u -r1.5.14.1 merge_help.awk
--- common/merge_help.awk	19 Oct 2006 14:47:21 -0000	1.5.14.1
+++ common/merge_help.awk	28 Sep 2006 19:06:20 -0000
@@ -1,6 +1,6 @@
 #!/usr/bin/awk -f
 #
-# $FreeBSD: src/sys/boot/common/merge_help.awk,v 1.5.14.1 2006/10/19 14:47:21 jhb Exp $
+# $FreeBSD: src/sys/boot/common/merge_help.awk,v 1.6 2006/09/28 19:06:20 jhb Exp $
 #
 # Merge two boot loader help files for FreeBSD 3.0
 # Joe Abley <jabley@patho.gen.nz>
Index: common/module.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/module.c,v
retrieving revision 1.25.10.1
diff -u -r1.25.10.1 module.c
--- common/module.c	23 Jan 2006 14:33:53 -0000	1.25.10.1
+++ common/module.c	12 Jan 2006 13:18:49 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/module.c,v 1.25.10.1 2006/01/23 14:33:53 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/module.c,v 1.26 2006/01/12 13:18:49 marius Exp $");
 
 /*
  * file/module function dispatcher, support, etc.
Index: common/panic.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/panic.c,v
retrieving revision 1.7
diff -u -r1.7 panic.c
--- common/panic.c	25 Aug 2003 23:30:41 -0000	1.7
+++ common/panic.c	29 Sep 2006 20:57:38 -0000
@@ -34,11 +34,13 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/panic.c,v 1.7 2003/08/25 23:30:41 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/panic.c,v 1.8 2006/09/29 20:57:38 ru Exp $");
 
 #include <stand.h>
 #include <machine/stdarg.h>
 
+extern void exit(int) __dead2;
+
 void
 panic(const char *fmt,...)
 {
Index: common/pnp.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/pnp.c,v
retrieving revision 1.16
diff -u -r1.16 pnp.c
--- common/pnp.c	25 Aug 2003 23:30:41 -0000	1.16
+++ common/pnp.c	7 Jan 2007 22:25:45 -0000
@@ -4,7 +4,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/pnp.c,v 1.16 2003/08/25 23:30:41 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/pnp.c,v 1.17 2007/01/07 22:25:45 marius Exp $");
 
 /*
  * "Plug and Play" functionality.
@@ -82,52 +82,6 @@
     return(CMD_OK);
 }
 
-#if 0
-/*
- * Try to load outstanding modules (eg. after disk change)
- */
-COMMAND_SET(pnpload, "pnpload", "load modules for PnP devices", pnp_load);
-
-static int
-pnp_load(int argc, char *argv[])
-{
-    struct pnpinfo	*pi;
-    char		*modfname;
-	
-    /* find anything? */
-    if (STAILQ_FIRST(&pnp_devices) != NULL) {
-
-	/* check for kernel, assign modules handled by static drivers there */
-	if (pnp_scankernel()) {
-	    command_errmsg = "cannot load drivers until kernel loaded";
-	    return(CMD_ERROR);
-	}
-	if (fname == NULL) {
-	    /* default paths */
-	    pnp_readconf("/boot/pnpdata.local");
-	    pnp_readconf("/boot/pnpdata");
-	} else {
-	    if (pnp_readconf(fname)) {
-		sprintf(command_errbuf, "can't read PnP information from '%s'", fname);
-		return(CMD_ERROR);
-	    }
-	}
-
-	/* try to load any modules that have been nominated */
-	STAILQ_FOREACH(pi, &pnp_devices, pi_link) {
-	    /* Already loaded? */
-	    if ((pi->pi_module != NULL) && (file_findfile(pi->pi_module, NULL) == NULL)) {
-		modfname = malloc(strlen(pi->pi_module) + 4);
-		sprintf(modfname, "%s.ko", pi->pi_module);	/* XXX implicit knowledge of KLD module filenames */
-		if (mod_load(pi->pi_module, pi->pi_argc, pi->pi_argv))
-		    printf("Could not load module '%s' for device '%s'\n", modfname, STAILQ_FIRST(&pi->pi_ident)->id_ident);
-		free(modfname);
-	    }
-	}
-    }
-    return(CMD_OK);
-}
-#endif
 /*
  * Throw away anything we think we know about PnP devices.
  */
@@ -142,159 +96,7 @@
 	pnp_freeinfo(pi);
     }
 }
-#if 0
-/*
- * The PnP configuration database consists of a flat text file with 
- * entries one per line.  Valid lines are:
- *
- * # <text>
- *
- * 	This line is a comment, and ignored.
- *
- * [<name>]
- *
- *	Entries following this line are for devices connected to the
- *	bus <name>, At least one such entry must be encountered
- *	before identifiers are recognised.
- *
- * ident=<identifier> rev=<revision> module=<module> args=<arguments>
- *
- *	This line describes an identifier:module mapping.  The 'ident'
- *	and 'module' fields are required; the 'rev' field is currently
- *	ignored (but should be used), and the 'args' field must come
- *	last.
- *
- * Comments may be appended to lines; any character including or following
- * '#' on a line is ignored.
- */
-static int
-pnp_readconf(char *path)
-{
-    struct pnpinfo	*pi;
-    struct pnpident	*id;
-    int			fd, line;
-    char		lbuf[128], *currbus, *ident, *revision, *module, *args;
-    char		*cp, *ep, *tp, c;
-
-    /* try to open the file */
-    if ((fd = open(path, O_RDONLY)) >= 0) {
-	line = 0;
-	currbus = NULL;
-	
-	while (fgetstr(lbuf, sizeof(lbuf), fd) > 0) {
-	    line++;
-	    /* Find the first non-space character on the line */
-	    for (cp = lbuf; (*cp != 0) && !isspace(*cp); cp++)
-		;
-	    
-	    /* keep/discard? */
-	    if ((*cp == 0) || (*cp == '#'))
-		continue;
-
-	    /* cut trailing comment? */
-	    if ((ep = strchr(cp, '#')) != NULL)
-		*ep = 0;
-	    
-	    /* bus declaration? */
-	    if (*cp == '[') {
-		if (((ep = strchr(cp, ']')) == NULL) || ((ep - cp) < 2)) {
-		    printf("%s line %d: bad bus specification\n", path, line);
-		} else {
-		    if (currbus != NULL)
-			free(currbus);
-		    *ep = 0;
-		    currbus = strdup(cp + 1);
-		}
-		continue;
-	    }
-
-	    /* XXX should we complain? */
-	    if (currbus == NULL)
-		continue;
-
-	    /* mapping */
-	    for (ident = module = args = revision = NULL; *cp != 0;) {
-
-		/* discard leading whitespace */
-		if (isspace(*cp)) {
-		    cp++;
-		    continue;
-		}
-		
-		/* scan for terminator, separator */
-		for (ep = cp; (*ep != 0) && (*ep != '=') && !isspace(*ep); ep++)
-		    ;
-
-		if (*ep == '=') {
-		    *ep = 0;
-		    for (tp = ep + 1; (*tp != 0) && !isspace(*tp); tp++)
-			;
-		    c = *tp;
-		    *tp = 0;
-		    if ((ident == NULL) && !strcmp(cp, "ident")) {
-			ident = ep + 1;
-		    } else if ((revision == NULL) && !strcmp(cp, "revision")) {
-			revision = ep + 1;
-		    } else if ((args == NULL) && !strcmp(cp, "args")) {
-			*tp = c;
-			while (*tp != 0)		/* skip to end of string */
-			    tp++;
-			args = ep + 1;
-		    } else {
-			/* XXX complain? */
-		    }
-		    cp = tp;
-		    continue;
-		}
-		
-		/* it's garbage or a keyword - ignore it for now */
-		cp = ep;
-	    }
-
-	    /* we must have at least ident and module set to be interesting */
-	    if ((ident == NULL) || (module == NULL))
-		continue;
-	    
-	    /*
-	     * Loop looking for module/bus that might match this, but aren't already
-	     * assigned.
-	     * XXX no revision parse/test here yet.
-	     */
-	    STAILQ_FOREACH(pi, &pnp_devices, pi_link) {
-
-		/* no driver assigned, bus matches OK */
-		if ((pi->pi_module == NULL) &&
-		    !strcmp(pi->pi_handler->pp_name, currbus)) {
-
-		    /* scan idents, take first match */
-		    STAILQ_FOREACH(id, &pi->pi_ident, id_link)
-			if (!strcmp(id->id_ident, ident))
-			    break;
-			
-		    /* find a match? */
-		    if (id != NULL) {
-			if (args != NULL)
-			    if (parse(&pi->pi_argc, &pi->pi_argv, args)) {
-				printf("%s line %d: bad arguments\n", path, line);
-				continue;
-			    }
-			pi->pi_module = strdup(module);
-			printf("use module '%s' for %s:%s\n", module, pi->pi_handler->pp_name, id->id_ident);
-		    }
-		}
-	    }
-	}
-	close(fd);
-    }
-    return(CMD_OK);
-}
 
-static int
-pnp_scankernel(void)
-{
-    return(CMD_OK);
-}
-#endif
 /*
  * Add a unique identifier to (pi)
  */
Index: common/reloc_elf.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/common/reloc_elf.c,v
retrieving revision 1.1.4.1
diff -u -r1.1.4.1 reloc_elf.c
--- common/reloc_elf.c	30 Dec 2005 22:13:58 -0000	1.1.4.1
+++ common/reloc_elf.c	18 Dec 2005 04:52:35 -0000
@@ -28,7 +28,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/common/reloc_elf.c,v 1.1.4.1 2005/12/30 22:13:58 marcel Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/common/reloc_elf.c,v 1.2 2005/12/18 04:52:35 marcel Exp $");
 
 #include <sys/types.h>
 #include <machine/elf.h>
Index: efi/include/efi.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efi.h,v
retrieving revision 1.3
diff -u -r1.3 efi.h
--- efi/include/efi.h	19 May 2002 03:17:20 -0000	1.3
+++ efi/include/efi.h	2 Nov 2006 02:42:47 -0000
@@ -1,7 +1,14 @@
-/* $FreeBSD: src/sys/boot/efi/include/efi.h,v 1.3 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efi.h,v 1.4 2006/11/02 02:42:47 marcel Exp $ */
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -17,19 +24,20 @@
 
 --*/
 
-/*
- * Build flags on input
- *  EFI32
- *  EFI_DEBUG               - Enable debugging code
- *  EFI_NT_EMULATOR         - Building for running under NT
- */
+//
+// Build flags on input
+//  EFI32
+//  EFI_DEBUG               - Enable debugging code
+//  EFI_NT_EMULATOR         - Building for running under NT
+//
+
 
 #ifndef _EFI_INCLUDE_
 #define _EFI_INCLUDE_
 
 #define EFI_FIRMWARE_VENDOR         L"INTEL"
-#define EFI_FIRMWARE_MAJOR_REVISION 12
-#define EFI_FIRMWARE_MINOR_REVISION 33
+#define EFI_FIRMWARE_MAJOR_REVISION 14
+#define EFI_FIRMWARE_MINOR_REVISION 62
 #define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))
 
 #include "efibind.h"
@@ -43,7 +51,12 @@
 #include "efinet.h"
 #include "efiapi.h"
 #include "efifs.h"
-#include "efifpswa.h"
 #include "efierr.h"
 
+#define EFI_STRINGIZE(a)                #a 
+#define EFI_PROTOCOL_DEFINITION(a)      EFI_STRINGIZE(Protocol/a/a.h) 
+
+#define EFI_GUID_DEFINITION(a) EFI_STRINGIZE(Guid/a/a##.h) 
+#define EFI_GUID_STRING(guidpointer, shortstring, longstring)
+
 #endif
Index: efi/include/efi_nii.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efi_nii.h,v
retrieving revision 1.2
diff -u -r1.2 efi_nii.h
--- efi/include/efi_nii.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efi_nii.h	2 Nov 2006 02:42:47 -0000
@@ -1,9 +1,16 @@
-/* $FreeBSD: src/sys/boot/efi/include/efi_nii.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efi_nii.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_NII_H
 #define _EFI_NII_H
 
 /*++
-Copyright (c) 2000  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module name:
     efi_nii.h
@@ -20,8 +27,11 @@
 
 #define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL \
     { 0xE18541CD, 0xF755, 0x4f73, 0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29 }
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL_31 \
+    { 0x1ACED566, 0x76ED, 0x4218, 0xBC, 0x81, 0x76, 0x7F, 0x1F, 0x97, 0x7A, 0x89 }
 
 #define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION 0x00010000
+#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION_31 0x00010001
 
 typedef enum {
     EfiNetworkInterfaceUndi = 1
@@ -29,54 +39,48 @@
 
 typedef struct {
 
-	/* Revision of the network interface identifier protocol interface. */
     UINT64 Revision;
+    // Revision of the network interface identifier protocol interface.
 
-	/*
-	 * Address of the first byte of the identifying structure for this
-	 * network interface.  This is set to zero if there is no structure.
-	 * For PXE/UNDI this is the first byte of the !PXE structure.
-	 */
     UINT64 ID;
+    // Address of the first byte of the identifying structure for this
+    // network interface.  This is set to zero if there is no structure.
+    //
+    // For PXE/UNDI this is the first byte of the !PXE structure.
 
-	/*
-	 * Address of the UNrelocated driver/ROM image.  This is set
-	 * to zero if there is no driver/ROM image.
-	 * For 16-bit UNDI, this is the first byte of the option ROM in
-	 * upper memory.
-	 * For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
-	 * image.
-	 * For H/W UNDI, this is set to zero.
-	 */
     UINT64 ImageAddr;
+    // Address of the UNrelocated driver/ROM image.  This is set
+    // to zero if there is no driver/ROM image.
+    //
+    // For 16-bit UNDI, this is the first byte of the option ROM in
+    // upper memory.
+    //
+    // For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
+    // image.
+    //
+    // For H/W UNDI, this is set to zero.
 
-	/*
-	 * Size of the UNrelocated driver/ROM image of this network interface.
-	 * This is set to zero if there is no driver/ROM image.
-	 */
     UINT32 ImageSize;
+    // Size of the UNrelocated driver/ROM image of this network interface.
+    // This is set to zero if there is no driver/ROM image.
 
-	/*
-	 * 4 char ASCII string to go in class identifier (option 60) in DHCP
-	 * and Boot Server discover packets.
-	 * For EfiNetworkInterfaceUndi this field is "UNDI".
-	 * For EfiNetworkInterfaceSnp this field is "SNPN".
-	 */
     CHAR8 StringId[4];
+    // 4 char ASCII string to go in class identifier (option 60) in DHCP
+    // and Boot Server discover packets.
+    // For EfiNetworkInterfaceUndi this field is "UNDI".
+    // For EfiNetworkInterfaceSnp this field is "SNPN".
 
-	/*
-	 * Information to be placed into the PXE DHCP and Discover packets.
-	 * This is the network interface type and version number that will
-	 * be placed into DHCP option 94 (client network interface identifier).
-	 */
     UINT8 Type;
     UINT8 MajorVer;
     UINT8 MinorVer;
-
+    // Information to be placed into the PXE DHCP and Discover packets.
+    // This is the network interface type and version number that will
+    // be placed into DHCP option 94 (client network interface identifier).
     BOOLEAN Ipv6Supported;
-	UINT8   IfNum;	/* interface number to be used with pxeid structure */
+	UINT8   IfNum;	// interface number to be used with pxeid structure
 } EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;
 
 extern EFI_GUID NetworkInterfaceIdentifierProtocol;
+extern EFI_GUID NetworkInterfaceIdentifierProtocol_31;
 
-#endif /* _EFI_NII_H */
+#endif // _EFI_NII_H
Index: efi/include/efiapi.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efiapi.h,v
retrieving revision 1.6
diff -u -r1.6 efiapi.h
--- efi/include/efiapi.h	10 Dec 2003 19:08:09 -0000	1.6
+++ efi/include/efiapi.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efiapi.h,v 1.6 2003/12/10 19:08:09 jhb Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efiapi.h,v 1.7 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_API_H
 #define _EFI_API_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -21,22 +28,22 @@
 
 --*/
 
-/*
- * EFI Specification Revision
- */
+//
+// EFI Specification Revision
+//
 
 #define EFI_SPECIFICATION_MAJOR_REVISION 1
-#define EFI_SPECIFICATION_MINOR_REVISION 02
+#define EFI_SPECIFICATION_MINOR_REVISION 10
 
-/*
- * Declare forward referenced data structures
- */
+//
+// Declare forward referenced data structures
+//
 
 INTERFACE_DECL(_EFI_SYSTEM_TABLE);
 
-/*
- * EFI Memory
- */
+//
+// EFI Memory
+//
 
 typedef
 EFI_STATUS
@@ -92,8 +99,8 @@
 
 
 #define EFI_OPTIONAL_PTR            0x00000001
-#define EFI_INTERNAL_FNC            0x00000002      /* Pointer to internal runtime fnc */
-#define EFI_INTERNAL_PTR            0x00000004      /* Pointer to internal runtime data */
+#define EFI_INTERNAL_FNC            0x00000002      // Pointer to internal runtime fnc
+#define EFI_INTERNAL_PTR            0x00000004      // Pointer to internal runtime data
 
 
 typedef 
@@ -104,9 +111,9 @@
     );
 
 
-/*
- * EFI Events
- */
+//
+// EFI Events
+//
 
 
 
@@ -181,9 +188,9 @@
     IN EFI_EVENT                Event
     );
 
-/*
- * Task priority level
- */
+//
+// Task priority level
+//
 
 #define TPL_APPLICATION    4
 #define TPL_CALLBACK       8
@@ -203,19 +210,19 @@
     );
 
 
-/*
- * EFI platform variables
- */
+//
+// EFI platform varibles
+//
 
 #define EFI_GLOBAL_VARIABLE     \
     { 0x8BE4DF61, 0x93CA, 0x11d2, 0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C }
 
-/* Variable attributes */
+// Variable attributes
 #define EFI_VARIABLE_NON_VOLATILE           0x00000001
 #define EFI_VARIABLE_BOOTSERVICE_ACCESS     0x00000002
 #define EFI_VARIABLE_RUNTIME_ACCESS         0x00000004
 
-/* Variable size limitation */
+// Variable size limitation
 #define EFI_MAXIMUM_VARIABLE_SIZE           1024
 
 typedef
@@ -248,14 +255,14 @@
     );
 
 
-/*
- * EFI Time
- */
+//
+// EFI Time
+//
 
 typedef struct {
-        UINT32              Resolution;     /* 1e-6 parts per million */
-        UINT32              Accuracy;       /* hertz */
-        BOOLEAN             SetsToZero;     /* Set clears sub-second time */
+        UINT32                      Resolution;     // 1e-6 parts per million
+        UINT32                      Accuracy;       // hertz
+        BOOLEAN                     SetsToZero;     // Set clears sub-second time
 } EFI_TIME_CAPABILITIES;
 
 
@@ -288,12 +295,12 @@
     );
 
 
-/*
- * Image functions
- */
+//
+// Image functions
+//
 
 
-/* PE32+ Subsystem type for EFI images */
+// PE32+ Subsystem type for EFI images
 
 #if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
 #define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
@@ -301,7 +308,7 @@
 #define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
 #endif
 
-/* PE32+ Machine type for EFI images */
+// PE32+ Machine type for EFI images
 
 #if !defined(EFI_IMAGE_MACHINE_IA32)
 #define EFI_IMAGE_MACHINE_IA32      0x014c
@@ -311,7 +318,11 @@
 #define EFI_IMAGE_MACHINE_IA64      0x0200
 #endif
 
-/* Image Entry prototype */
+#if !defined(EFI_IMAGE_MACHINE_EBC)
+#define EFI_IMAGE_MACHINE_EBC       0x0EBC
+#endif
+
+// Image Entry prototype
 
 typedef 
 EFI_STATUS
@@ -355,32 +366,32 @@
     );
 
 
-/* Image handle */
+// Image handle
 #define LOADED_IMAGE_PROTOCOL      \
     { 0x5B1B31A1, 0x9562, 0x11d2, 0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B }
 
-#define EFI_IMAGE_INFORMATION_REVISION      0x1000
+#define EFI_LOADED_IMAGE_INFORMATION_REVISION      0x1000
 typedef struct {
     UINT32                          Revision;
     EFI_HANDLE                      ParentHandle;
     struct _EFI_SYSTEM_TABLE        *SystemTable;
 
-	/* Source location of image */
+    // Source location of image
     EFI_HANDLE                      DeviceHandle;
     EFI_DEVICE_PATH                 *FilePath;
     VOID                            *Reserved;
 
-	/* Images load options */
+    // Images load options
     UINT32                          LoadOptionsSize;
     VOID                            *LoadOptions;
 
-	/* Location of where image was loaded */
+    // Location of where image was loaded
     VOID                            *ImageBase;
     UINT64                          ImageSize;
     EFI_MEMORY_TYPE                 ImageCodeType;
     EFI_MEMORY_TYPE                 ImageDataType;
 
-	/* If the driver image supports a dynamic unload request */
+    // If the driver image supports a dynamic unload request
     EFI_IMAGE_UNLOAD                Unload;
 
 } EFI_LOADED_IMAGE;
@@ -393,9 +404,9 @@
     IN UINTN                        MapKey
     );
 
-/*
- * Misc
- */
+//
+// Misc
+//
 
 
 typedef
@@ -416,11 +427,12 @@
 
 typedef enum {
     EfiResetCold,
-    EfiResetWarm
+    EfiResetWarm,
+    EfiResetShutdown
 } EFI_RESET_TYPE;
 
 typedef
-EFI_STATUS
+VOID
 (EFIAPI *EFI_RESET_SYSTEM) (
     IN EFI_RESET_TYPE           ResetType,
     IN EFI_STATUS               ResetStatus,
@@ -440,13 +452,12 @@
     OUT UINT32                  *HighCount
     );
 
-/*
- * Protocol handler functions
- */
+//
+// Protocol handler functions
+//
 
 typedef enum {
-    EFI_NATIVE_INTERFACE,
-    EFI_PCODE_INTERFACE
+    EFI_NATIVE_INTERFACE
 } EFI_INTERFACE_TYPE;
 
 typedef
@@ -525,179 +536,355 @@
 typedef
 EFI_STATUS
 (EFIAPI *EFI_RESERVED_SERVICE) (
-    VOID
     );
 
-/*
- * Standard EFI table header
- */
-
-typedef struct _EFI_TABLE_HEARDER {
-    UINT64                      Signature;
-    UINT32                      Revision;
-    UINT32                      HeaderSize;
-    UINT32                      CRC32;
-    UINT32                      Reserved;
-} EFI_TABLE_HEADER;
-
-
-/*
- * EFI Runtime Serivces Table
- */
-
-#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552
-#define EFI_RUNTIME_SERVICES_REVISION   (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+typedef
+EFI_STATUS 
+(EFIAPI *EFI_CONNECT_CONTROLLER) (
+  IN  EFI_HANDLE                    ControllerHandle,
+  IN  EFI_HANDLE                    *DriverImageHandle    OPTIONAL,
+  IN  EFI_DEVICE_PATH               *RemainingDevicePath  OPTIONAL,
+  IN  BOOLEAN                       Recursive
+  );
 
-typedef struct  {
-    EFI_TABLE_HEADER                Hdr;
+typedef
+EFI_STATUS 
+(EFIAPI *EFI_DISCONNECT_CONTROLLER)(
+  IN EFI_HANDLE           ControllerHandle,
+  IN EFI_HANDLE           DriverImageHandle, OPTIONAL
+  IN EFI_HANDLE           ChildHandle        OPTIONAL
+  );    
+
+#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL	 0x00000001  
+#define EFI_OPEN_PROTOCOL_GET_PROTOCOL	       0x00000002  
+#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL        0x00000004  
+#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER  0x00000008  
+#define EFI_OPEN_PROTOCOL_BY_DRIVER            0x00000010  
+#define EFI_OPEN_PROTOCOL_EXCLUSIVE            0x00000020  
 
-	/* Time services */
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL) (
+  IN EFI_HANDLE                 Handle,
+  IN EFI_GUID                   *Protocol,
+  OUT VOID                      **Interface,
+  IN  EFI_HANDLE                ImageHandle,
+  IN  EFI_HANDLE                ControllerHandle, OPTIONAL
+  IN  UINT32                    Attributes
+  );
 
-    EFI_GET_TIME                    GetTime;
-    EFI_SET_TIME                    SetTime;
-    EFI_GET_WAKEUP_TIME             GetWakeupTime;
-    EFI_SET_WAKEUP_TIME             SetWakeupTime;
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_PROTOCOL) (
+  IN EFI_HANDLE               Handle,
+  IN EFI_GUID                 *Protocol,
+  IN EFI_HANDLE               ImageHandle,
+  IN EFI_HANDLE               DeviceHandle
+  );
 
-	/* Virtual memory services */
+typedef struct {
+  EFI_HANDLE                  AgentHandle;
+  EFI_HANDLE                  ControllerHandle;
+  UINT32                      Attributes;
+  UINT32                      OpenCount;
+} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
 
-    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
-    EFI_CONVERT_POINTER             ConvertPointer;
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION) (
+  IN  EFI_HANDLE                          UserHandle,
+  IN  EFI_GUID                            *Protocol,
+  IN  EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
+  OUT UINTN                               *EntryCount
+  );
 
-	/* Variable serviers */
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PROTOCOLS_PER_HANDLE) (
+  IN EFI_HANDLE       UserHandle,
+  OUT EFI_GUID        ***ProtocolBuffer,
+  OUT UINTN           *ProtocolBufferCount
+  );
 
-    EFI_GET_VARIABLE                GetVariable;
-    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
-    EFI_SET_VARIABLE                SetVariable;
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE_BUFFER) (
+  IN EFI_LOCATE_SEARCH_TYPE       SearchType,
+  IN EFI_GUID                     *Protocol OPTIONAL,
+  IN VOID                         *SearchKey OPTIONAL,
+  IN OUT UINTN                    *NumberHandles,
+  OUT EFI_HANDLE                  **Buffer
+  );
 
-	/* Misc */
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_PROTOCOL) (
+  EFI_GUID  *Protocol,
+  VOID      *Registration, OPTIONAL
+  VOID      **Interface
+  );
 
-    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
-    EFI_RESET_SYSTEM                ResetSystem;
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+  IN OUT EFI_HANDLE           *Handle,
+  ...
+  );
 
-} EFI_RUNTIME_SERVICES;
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+  IN EFI_HANDLE           Handle,
+  ...
+  );
 
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CALCULATE_CRC32) (
+  IN  VOID                              *Data,
+  IN  UINTN                             DataSize,
+  OUT UINT32                            *Crc32
+  );
 
-/*
- * EFI Boot Services Table
- */
+typedef
+VOID
+(EFIAPI *EFI_COPY_MEM) (
+  IN VOID     *Destination,
+  IN VOID     *Source,
+  IN UINTN    Length
+  );
 
-#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
-#define EFI_BOOT_SERVICES_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+typedef
+VOID
+(EFIAPI *EFI_SET_MEM) (
+  IN VOID     *Buffer,
+  IN UINTN    Size,
+  IN UINT8    Value
+  );
+
+//
+// Standard EFI table header
+//
 
-typedef struct _EFI_BOOT_SERVICES {
+typedef struct _EFI_TABLE_HEARDER {
+  UINT64                      Signature;
+  UINT32                      Revision;
+  UINT32                      HeaderSize;
+  UINT32                      CRC32;
+  UINT32                      Reserved;
+} EFI_TABLE_HEADER;
 
-    EFI_TABLE_HEADER                Hdr;
 
-	/* Task priority functions */
+//
+// EFI Runtime Serivces Table
+//
 
-    EFI_RAISE_TPL                   RaiseTPL;
-    EFI_RESTORE_TPL                 RestoreTPL;
+#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552
+#define EFI_RUNTIME_SERVICES_REVISION   ((EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION))
 
-	/* Memory functions */
+typedef struct  {
+  EFI_TABLE_HEADER                Hdr;
 
-    EFI_ALLOCATE_PAGES              AllocatePages;
-    EFI_FREE_PAGES                  FreePages;
-    EFI_GET_MEMORY_MAP              GetMemoryMap;
-    EFI_ALLOCATE_POOL               AllocatePool;
-    EFI_FREE_POOL                   FreePool;
+  //
+  // Time services
+  //
+
+  EFI_GET_TIME                    GetTime;
+  EFI_SET_TIME                    SetTime;
+  EFI_GET_WAKEUP_TIME             GetWakeupTime;
+  EFI_SET_WAKEUP_TIME             SetWakeupTime;
+
+  //
+  // Virtual memory services
+  //
+
+  EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
+  EFI_CONVERT_POINTER             ConvertPointer;
+
+  //
+  // Variable serviers
+  //
+
+  EFI_GET_VARIABLE                GetVariable;
+  EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
+  EFI_SET_VARIABLE                SetVariable;
+
+  //
+  // Misc
+  //
 
-	/* Event & timer functions */
+  EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
+  EFI_RESET_SYSTEM                ResetSystem;
 
-    EFI_CREATE_EVENT                CreateEvent;
-    EFI_SET_TIMER                   SetTimer;
-    EFI_WAIT_FOR_EVENT              WaitForEvent;
-    EFI_SIGNAL_EVENT                SignalEvent;
-    EFI_CLOSE_EVENT                 CloseEvent;
-    EFI_CHECK_EVENT                 CheckEvent;
+} EFI_RUNTIME_SERVICES;
 
-	/* Protocol handler functions */
 
-    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
-    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
-    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
-    EFI_HANDLE_PROTOCOL             HandleProtocol;
-    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
-    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
-    EFI_LOCATE_HANDLE               LocateHandle;
-    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
-    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;
+//
+// EFI Boot Services Table
+//
 
-	/* Image functions */
+#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
+#define EFI_BOOT_SERVICES_REVISION      ((EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION))
 
-    EFI_IMAGE_LOAD                  LoadImage;
-    EFI_IMAGE_START                 StartImage;
-    EFI_EXIT                        Exit;
-    EFI_IMAGE_UNLOAD                UnloadImage;
-    EFI_EXIT_BOOT_SERVICES          ExitBootServices;
+typedef struct {
 
-	/* Misc functions */
+  EFI_TABLE_HEADER                Hdr;
 
-    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
-    EFI_STALL                       Stall;
-    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;
+  //
+  // Task priority functions
+  //
+
+  EFI_RAISE_TPL                   RaiseTPL;
+  EFI_RESTORE_TPL                 RestoreTPL;
+
+  //
+  // Memory functions
+  //
+
+  EFI_ALLOCATE_PAGES              AllocatePages;
+  EFI_FREE_PAGES                  FreePages;
+  EFI_GET_MEMORY_MAP              GetMemoryMap;
+  EFI_ALLOCATE_POOL               AllocatePool;
+  EFI_FREE_POOL                   FreePool;
+
+  //
+  // Event & timer functions
+  //
+
+  EFI_CREATE_EVENT                CreateEvent;
+  EFI_SET_TIMER                   SetTimer;
+  EFI_WAIT_FOR_EVENT              WaitForEvent;
+  EFI_SIGNAL_EVENT                SignalEvent;
+  EFI_CLOSE_EVENT                 CloseEvent;
+  EFI_CHECK_EVENT                 CheckEvent;
+
+  //
+  // Protocol handler functions
+  //
+
+  EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
+  EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
+  EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
+  EFI_HANDLE_PROTOCOL             HandleProtocol;
+  VOID                            *Reserved;
+  EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
+  EFI_LOCATE_HANDLE               LocateHandle;
+  EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
+  EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;
+
+  //
+  // Image functions
+  //
+
+  EFI_IMAGE_LOAD                  LoadImage;
+  EFI_IMAGE_START                 StartImage;
+  EFI_EXIT                        Exit;
+  EFI_IMAGE_UNLOAD                UnloadImage;
+  EFI_EXIT_BOOT_SERVICES          ExitBootServices;
+
+  //
+  // Misc functions
+  //
+
+  EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
+  EFI_STALL                       Stall;
+  EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;
+
+  //
+  // DriverSupport Services
+  //
+  EFI_CONNECT_CONTROLLER	        ConnectController;
+  EFI_DISCONNECT_CONTROLLER       DisconnectController;
+
+  //
+  // Open and Close Protocol Services
+  //
+  EFI_OPEN_PROTOCOL               OpenProtocol;
+  EFI_CLOSE_PROTOCOL              CloseProtocol;
+  EFI_OPEN_PROTOCOL_INFORMATION   OpenProtocolInformation;
+
+  //
+  // Library Services to reduce size of drivers
+  //
+  EFI_PROTOCOLS_PER_HANDLE        ProtocolsPerHandle;
+  EFI_LOCATE_HANDLE_BUFFER        LocateHandleBuffer;
+  EFI_LOCATE_PROTOCOL             LocateProtocol;    
+
+  EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES    InstallMultipleProtocolInterfaces;
+  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES  UninstallMultipleProtocolInterfaces;
+
+  //
+  // CRC32 services
+  //
+  EFI_CALCULATE_CRC32             CalculateCrc32;
+
+  //
+  // Memory Utility Services
+  //
+  EFI_COPY_MEM                    CopyMem;
+  EFI_SET_MEM                     SetMem;
 
 } EFI_BOOT_SERVICES;
 
 
-/*
- * EFI Configuration Table and GUID definitions
- */
+//
+// EFI Configuration Table and GUID definitions
+//
 
 #define MPS_TABLE_GUID    \
-    { 0xeb9d2d2f, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } }
+  { 0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }
 
 #define ACPI_TABLE_GUID    \
-    { 0xeb9d2d30, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } }
+  { 0xeb9d2d30, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }
 
 #define ACPI_20_TABLE_GUID  \
-    { 0x8868e871, 0xe4f1, 0x11d3, { 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } }
+  { 0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }
 
 #define SMBIOS_TABLE_GUID    \
-    { 0xeb9d2d31, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } }
+  { 0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }
 
 #define SAL_SYSTEM_TABLE_GUID    \
-    { 0xeb9d2d32, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } }
+  { 0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }
 
-/* DIG64 Headless Console & Debug Port Table. */
-#define	HCDP_TABLE_GUID		\
-	{0xf951938d,0x620b,0x42ef,{0x82,0x79,0xa8,0x4b,0x79,0x61,0x78,0x98}}
 
 typedef struct _EFI_CONFIGURATION_TABLE {
-    EFI_GUID                VendorGuid;
-    VOID                    *VendorTable;
+  EFI_GUID                VendorGuid;
+  VOID                    *VendorTable;
 } EFI_CONFIGURATION_TABLE;
 
 
-/*
- * EFI System Table
- */
+//
+// EFI System Table
+//
 
 
 
 
 #define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249
-#define EFI_SYSTEM_TABLE_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+#define EFI_SYSTEM_TABLE_REVISION      ((EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION))
+#define EFI_1_10_SYSTEM_TABLE_REVISION ((1<<16) | 10)
+#define EFI_1_02_SYSTEM_TABLE_REVISION ((1<<16) | 02)
 
 typedef struct _EFI_SYSTEM_TABLE {
-    EFI_TABLE_HEADER                Hdr;
+  EFI_TABLE_HEADER                Hdr;
 
-    CHAR16                          *FirmwareVendor;
-    UINT32                          FirmwareRevision;
+  CHAR16                          *FirmwareVendor;
+  UINT32                          FirmwareRevision;
 
-    EFI_HANDLE                      ConsoleInHandle;
-    SIMPLE_INPUT_INTERFACE          *ConIn;
+  EFI_HANDLE                      ConsoleInHandle;
+  SIMPLE_INPUT_INTERFACE          *ConIn;
 
-    EFI_HANDLE                      ConsoleOutHandle;
-    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
+  EFI_HANDLE                      ConsoleOutHandle;
+  SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
 
-    EFI_HANDLE                      StandardErrorHandle;
-    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;
+  EFI_HANDLE                      StandardErrorHandle;
+  SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;
 
-    EFI_RUNTIME_SERVICES            *RuntimeServices;
-    EFI_BOOT_SERVICES               *BootServices;
+  EFI_RUNTIME_SERVICES            *RuntimeServices;
+  EFI_BOOT_SERVICES               *BootServices;
 
-    UINTN                           NumberOfTableEntries;
-    EFI_CONFIGURATION_TABLE         *ConfigurationTable;
+  UINTN                           NumberOfTableEntries;
+  EFI_CONFIGURATION_TABLE         *ConfigurationTable;
 
 } EFI_SYSTEM_TABLE;
 
Index: efi/include/eficon.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/eficon.h,v
retrieving revision 1.2
diff -u -r1.2 eficon.h
--- efi/include/eficon.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/eficon.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/eficon.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/eficon.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_CON_H
 #define _EFI_CON_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -20,9 +27,9 @@
 
 --*/
 
-/*
- * Text output protocol
- */
+//
+// Text output protocol
+//
 
 #define SIMPLE_TEXT_OUTPUT_PROTOCOL \
     { 0x387477c2, 0x69c7, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
@@ -126,7 +133,7 @@
 
 typedef struct {
     INT32                           MaxMode;
-	/* current settings */
+    // current settings
     INT32                           Mode;
     INT32                           Attribute;
     INT32                           CursorColumn;
@@ -148,13 +155,13 @@
     EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
     EFI_TEXT_ENABLE_CURSOR          EnableCursor;
 
-	/* Current mode */
+    // Current mode
     SIMPLE_TEXT_OUTPUT_MODE         *Mode;
 } SIMPLE_TEXT_OUTPUT_INTERFACE;
 
-/*
- * Define's for required EFI Unicode Box Draw character
- */
+//
+// Define's for required EFI Unicode Box Draw character
+//
 
 #define BOXDRAW_HORIZONTAL                  0x2500
 #define BOXDRAW_VERTICAL                    0x2502
@@ -206,29 +213,31 @@
 #define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
 #define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c
 
-/*
- * EFI Required Block Elements Code Chart
- */
+//
+// EFI Required Block Elements Code Chart
+//
+
 #define BLOCKELEMENT_FULL_BLOCK             0x2588
 #define BLOCKELEMENT_LIGHT_SHADE            0x2591
+//
+// EFI Required Geometric Shapes Code Chart
+//
 
-/*
- * EFI Required Geometric Shapes Code Chart
- */
 #define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
 #define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
 #define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
 #define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4
 
-/*
- * EFI Required Arrow shapes
- */
+//
+// EFI Required Arrow shapes
+//
+
 #define ARROW_UP                            0x2191
 #define ARROW_DOWN                          0x2193
 
-/*
- * Text input protocol
- */
+//
+// Text input protocol
+//
 
 #define SIMPLE_TEXT_INPUT_PROTOCOL  \
     { 0x387477c1, 0x69c7, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
@@ -240,9 +249,9 @@
     CHAR16                              UnicodeChar;
 } EFI_INPUT_KEY;
 
-/*
- * Baseline unicode control chars
- */
+//
+// Baseline unicode control chars
+//
 
 #define CHAR_NULL                       0x0000
 #define CHAR_BACKSPACE                  0x0008
@@ -250,9 +259,10 @@
 #define CHAR_LINEFEED                   0x000A
 #define CHAR_CARRIAGE_RETURN            0x000D
 
-/*
- * Scan codes for base line keys
- */
+//
+// Scan codes for base line keys
+//
+
 #define SCAN_NULL                       0x0000
 #define SCAN_UP                         0x0001
 #define SCAN_DOWN                       0x0002
Index: efi/include/efidebug.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efidebug.h,v
retrieving revision 1.2
diff -u -r1.2 efidebug.h
--- efi/include/efidebug.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efidebug.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efidebug.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efidebug.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_DEBUG_H
 #define _EFI_DEBUG_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -44,32 +51,38 @@
 
 #endif
 
-#define D_INIT        0x00000001          /* Initialization style messages */
-#define D_WARN        0x00000002          /* Warnings */
-#define D_LOAD        0x00000004          /* Load events */
-#define D_FS          0x00000008          /* EFI File system */
-#define D_POOL        0x00000010          /* Alloc & Free's */
-#define D_PAGE        0x00000020          /* Alloc & Free's */
-#define D_INFO        0x00000040          /* Verbose */
-#define D_VAR         0x00000100          /* Variable */
-#define D_PARSE       0x00000200          /* Command parsing */
-#define D_BM          0x00000400          /* Boot manager */
-#define D_BLKIO       0x00001000          /* BlkIo Driver */
-#define D_BLKIO_ULTRA 0x00002000          /* BlkIo Driver */
-#define D_NET         0x00004000          /* SNI Driver */
-#define D_NET_ULTRA   0x00008000          /* SNI Driver */
-#define D_TXTIN       0x00010000          /* Simple Input Driver */
-#define D_TXTOUT      0x00020000          /* Simple Text Output Driver */
-#define D_ERROR_ATA   0x00040000	  /* ATA error messages */
-#define D_ERROR       0x80000000          /* Error */
-
-#define D_RESERVED    0x7fffC880          /* Bits not reserved above */
-
-/*
- * Current Debug level of the system, value of EFIDebug
- */
+#define D_INIT        0x00000001          // Initialization style messages
+#define D_WARN        0x00000002          // Warnings
+#define D_LOAD        0x00000004          // Load events
+#define D_FS          0x00000008          // EFI File system
+#define D_POOL        0x00000010          // Alloc & Free's
+#define D_PAGE        0x00000020          // Alloc & Free's
+#define D_INFO        0x00000040          // Verbose
+#define D_VARIABLE    0x00000100          // Variable
+#define D_VAR         0x00000100          // Variable
+#define D_BM          0x00000400          // Boot Manager 
+#define D_BLKIO       0x00001000          // BlkIo Driver
+#define D_BLKIO_ULTRA 0x00002000          // BlkIo Driver
+#define D_NET         0x00004000          // SNI Driver
+#define D_NET_ULTRA   0x00008000          // SNI Driver
+#define D_UNDI        0x00010000          // UNDI Driver
+#define D_LOADFILE    0x00020000          // UNDI Driver
+#define D_EVENT       0x00080000          // Event messages
+
+#define D_ERROR       0x80000000          // Error
+
+#define D_RESERVED    0x7ff40A80          // Bits not reserved above
+
+//
+// Current Debug level of the system, value of EFIDebug
+//
+//#define EFI_DBUG_MASK   (D_ERROR | D_WARN | D_LOAD | D_BLKIO | D_INIT)
 #define EFI_DBUG_MASK   (D_ERROR)
 
+//
+//
+//
+
 #if EFI_DEBUG
 
     #define ASSERT(a)               if(!(a))       DBGASSERT(a)
@@ -84,9 +97,9 @@
 
 #endif
 
-/*
- * Prototypes
- */
+//
+// Prototypes
+//
 
 INTN
 DbgAssert (
Index: efi/include/efidef.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efidef.h,v
retrieving revision 1.2
diff -u -r1.2 efidef.h
--- efi/include/efidef.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efidef.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efidef.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efidef.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_DEF_H
 #define _EFI_DEF_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -41,14 +48,14 @@
 typedef VOID            *EFI_EVENT;
 
 
-/*
- * Prototype argument decoration for EFI parameters to indicate
- * their direction
- *
- * IN - argument is passed into the function
- * OUT - argument (pointer) is returned from the function
- * OPTIONAL - argument is optional
- */
+//
+// Prototype argument decoration for EFI parameters to indicate
+// their direction
+//
+// IN - argument is passed into the function
+// OUT - argument (pointer) is returned from the function
+// OPTIONAL - argument is optional
+//
 
 #ifndef IN
     #define IN
@@ -57,9 +64,9 @@
 #endif
 
 
-/*
- * A GUID
- */
+//
+// A GUID
+//
 
 typedef struct {          
     UINT32  Data1;
@@ -69,36 +76,36 @@
 } EFI_GUID;
 
 
-/*
- * Time
- */
+//
+// Time
+//
 
 typedef struct {          
-	UINT16      Year;       /* 1998 - 20XX */
-	UINT8       Month;      /* 1 - 12 */
-	UINT8       Day;        /* 1 - 31 */
-	UINT8       Hour;       /* 0 - 23 */
-	UINT8       Minute;     /* 0 - 59 */
-	UINT8       Second;     /* 0 - 59 */
-	UINT8       Pad1;
-	UINT32      Nanosecond; /* 0 - 999,999,999 */
-	INT16       TimeZone;   /* -1440 to 1440 or 2047 */
-	UINT8       Daylight;
-	UINT8       Pad2;
+    UINT16      Year;       // 1998 - 20XX
+    UINT8       Month;      // 1 - 12
+    UINT8       Day;        // 1 - 31
+    UINT8       Hour;       // 0 - 23
+    UINT8       Minute;     // 0 - 59
+    UINT8       Second;     // 0 - 59
+    UINT8       Pad1;
+    UINT32      Nanosecond; // 0 - 999,999,999
+    INT16       TimeZone;   // -1440 to 1440 or 2047
+    UINT8       Daylight;
+    UINT8       Pad2;
 } EFI_TIME;
 
-/* Bit definitions for EFI_TIME.Daylight */
+// Bit definitions for EFI_TIME.Daylight
 #define EFI_TIME_ADJUST_DAYLIGHT    0x01
 #define EFI_TIME_IN_DAYLIGHT        0x02
 
-/* Value definition for EFI_TIME.TimeZone */
+// Value definition for EFI_TIME.TimeZone
 #define EFI_UNSPECIFIED_TIMEZONE    0x07FF
 
 
 
-/*
- * Networking
- */
+//
+// Networking
+//
 
 typedef struct {
     UINT8                   Addr[4];
@@ -112,9 +119,9 @@
     UINT8                   Addr[32];
 } EFI_MAC_ADDRESS;
 
-/*
- * Memory
- */
+//
+// Memory
+//
 
 typedef UINT64          EFI_PHYSICAL_ADDRESS;
 typedef UINT64          EFI_VIRTUAL_ADDRESS;
@@ -126,13 +133,12 @@
     MaxAllocateType
 } EFI_ALLOCATE_TYPE;
 
-/*
- * Preseve the attr on any range supplied.
- * ConventialMemory must have WB,SR,SW when supplied.
- * When allocating from ConventialMemory always make it WB,SR,SW
- * When returning to ConventialMemory always make it WB,SR,SW
- * When getting the memory map, or on RT for runtime types
- */
+//Preseve the attr on any range supplied.
+//ConventialMemory must have WB,SR,SW when supplied.
+//When allocating from ConventialMemory always make it WB,SR,SW
+//When returning to ConventialMemory always make it WB,SR,SW
+//When getting the memory map, or on RT for runtime types
+
 
 typedef enum {
     EfiReservedMemoryType,
@@ -152,42 +158,46 @@
     EfiMaxMemoryType
 } EFI_MEMORY_TYPE;
 
-/* possible caching types for the memory range */
+// possible caching types for the memory range
 #define EFI_MEMORY_UC           0x0000000000000001
 #define EFI_MEMORY_WC           0x0000000000000002
 #define EFI_MEMORY_WT           0x0000000000000004
 #define EFI_MEMORY_WB           0x0000000000000008
 #define EFI_MEMORY_UCE          0x0000000000000010  
 
-/* physical memory protection on range */
+// physical memory protection on range 
 #define EFI_MEMORY_WP           0x0000000000001000
 #define EFI_MEMORY_RP           0x0000000000002000
 #define EFI_MEMORY_XP           0x0000000000004000
 
-/* range requires a runtime mapping */
+// range requires a runtime mapping
 #define EFI_MEMORY_RUNTIME      0x8000000000000000
 
 #define EFI_MEMORY_DESCRIPTOR_VERSION  1
 typedef struct {
-	UINT32                          Type;           /* 32 bit padding */
-	EFI_PHYSICAL_ADDRESS            PhysicalStart;
-	EFI_VIRTUAL_ADDRESS             VirtualStart;
-	UINT64                          NumberOfPages;
-	UINT64                          Attribute;
+    UINT32                          Type;           // Field size is 32 bits followed by 32 bit pad
+    EFI_PHYSICAL_ADDRESS            PhysicalStart;  // Field size is 64 bits
+    EFI_VIRTUAL_ADDRESS             VirtualStart;   // Field size is 64 bits
+    UINT64                          NumberOfPages;  // Field size is 64 bits
+    UINT64                          Attribute;      // Field size is 64 bits
 } EFI_MEMORY_DESCRIPTOR;
 
-/*
- * International Language
- */
+//
+// International Language
+//
 
 typedef UINT8   ISO_639_2;
 #define ISO_639_2_ENTRY_SIZE    3
 
+//
+//
+//
+
 #define EFI_PAGE_SIZE   4096
 #define EFI_PAGE_MASK   0xFFF
 #define EFI_PAGE_SHIFT  12
 
 #define EFI_SIZE_TO_PAGES(a)  \
-    ( ((a) >> EFI_PAGE_SHIFT) + ((a) & EFI_PAGE_MASK ? 1 : 0) )
+    ( ((a) >> EFI_PAGE_SHIFT) + (((a) & EFI_PAGE_MASK) ? 1 : 0) )
 
 #endif
Index: efi/include/efidevp.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efidevp.h,v
retrieving revision 1.2
diff -u -r1.2 efidevp.h
--- efi/include/efidevp.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efidevp.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efidevp.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efidevp.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _DEVPATH_H
 #define _DEVPATH_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -20,9 +27,9 @@
 
 --*/
 
-/*
- * Device Path structures - Section C
- */
+//
+// Device Path structures - Section C
+//
 
 typedef struct _EFI_DEVICE_PATH {
         UINT8                           Type;
@@ -33,7 +40,9 @@
 #define EFI_DP_TYPE_MASK                    0x7F
 #define EFI_DP_TYPE_UNPACKED                0x80
 
+//#define END_DEVICE_PATH_TYPE                0xff
 #define END_DEVICE_PATH_TYPE                0x7f
+//#define END_DEVICE_PATH_TYPE_UNPACKED       0x7f
 
 #define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
 #define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
@@ -47,6 +56,7 @@
 #define DevicePathSubType(a)        ( (a)->SubType )
 #define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
 #define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
+//#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED )
 #define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
 #define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
 #define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
@@ -82,7 +92,7 @@
 #define HW_PCCARD_DP                    0x02
 typedef struct _PCCARD_DEVICE_PATH {
         EFI_DEVICE_PATH                 Header;
-        UINT8                           SocketNumber;
+        UINT8                           FunctionNumber;
 } PCCARD_DEVICE_PATH;
 
 #define HW_MEMMAP_DP                    0x03
@@ -125,16 +135,25 @@
         UINT32                          UID;
 } ACPI_HID_DEVICE_PATH;
 
-/*
- * EISA ID Macro
- * EISA ID Definition 32-bits
- *  bits[15:0] - three character compressed ASCII EISA ID.
- *  bits[31:16] - binary number
- *   Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
- */
+#define ACPI_EXTENDED_DP          0x02
+typedef struct _ACPI_EXTENDED_HID_DEVICE_PATH {
+  EFI_DEVICE_PATH                 Header;
+  UINT32                          HID;
+  UINT32                          UID;
+  UINT32                          CID;
+} ACPI_EXTENDED_HID_DEVICE_PATH;
+
+//
+// EISA ID Macro
+// EISA ID Definition 32-bits
+//  bits[15:0] - three character compressed ASCII EISA ID.
+//  bits[31:16] - binary number
+//   Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
+//
 #define PNP_EISA_ID_CONST       0x41d0    
 #define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))   
 #define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
+#define EFI_PNP_ID(_PNPId)      (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
 
 #define PNP_EISA_ID_MASK        0xffff
 #define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)
@@ -175,9 +194,9 @@
 
 #define MSG_USB_DP                      0x05
 typedef struct _USB_DEVICE_PATH {
-        EFI_DEVICE_PATH                 Header;
-        UINT8                           Port;
-        UINT8                           Endpoint;
+    EFI_DEVICE_PATH                     Header;
+    UINT8					                      ParentPortNumber;
+    UINT8					                      InterfaceNumber;
 } USB_DEVICE_PATH;
 
 #define MSG_USB_CLASS_DP                0x0F
@@ -186,7 +205,7 @@
         UINT16                          VendorId;
         UINT16                          ProductId;
         UINT8                           DeviceClass;
-        UINT8                           DeviceSubclass;
+        UINT8                           DeviceSubClass;
         UINT8                           DeviceProtocol;
 } USB_CLASS_DEVICE_PATH;
 
@@ -227,13 +246,20 @@
 
 #define MSG_INFINIBAND_DP               0x09
 typedef struct _INFINIBAND_DEVICE_PATH {
-        EFI_DEVICE_PATH                 Header;
-        UINT32                          Reserved;
-        UINT64                          NodeGuid;
-        UINT64                          IocGuid;
-        UINT64                          DeviceId;
+  EFI_DEVICE_PATH                       Header;
+  UINT32                                ResourceFlags;
+  UINT8                                 PortGid[16];
+  UINT64                                ServiceId;
+  UINT64                                TargetPortId;
+  UINT64                                DeviceId;
 } INFINIBAND_DEVICE_PATH;
 
+#define INFINIBAND_RESOURCE_FLAG_IOC_SERVICE                0x01
+#define INFINIBAND_RESOURCE_FLAG_EXTENDED_BOOT_ENVIRONMENT  0x02
+#define INFINIBAND_RESOURCE_FLAG_CONSOLE_PROTOCOL           0x04
+#define INFINIBAND_RESOURCE_FLAG_STORAGE_PROTOCOL           0x08
+#define INFINIBAND_RESOURCE_FLAG_NETWORK_PROTOCOL           0x10
+
 #define MSG_UART_DP                     0x0e
 typedef struct _UART_DEVICE_PATH {
         EFI_DEVICE_PATH                 Header;
@@ -253,6 +279,11 @@
 #define DEVICE_PATH_MESSAGING_VT_100 \
     { 0xdfa66065, 0xb419, 0x11d3,  0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d  }
 
+#define DEVICE_PATH_MESSAGING_VT_100_PLUS \
+    { 0x7baec70b, 0x57e0, 0x4c76, 0x8e, 0x87, 0x2f, 0x9e, 0x28, 0x08, 0x83, 0x43  }
+    
+#define DEVICE_PATH_MESSAGING_VT_UTF8 \
+    { 0xad15a0d6, 0x8bec, 0x4acf, 0xa0, 0x73, 0xd0, 0x1d, 0xe7, 0x7e, 0x2d, 0x88 }   
 
 
 #define MEDIA_DEVICE_PATH               0x04
@@ -362,6 +393,7 @@
     UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;   
     CONTROLLER_DEVICE_PATH               *Controller;
     ACPI_HID_DEVICE_PATH                 *Acpi;
+    ACPI_EXTENDED_HID_DEVICE_PATH        *ExtendedAcpi;
 
     ATAPI_DEVICE_PATH                    *Atapi;
     SCSI_DEVICE_PATH                     *Scsi;
Index: efi/include/efierr.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efierr.h,v
retrieving revision 1.1
diff -u -r1.1 efierr.h
--- efi/include/efierr.h	9 Jun 2001 16:49:49 -0000	1.1
+++ efi/include/efierr.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efierr.h,v 1.1 2001/06/09 16:49:49 dfr Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efierr.h,v 1.2 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_ERR_H
 #define _EFI_ERR_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -52,7 +59,7 @@
 #define EFI_TFTP_ERROR                  EFIERR(23)
 #define EFI_PROTOCOL_ERROR              EFIERR(24)
 
-#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
+#define EFI_WARN_UNKNOWN_GLYPH          EFIWARN(1)
 #define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
 #define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
 #define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)
Index: efi/include/efifs.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efifs.h,v
retrieving revision 1.2
diff -u -r1.2 efifs.h
--- efi/include/efifs.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efifs.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efifs.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efifs.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_FS_H
 #define _EFI_FS_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -21,9 +28,9 @@
 --*/
 
 
-/*
- * EFI Partition header (normaly starts in LBA 1)
- */
+//
+// EFI Partition header (normaly starts in LBA 1)
+//
 
 #define EFI_PARTITION_SIGNATURE         0x5053595320494249
 #define EFI_PARTITION_REVISION          0x00010001
@@ -43,9 +50,9 @@
 } EFI_PARTITION_HEADER;
 
 
-/*
- * File header
- */
+//
+// File header
+//
 
 #define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
 #define EFI_FILE_HEADER_REVISION    0x00010000
@@ -65,10 +72,10 @@
 } EFI_FILE_HEADER;
 
 
-/*
- * Return the file's first LBAL which is in the same
- * logical block as the file header
- */
+//
+// Return the file's first LBAL which is in the same
+// logical block as the file header
+//
 
 #define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))
 
@@ -77,10 +84,10 @@
 #define EFI_FILE_CLASS_NORMAL       3
 
 
-/*
- * Logical Block Address List - the fundemental block
- * description structure
- */
+//
+// Logical Block Address List - the fundemental block
+// description structure
+//
 
 #define EFI_LBAL_SIGNATURE      0x4c41424c20494249
 #define EFI_LBAL_REVISION       0x00010000
@@ -94,22 +101,22 @@
     UINT32              ArrayCount;
 } EFI_LBAL;
 
-/* Array size */
+// Array size 
 #define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
         (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))
 
-/*
- * Logical Block run-length
- */
+//
+// Logical Block run-length
+//
 
 typedef struct {
     EFI_LBA     Start;
     UINT64      Length;
 } EFI_RL;
 
-/*
- * Return the run-length structure from an LBAL header
- */
+//
+// Return the run-length structure from an LBAL header
+//
 
 #define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))
 
Index: efi/include/efilib.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efilib.h,v
retrieving revision 1.4
diff -u -r1.4 efilib.h
--- efi/include/efilib.h	28 Nov 2004 00:30:22 -0000	1.4
+++ efi/include/efilib.h	5 Nov 2006 22:03:02 -0000
@@ -1,5 +1,6 @@
 /*-
  * Copyright (c) 2000 Doug Rabson
+ * Copyright (c) 2006 Marcel Moolenaar
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -23,18 +24,31 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *	$FreeBSD: src/sys/boot/efi/include/efilib.h,v 1.4 2004/11/28 00:30:22 marcel Exp $
+ * $FreeBSD: src/sys/boot/efi/include/efilib.h,v 1.6 2006/11/05 22:03:02 marcel Exp $
  */
 
+#include <stand.h>
+
 extern EFI_HANDLE		IH;
 extern EFI_SYSTEM_TABLE		*ST;
 extern EFI_BOOT_SERVICES	*BS;
 extern EFI_RUNTIME_SERVICES	*RS;
 
+extern struct devsw efifs_dev;
+extern struct fs_ops efifs_fsops;
+
+extern struct devsw efinet_dev;
+extern struct netif_driver efinetif;
+
 void *efi_get_table(EFI_GUID *tbl);
 void efi_main(EFI_HANDLE image_handle, EFI_SYSTEM_TABLE *system_table);
 
-EFI_PHYSICAL_ADDRESS efimd_va2pa(EFI_VIRTUAL_ADDRESS);
+int efi_register_handles(struct devsw *, EFI_HANDLE *, int);
+EFI_HANDLE efi_find_handle(struct devsw *, int);
+int efi_handle_lookup(EFI_HANDLE, struct devsw **, int *);
+
+int efi_status_to_errno(EFI_STATUS);
+time_t efi_time(EFI_TIME *);
 
 EFI_STATUS main(int argc, CHAR16 *argv[]);
 void exit(EFI_STATUS status);
Index: efi/include/efinet.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efinet.h,v
retrieving revision 1.2
diff -u -r1.2 efinet.h
--- efi/include/efinet.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efinet.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efinet.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efinet.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFINET_H
 #define _EFINET_H
 
 
 /*++
-Copyright (c) 1999  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
     efinet.h
@@ -16,55 +23,78 @@
 --*/
 
 
+///////////////////////////////////////////////////////////////////////////////
+//
+//      Simple Network Protocol
+//
+
 #define EFI_SIMPLE_NETWORK_PROTOCOL \
     { 0xA19832B9, 0xAC25, 0x11D3, 0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D }
 
+
 INTERFACE_DECL(_EFI_SIMPLE_NETWORK);
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef struct {
-	/*
-	 * Total number of frames received.  Includes frames with errors and
-	 * dropped frames.
-	 */
+    //
+    // Total number of frames received.  Includes frames with errors and
+    // dropped frames.
+    //
     UINT64  RxTotalFrames;
 
-	/* Number of valid frames received and copied into receive buffers. */
+    //
+    // Number of valid frames received and copied into receive buffers.
+    //
     UINT64  RxGoodFrames;
 
-	/*
-	 * Number of frames below the minimum length for the media.
-	 * This would be <64 for ethernet.
-	 */
+    //
+    // Number of frames below the minimum length for the media.
+    // This would be <64 for ethernet.
+    //
     UINT64  RxUndersizeFrames;
 
-	/*
-	 * Number of frames longer than the maxminum length for the
-	 * media.  This would be >1500 for ethernet.
-	 */
+    //
+    // Number of frames longer than the maxminum length for the
+    // media.  This would be >1500 for ethernet.
+    //
     UINT64  RxOversizeFrames;
 
-	/* Valid frames that were dropped because receive buffers were full. */
+    //
+    // Valid frames that were dropped because receive buffers were full.
+    //
     UINT64  RxDroppedFrames;
 
-	/* Number of valid unicast frames received and not dropped. */
+    //
+    // Number of valid unicast frames received and not dropped.
+    //
     UINT64  RxUnicastFrames;
 
-	/* Number of valid broadcast frames received and not dropped. */
+    //
+    // Number of valid broadcast frames received and not dropped.
+    //
     UINT64  RxBroadcastFrames;
 
-	/* Number of valid mutlicast frames received and not dropped. */
+    //
+    // Number of valid mutlicast frames received and not dropped.
+    //
     UINT64  RxMulticastFrames;
 
-	/* Number of frames w/ CRC or alignment errors. */
+    //
+    // Number of frames w/ CRC or alignment errors.
+    //
     UINT64  RxCrcErrorFrames;
 
-	/*
-	 * Total number of bytes received.  Includes frames with errors
-	 * and dropped frames.
-	 */
+    //
+    // Total number of bytes received.  Includes frames with errors
+    // and dropped frames.
+    //
     UINT64  RxTotalBytes;
 
-	/* Transmit statistics. */
+    //
+    // Transmit statistics.
+    //
     UINT64  TxTotalFrames;
     UINT64  TxGoodFrames;
     UINT64  TxUndersizeFrames;
@@ -76,14 +106,21 @@
     UINT64  TxCrcErrorFrames;
     UINT64  TxTotalBytes;
 
-	/* Number of collisions detection on this subnet. */
+    //
+    // Number of collisions detection on this subnet.
+    //
     UINT64  Collisions;
 
-	/* Number of frames destined for unsupported protocol. */
+    //
+    // Number of frames destined for unsupported protocol.
+    //
     UINT64  UnsupportedProtocol;
 
 } EFI_NETWORK_STATISTICS;
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef enum {
     EfiSimpleNetworkStopped,
     EfiSimpleNetworkStarted,
@@ -91,17 +128,25 @@
     EfiSimpleNetworkMaxState
 } EFI_SIMPLE_NETWORK_STATE;
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 #define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
 #define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
 #define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
 #define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
 #define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 #define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
 #define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
 #define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
 #define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08
 
+///////////////////////////////////////////////////////////////////////////////
+//
 #define MAX_MCAST_FILTER_CNT    16
 typedef struct {
     UINT32                      State;
@@ -125,18 +170,27 @@
     BOOLEAN                     MediaPresent;
 } EFI_SIMPLE_NETWORK_MODE;
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_START) (
     IN struct _EFI_SIMPLE_NETWORK  *This
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
     IN struct _EFI_SIMPLE_NETWORK  *This
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
@@ -145,6 +199,9 @@
     IN UINTN                       ExtraTxBufferSize  OPTIONAL
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
@@ -152,12 +209,18 @@
     IN BOOLEAN                      ExtendedVerification
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
     IN struct _EFI_SIMPLE_NETWORK  *This
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
@@ -169,6 +232,9 @@
     IN EFI_MAC_ADDRESS              *MCastFilter       OPTIONAL
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
@@ -177,6 +243,9 @@
     IN EFI_MAC_ADDRESS              *New      OPTIONAL
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
@@ -186,6 +255,9 @@
     OUT EFI_NETWORK_STATISTICS      *StatisticsTable  OPTIONAL
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
@@ -195,6 +267,9 @@
     OUT EFI_MAC_ADDRESS             *MAC
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
@@ -205,6 +280,9 @@
     IN OUT VOID                    *Buffer
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
@@ -213,6 +291,9 @@
     OUT VOID                       **TxBuf           OPTIONAL
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
@@ -225,6 +306,9 @@
     IN UINT16                       *Protocol    OPTIONAL
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 typedef 
 EFI_STATUS 
 (EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
@@ -237,6 +321,9 @@
     OUT UINT16                      *Protocol    OPTIONAL
 );
 
+///////////////////////////////////////////////////////////////////////////////
+//
+
 #define EFI_SIMPLE_NETWORK_INTERFACE_REVISION   0x00010000
 
 typedef struct _EFI_SIMPLE_NETWORK {
Index: efi/include/efipart.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efipart.h,v
retrieving revision 1.2
diff -u -r1.2 efipart.h
--- efi/include/efipart.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efipart.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efipart.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efipart.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_PART_H
 #define _EFI_PART_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -20,6 +27,10 @@
 
 --*/
 
+//
+//
+//
+
 #define EFI_PARTITION   0xef
 #define MBR_SIZE        512
 
@@ -42,7 +53,7 @@
 
 #define MBR_SIGNATURE           0xaa55
 #define MIN_MBR_DEVICE_SIZE     0x80000
-#define MBR_ERRATA_PAD          0x40000	/* 128 MB */
+#define MBR_ERRATA_PAD          0x40000 // 128 MB
 
 #define MAX_MBR_PARTITIONS  4   
 typedef struct {
Index: efi/include/efiprot.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efiprot.h,v
retrieving revision 1.3
diff -u -r1.3 efiprot.h
--- efi/include/efiprot.h	19 May 2002 03:17:20 -0000	1.3
+++ efi/include/efiprot.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efiprot.h,v 1.3 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efiprot.h,v 1.4 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_PROT_H
 #define _EFI_PROT_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -20,17 +27,17 @@
 
 --*/
 
-/*
- * Device Path protocol
- */
+//
+// Device Path protocol
+//
 
 #define DEVICE_PATH_PROTOCOL    \
     { 0x9576e91, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
 
 
-/*
- * Block IO protocol
- */
+//
+// Block IO protocol
+//
 
 #define BLOCK_IO_PROTOCOL \
     { 0x964e5b21, 0x6459, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
@@ -104,9 +111,9 @@
 
 
 
-/*
- * Disk Block IO protocol
- */
+//
+// Disk Block IO protocol
+//
 
 #define DISK_IO_PROTOCOL \
     { 0xce345171, 0xba0b, 0x11d2,  0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
@@ -143,9 +150,9 @@
 } EFI_DISK_IO;
 
 
-/*
- * Simple filesystem protocol
- */
+//
+// Simple file system protocol
+//
 
 #define SIMPLE_FILE_SYSTEM_PROTOCOL \
     { 0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
@@ -167,6 +174,10 @@
     EFI_VOLUME_OPEN         OpenVolume;
 } EFI_FILE_IO_INTERFACE;
 
+//
+//
+//
+
 typedef
 EFI_STATUS
 (EFIAPI *EFI_FILE_OPEN) (
@@ -177,12 +188,12 @@
     IN UINT64                   Attributes
     );
 
-/* Open modes */
+// Open modes
 #define EFI_FILE_MODE_READ      0x0000000000000001
 #define EFI_FILE_MODE_WRITE     0x0000000000000002
 #define EFI_FILE_MODE_CREATE    0x8000000000000000
 
-/* File attributes */
+// File attributes
 #define EFI_FILE_READ_ONLY      0x0000000000000001
 #define EFI_FILE_HIDDEN         0x0000000000000002
 #define EFI_FILE_SYSTEM         0x0000000000000004
@@ -275,9 +286,9 @@
 } EFI_FILE, *EFI_FILE_HANDLE;
 
 
-/*
- * File information types
- */
+//
+// File information types
+//
 
 #define EFI_FILE_INFO_ID   \
     { 0x9576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
@@ -293,14 +304,13 @@
     CHAR16                  FileName[1];
 } EFI_FILE_INFO;
 
-/*
- * The FileName field of the EFI_FILE_INFO data structure is variable length.
- * Whenever code needs to know the size of the EFI_FILE_INFO data structure,
- * it needs to be the size of the data structure without the FileName field.
- * The following macro computes this size correctly no matter how big the
- * FileName array is declared. This is required to make the EFI_FILE_INFO
- * data structure ANSI compliant. 
- */
+//
+// The FileName field of the EFI_FILE_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
+// be the size of the data structure without the FileName field.  The following macro 
+// computes this size correctly no matter how big the FileName array is declared.
+// This is required to make the EFI_FILE_INFO data structure ANSI compilant. 
+//
 
 #define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)
 
@@ -316,15 +326,13 @@
     CHAR16                  VolumeLabel[1];
 } EFI_FILE_SYSTEM_INFO;
 
-/*
- * The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is
- * variable length. Whenever code needs to know the size of the
- * EFI_FILE_SYSTEM_INFO data structure, it needs to be the size of the data
- * structure without the VolumeLable field.  The following macro computes
- * this size correctly no matter how big the VolumeLable array is declared.
- * This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI
- * compilant. 
- */
+//
+// The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
+// Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
+// to be the size of the data structure without the VolumeLable field.  The following macro 
+// computes this size correctly no matter how big the VolumeLable array is declared.
+// This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant. 
+//
 
 #define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)
 
@@ -337,9 +345,10 @@
 
 #define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL_INFO,VolumeLabel)
 
-/*
- * Load file protocol
- */
+//
+// Load file protocol
+//
+
 
 #define LOAD_FILE_PROTOCOL \
     { 0x56EC3091, 0x954C, 0x11d2, 0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B }
@@ -361,9 +370,9 @@
 } EFI_LOAD_FILE_INTERFACE;
 
 
-/*
- * Device IO protocol
- */
+//
+// Device IO protocol
+//
 
 #define DEVICE_IO_PROTOCOL \
     { 0xaf6ac311, 0x84c3, 0x11d2, 0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
@@ -375,19 +384,17 @@
     IO_UINT16,
     IO_UINT32,
     IO_UINT64,
-/*
- * Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to
- * MMIO
- */
+//
+// Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
+//
     MMIO_COPY_UINT8,
     MMIO_COPY_UINT16,
     MMIO_COPY_UINT32,
     MMIO_COPY_UINT64
 } EFI_IO_WIDTH;
 
-#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
-    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )
-
+#define EFI_PCI_ADDRESS(bus,dev,func,reg) \
+  ( (UINT64) ( (((UINTN)bus) << 24) + (((UINTN)dev) << 16) + (((UINTN)func) << 8) + ((UINTN)reg) ))
 
 typedef
 EFI_STATUS
@@ -473,9 +480,9 @@
 } EFI_DEVICE_IO_INTERFACE;
 
 
-/*
- * Unicode Collation protocol
- */
+//
+// Unicode Collation protocol
+//
 
 #define UNICODE_COLLATION_PROTOCOL \
     { 0x1d85cd7f, 0xf43d, 0x11d2, 0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }
@@ -486,7 +493,7 @@
 
 typedef
 INTN
-(EFIAPI *EFI_UNICODE_STRICOLL) (
+(EFIAPI *EFI_UNICODE_COLLATION_STRICOLL) (
     IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
     IN CHAR16                         *s1,
     IN CHAR16                         *s2
@@ -494,7 +501,7 @@
 
 typedef
 BOOLEAN
-(EFIAPI *EFI_UNICODE_METAIMATCH) (
+(EFIAPI *EFI_UNICODE_COLLATION_METAIMATCH) (
     IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
     IN CHAR16                         *String,
     IN CHAR16                         *Pattern
@@ -502,21 +509,21 @@
 
 typedef
 VOID
-(EFIAPI *EFI_UNICODE_STRLWR) (
+(EFIAPI *EFI_UNICODE_COLLATION_STRLWR) (
     IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
     IN OUT CHAR16                       *Str
     );
 
 typedef
 VOID
-(EFIAPI *EFI_UNICODE_STRUPR) (
+(EFIAPI *EFI_UNICODE_COLLATION_STRUPR) (
     IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
     IN OUT CHAR16                       *Str
     );
 
 typedef
 VOID
-(EFIAPI *EFI_UNICODE_FATTOSTR) (
+(EFIAPI *EFI_UNICODE_COLLATION_FATTOSTR) (
     IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
     IN UINTN                            FatSize,
     IN CHAR8                            *Fat,
@@ -525,7 +532,7 @@
 
 typedef
 BOOLEAN
-(EFIAPI *EFI_UNICODE_STRTOFAT) (
+(EFIAPI *EFI_UNICODE_COLLATION_STRTOFAT) (
     IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
     IN CHAR16                           *String,
     IN UINTN                            FatSize,
@@ -535,15 +542,15 @@
 
 typedef struct _EFI_UNICODE_COLLATION_INTERFACE {
 
-	/* general */
-    EFI_UNICODE_STRICOLL                StriColl;
-    EFI_UNICODE_METAIMATCH              MetaiMatch;
-    EFI_UNICODE_STRLWR                  StrLwr;
-    EFI_UNICODE_STRUPR                  StrUpr;
-
-	/* for supporting fat volumes */
-    EFI_UNICODE_FATTOSTR                FatToStr;
-    EFI_UNICODE_STRTOFAT                StrToFat;
+    // general
+    EFI_UNICODE_COLLATION_STRICOLL                StriColl;
+    EFI_UNICODE_COLLATION_METAIMATCH              MetaiMatch;
+    EFI_UNICODE_COLLATION_STRLWR                  StrLwr;
+    EFI_UNICODE_COLLATION_STRUPR                  StrUpr;
+
+    // for supporting fat volumes
+    EFI_UNICODE_COLLATION_FATTOSTR                FatToStr;
+    EFI_UNICODE_COLLATION_STRTOFAT                StrToFat;
 
     CHAR8                               *SupportedLanguages;
 } EFI_UNICODE_COLLATION_INTERFACE;
Index: efi/include/efipxebc.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efipxebc.h,v
retrieving revision 1.2
diff -u -r1.2 efipxebc.h
--- efi/include/efipxebc.h	19 May 2002 03:17:20 -0000	1.2
+++ efi/include/efipxebc.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efipxebc.h,v 1.2 2002/05/19 03:17:20 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efipxebc.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFIPXEBC_H
 #define _EFIPXEBC_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -20,21 +27,20 @@
 
 --*/
 
-/*
- * PXE Base Code protocol
- */
+//
+// PXE Base Code protocol
+//
 
 #define EFI_PXE_BASE_CODE_PROTOCOL \
     { 0x03c4e603, 0xac28, 0x11d3, 0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d }
 
 INTERFACE_DECL(_EFI_PXE_BASE_CODE);
 
-#define DEFAULT_TTL 4
+#define DEFAULT_TTL 8
 #define DEFAULT_ToS 0
-
-/*
- * Address definitions
- */
+//
+// Address definitions
+//
 
 typedef union {
     UINT32      Addr[4];
@@ -44,9 +50,9 @@
 
 typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;
 
-/*
- * Packet definitions
- */
+//
+// Packet definitions
+//
 
 typedef struct {
     UINT8                           BootpOpcode;
@@ -67,9 +73,15 @@
     UINT8                           DhcpOptions[56];
 } EFI_PXE_BASE_CODE_DHCPV4_PACKET;
 
+// TBD in EFI v1.1
+//typedef struct {
+//    UINT8                           reserved;
+//} EFI_PXE_BASE_CODE_DHCPV6_PACKET;
+
 typedef union {
     UINT8                               Raw[1472];
     EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
+//    EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6;
 } EFI_PXE_BASE_CODE_PACKET;
 
 typedef struct {
@@ -93,9 +105,9 @@
     CHAR8                   ErrorString[127];
 } EFI_PXE_BASE_CODE_TFTP_ERROR;
 
-/*
- * IP Receive Filter definitions
- */
+//
+// IP Receive Filter definitions
+//
 #define EFI_PXE_BASE_CODE_MAX_IPCNT             8
 typedef struct {
     UINT8                       Filters;
@@ -109,9 +121,9 @@
 #define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
 #define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008
 
-/*
- * ARP Cache definitions
- */
+//
+// ARP Cache definitions
+//
 
 typedef struct {
     EFI_IP_ADDRESS       IpAddr;
@@ -124,9 +136,9 @@
     EFI_IP_ADDRESS       GwAddr;
 } EFI_PXE_BASE_CODE_ROUTE_ENTRY;
 
-/*
- * UDP definitions
- */
+//
+// UDP definitions
+//
 
 #define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
 #define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
@@ -135,9 +147,9 @@
 #define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
 #define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020
 
-/*
- * Discover() definitions
- */
+//
+// Discover() definitions
+//
 
 #define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0   
 #define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
@@ -156,15 +168,16 @@
 #define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
 #define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
 #define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
-/*
- * 17 through 32767 are reserved
- * 32768 through 65279 are for vendor use
- * 65280 through 65534 are reserved
- */
+//
+// 17 through 32767 are reserved
+// 32768 through 65279 are for vendor use
+// 65280 through 65534 are reserved
+//
 #define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535
 
 #define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
 #define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000
+#define EFI_PXE_BASE_CODE_BOOT_LAYER_CREDENTIALS        0x8000
 
 
 typedef struct {
@@ -184,9 +197,9 @@
     EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
 } EFI_PXE_BASE_CODE_DISCOVER_INFO;
 
-/*
- * Mtftp() definitions
- */
+//
+// Mtftp() definitions
+//
 
 typedef enum {
     EFI_PXE_BASE_CODE_TFTP_FIRST,
@@ -208,9 +221,9 @@
     UINT16                      TransmitTimeout;
 } EFI_PXE_BASE_CODE_MTFTP_INFO;
 
-/*
- * PXE Base Code Mode structure
- */
+//
+// PXE Base Code Mode structure
+//
 
 #define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
 #define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8
@@ -252,9 +265,9 @@
     EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
 } EFI_PXE_BASE_CODE_MODE;
 
-/*
- * PXE Base Code Interface Function definitions
- */
+//
+// PXE Base Code Interface Function definitions
+//
 
 typedef
 EFI_STATUS
@@ -293,7 +306,7 @@
     IN EFI_PXE_BASE_CODE_TFTP_OPCODE    Operation,
     IN OUT VOID                         *BufferPtr  OPTIONAL,
     IN BOOLEAN                          Overwrite,
-    IN OUT UINTN                        *BufferSize,
+    IN OUT UINT64                       *BufferSize,
     IN UINTN                            *BlockSize  OPTIONAL,
     IN EFI_IP_ADDRESS                   *ServerIp,
     IN UINT8                            *Filename,
@@ -384,9 +397,9 @@
     IN EFI_PXE_BASE_CODE_PACKET     *NewPxeBisReply   OPTIONAL
     );
 
-/*
- * PXE Base Code Protocol structure
- */
+//
+// PXE Base Code Protocol structure
+//
 
 #define EFI_PXE_BASE_CODE_INTERFACE_REVISION    0x00010000
 
@@ -407,16 +420,16 @@
     EFI_PXE_BASE_CODE_MODE              *Mode;
 } EFI_PXE_BASE_CODE;
 
-/*
- * Call Back Definitions
- */
+//
+// Call Back Definitions
+//
 
 #define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL \
     { 0x245dca21, 0xfb7b, 0x11d3, 0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
 
-/*
- * Revision Number
- */
+//
+// Revision Number
+//
 
 #define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION   0x00010000
 
Index: efi/include/efiser.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efiser.h,v
retrieving revision 1.2
diff -u -r1.2 efiser.h
--- efi/include/efiser.h	19 May 2002 03:17:21 -0000	1.2
+++ efi/include/efiser.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efiser.h,v 1.2 2002/05/19 03:17:21 marcel Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efiser.h,v 1.3 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFI_SER_H
 #define _EFI_SER_H
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -18,9 +25,9 @@
 
 --*/
 
-/*
- * Serial protocol
- */
+//
+// Serial protocol
+//
 
 #define SERIAL_IO_PROTOCOL \
     { 0xBB25CF6F, 0xF1D4, 0x11D2, 0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD }
@@ -37,23 +44,23 @@
 } EFI_PARITY_TYPE;
 
 typedef enum {
-	DefaultStopBits,
-	OneStopBit,
-	OneFiveStopBits,
-	TwoStopBits
+    DefaultStopBits,        
+    OneStopBit,         // 1 stop bit
+    OneFiveStopBits,    // 1.5 stop bits
+    TwoStopBits         // 2 stop bits
 } EFI_STOP_BITS_TYPE;
 
-#define EFI_SERIAL_CLEAR_TO_SEND                   0x0010
-#define EFI_SERIAL_DATA_SET_READY                  0x0020
-#define EFI_SERIAL_RING_INDICATE                   0x0040
-#define EFI_SERIAL_CARRIER_DETECT                  0x0080
-#define EFI_SERIAL_REQUEST_TO_SEND                 0x0002
-#define EFI_SERIAL_DATA_TERMINAL_READY             0x0001
-#define EFI_SERIAL_INPUT_BUFFER_EMPTY              0x0100
-#define EFI_SERIAL_OUTPUT_BUFFER_EMPTY             0x0200
-#define EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE        0x1000
-#define EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE        0x2000
-#define EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE    0x4000
+#define EFI_SERIAL_CLEAR_TO_SEND                   0x0010  // RO
+#define EFI_SERIAL_DATA_SET_READY                  0x0020  // RO
+#define EFI_SERIAL_RING_INDICATE                   0x0040  // RO
+#define EFI_SERIAL_CARRIER_DETECT                  0x0080  // RO
+#define EFI_SERIAL_REQUEST_TO_SEND                 0x0002  // WO
+#define EFI_SERIAL_DATA_TERMINAL_READY             0x0001  // WO
+#define EFI_SERIAL_INPUT_BUFFER_EMPTY              0x0100  // RO
+#define EFI_SERIAL_OUTPUT_BUFFER_EMPTY             0x0200  // RO
+#define EFI_SERIAL_HARDWARE_LOOPBACK_ENABLE        0x1000  // RW
+#define EFI_SERIAL_SOFTWARE_LOOPBACK_ENABLE        0x2000  // RW
+#define EFI_SERIAL_HARDWARE_FLOW_CONTROL_ENABLE    0x4000  // RW
 
 typedef
 EFI_STATUS
@@ -106,7 +113,7 @@
 typedef struct {
     UINT32                  ControlMask;
 
-	/* current Attributes. */
+    // current Attributes
     UINT32                  Timeout;
     UINT64                  BaudRate;
     UINT32                  ReceiveFifoDepth;
Index: efi/include/efistdarg.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/efistdarg.h,v
retrieving revision 1.1
diff -u -r1.1 efistdarg.h
--- efi/include/efistdarg.h	9 Jun 2001 16:49:49 -0000	1.1
+++ efi/include/efistdarg.h	2 Nov 2006 02:42:47 -0000
@@ -1,10 +1,17 @@
-/* $FreeBSD: src/sys/boot/efi/include/efistdarg.h,v 1.1 2001/06/09 16:49:49 dfr Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/efistdarg.h,v 1.2 2006/11/02 02:42:47 marcel Exp $ */
 #ifndef _EFISTDARG_H_
 #define _EFISTDARG_H_
 
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2002 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
Index: efi/include/i386/efibind.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/i386/efibind.h,v
retrieving revision 1.3
diff -u -r1.3 efibind.h
--- efi/include/i386/efibind.h	7 Mar 2005 15:38:37 -0000	1.3
+++ efi/include/i386/efibind.h	2 Nov 2006 02:42:47 -0000
@@ -1,7 +1,14 @@
-/* $FreeBSD: src/sys/boot/efi/include/i386/efibind.h,v 1.3 2005/03/07 15:38:37 stefanf Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/i386/efibind.h,v 1.4 2006/11/02 02:42:47 marcel Exp $ */
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2003 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -21,17 +28,20 @@
 #pragma pack()
 
 
-/*
- * Basic int types of various widths
- */
+#ifdef __FreeBSD__
+#include <sys/stdint.h>
+#else
+//
+// Basic int types of various widths
+//
 
 #if (__STDC_VERSION__ < 199901L )
 
-/* No ANSI C 1999/2000 stdint.h integer width declarations */
+    // No ANSI C 1999/2000 stdint.h integer width declarations 
 
     #if _MSC_EXTENSIONS
 
-/* Use Microsoft C compiler integer width declarations */
+        // Use Microsoft C compiler integer width declarations 
 
         typedef unsigned __int64    uint64_t;
         typedef __int64             int64_t;
@@ -44,7 +54,7 @@
     #else             
         #ifdef UNIX_LP64
 
-/* Use LP64 programming model from C_FLAGS for integer width declarations */
+            // Use LP64 programming model from C_FLAGS for integer width declarations 
 
             typedef unsigned long       uint64_t;
             typedef long                int64_t;
@@ -56,7 +66,7 @@
             typedef char                int8_t;
         #else
 
-/* Assume P64 programming model from C_FLAGS for integer width declarations */
+            // Assume P64 programming model from C_FLAGS for integer width declarations 
 
             typedef unsigned long long  uint64_t;
             typedef long long           int64_t;
@@ -69,10 +79,11 @@
         #endif
     #endif
 #endif
+#endif	/* __FreeBSD__ */
 
-/*
- * Basic EFI types of various widths
- */
+//
+// Basic EFI types of various widths
+//
 
 typedef uint64_t   UINT64;
 typedef int64_t    INT64;
@@ -113,15 +124,11 @@
 #define BAD_POINTER         0xFBFBFBFB
 #define MAX_ADDRESS         0xFFFFFFFF
 
-#ifdef EFI_NT_EMULATOR
-    #define BREAKPOINT()        __asm { int 3 }
-#else
-    #define BREAKPOINT()        while (TRUE);
-#endif
+#define BREAKPOINT()        __asm { int 3 }
 
-/*
- * Pointers must be aligned to these address to function
- */
+//
+// Pointers must be aligned to these address to function
+//
 
 #define MIN_ALIGNMENT_SIZE  4
 
@@ -132,108 +139,125 @@
             Value = (UINTN)Value + (UINTN)Adjustment
 
 
-/*
- * Define macros to build data structure signatures from characters.
- */
+//
+// Define macros to build data structure signatures from characters.
+//
 
 #define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
 #define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
 #define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
 
-/*
- * To export & import functions in the EFI emulator environment
- */
-
-#if EFI_NT_EMULATOR
-    #define EXPORTAPI           __declspec( dllexport )
-#else
-    #define EXPORTAPI
-#endif
-
+//
+// EFIAPI - prototype calling convention for EFI function pointers
+// BOOTSERVICE - prototype for implementation of a boot service interface
+// RUNTIMESERVICE - prototype for implementation of a runtime service interface
+// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
+// RUNTIME_CODE - pragma macro for declaring runtime code    
+//
 
-/*
- * EFIAPI - prototype calling convention for EFI function pointers
- * BOOTSERVICE - prototype for implementation of a boot service interface
- * RUNTIMESERVICE - prototype for implementation of a runtime service interface
- * RUNTIMEFUNCTION - prototype for implementation of a runtime function that
- *	is not a service
- * RUNTIME_CODE - pragma macro for declaring runtime code    
- */
-
-/* Forces EFI calling conventions reguardless of compiler options */
-#ifndef EFIAPI
+#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
     #if _MSC_EXTENSIONS
-        #define EFIAPI __cdecl
+        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
     #else
-        #define EFIAPI
+        #define EFIAPI          // Substitute expresion to force C calling convention 
     #endif
 #endif
 
 #define BOOTSERVICE
+//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
+//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
 #define RUNTIMESERVICE
 #define RUNTIMEFUNCTION
 
 
 #define RUNTIME_CODE(a)         alloc_text("rtcode", a)
 #define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
-#define END_RUNTIME_DATA()      data_seg("")
+#define END_RUNTIME_DATA()      data_seg()
 
 #define VOLATILE    volatile
 
 #define MEMORY_FENCE()    
 
+#ifdef EFI_NO_INTERFACE_DECL
+  #define EFI_FORWARD_DECLARATION(x)
+  #define EFI_INTERFACE_DECL(x)
+#else
+  #define EFI_FORWARD_DECLARATION(x) typedef struct _##x x
+  #define EFI_INTERFACE_DECL(x) typedef struct x
+#endif
+
 #ifdef EFI_NT_EMULATOR
 
-/*
- * To help ensure proper coding of integrated drivers, they are
- * compiled as DLLs.  In NT they require a dll init entry pointer.
- * The macro puts a stub entry point into the DLL so it will load.
- */
-
-#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
-    UINTN                                       \
-    __stdcall                                   \
-    _DllMainCRTStartup (                        \
-        UINTN    Inst,                          \
-        UINTN    reason_for_call,               \
-        VOID    *rserved                        \
-        )                                       \
-    {                                           \
-        return 1;                               \
-    }                                           \
-                                                \
-    int                                         \
-    EXPORTAPI                                   \
-    __cdecl                                     \
-    InitializeDriver (                          \
-        void *ImageHandle,                      \
-        void *SystemTable                       \
-        )                                       \
-    {                                           \
-        return InitFunction(ImageHandle, SystemTable);       \
+//
+// To help ensure proper coding of integrated drivers, they are
+// compiled as DLLs.  In NT they require a dll init entry pointer.
+// The macro puts a stub entry point into the DLL so it will load.
+//
+
+#define EFI_DRIVER_ENTRY_POINT(InitFunction)            \
+    EFI_STATUS                                          \
+    InitFunction (                                      \
+      EFI_HANDLE  ImageHandle,                          \
+      EFI_SYSTEM_TABLE  *SystemTable                    \
+      );                                                \
+                                                        \
+    UINTN                                               \
+    __stdcall                                           \
+    _DllMainCRTStartup (                                \
+        UINTN    Inst,                                  \
+        UINTN    reason_for_call,                       \
+        VOID    *rserved                                \
+        )                                               \
+    {                                                   \
+        return 1;                                       \
+    }                                                   \
+                                                        \
+    int                                                 \
+    __declspec( dllexport )                             \
+    __cdecl                                             \
+    InitializeDriver (                                  \
+        void *ImageHandle,                              \
+        void *SystemTable                               \
+        )                                               \
+    {                                                   \
+        return InitFunction(ImageHandle, SystemTable);  \
     }
 
 
     #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
         (_if)->LoadInternal(type, name, NULL)             
 
-#else /* EFI_NT_EMULATOR */
+#else // EFI_NT_EMULATOR 
 
-/*
- * When build similiar to FW, then link everything together as
- * one big module.
- */
+//
+// When build similiar to FW, then link everything together as
+// one big module.
+//
 
     #define EFI_DRIVER_ENTRY_POINT(InitFunction)
 
     #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
             (_if)->LoadInternal(type, name, entry)
 
-#endif /* EFI_FW_NT */
+#endif // EFI_FW_NT 
 
+#ifdef __FreeBSD__
 #define INTERFACE_DECL(x) struct x
+#else
+//
+// Some compilers don't support the forward reference construct:
+//  typedef struct XXXXX
+//
+// The following macro provide a workaround for such cases.
+//
+#ifdef NO_INTERFACE_DECL
+#define INTERFACE_DECL(x)
+#else
+#define INTERFACE_DECL(x) typedef struct x
+#endif
+#endif	/* __FreeBSD__ */
 
 #if _MSC_EXTENSIONS
-#pragma warning ( disable : 4731 )
+#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
 #endif
 
Index: efi/include/i386/pe.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/i386/pe.h,v
retrieving revision 1.1
diff -u -r1.1 pe.h
--- efi/include/i386/pe.h	9 Jun 2001 16:49:50 -0000	1.1
+++ efi/include/i386/pe.h	2 Nov 2006 02:42:48 -0000
@@ -1,4 +1,4 @@
-/* $FreeBSD: src/sys/boot/efi/include/i386/pe.h,v 1.1 2001/06/09 16:49:50 dfr Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/i386/pe.h,v 1.2 2006/11/02 02:42:48 marcel Exp $ */
 /* 
     PE32+ header file
  */
@@ -589,4 +589,43 @@
     PIMAGE_THUNK_DATA FirstThunk;
 } IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
 
+#define IMAGE_DEBUG_TYPE_CODEVIEW   2
+
+typedef struct {
+  UINT32    Characteristics;
+  UINT32    TimeDateStamp;
+  UINT16    MajorVersion;
+  UINT16    MinorVersion;
+  UINT32    Type;
+  UINT32    SizeOfData;
+  UINT32    RVA;
+  UINT32    FileOffset;
+} IMAGE_DEBUG_DIRECTORY_ENTRY;
+
+#define CODEVIEW_SIGNATURE_NB10  0x3031424E // "NB10"
+
+typedef struct {
+  UINT32    Signature; // "NB10"
+  UINT32    Unknown;
+  UINT32    Unknown2;
+  UINT32    Unknown3;     
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY;
+
+#define CODEVIEW_SIGNATURE_RSDS  0x53445352 // "RSDS"
+
+typedef struct {
+  UINT32    Signature; // "RSDS"
+  UINT32    Unknown;
+  UINT32    Unknown2;
+  UINT32    Unknown3;     
+  UINT32    Unknown4;     
+  UINT32    Unknown5;     
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY;
+
 #endif
Index: efi/include/ia64/efibind.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/ia64/efibind.h,v
retrieving revision 1.6
diff -u -r1.6 efibind.h
--- efi/include/ia64/efibind.h	7 Mar 2005 15:38:37 -0000	1.6
+++ efi/include/ia64/efibind.h	2 Nov 2006 02:42:48 -0000
@@ -1,7 +1,14 @@
-/* $FreeBSD: src/sys/boot/efi/include/ia64/efibind.h,v 1.6 2005/03/07 15:38:37 stefanf Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/ia64/efibind.h,v 1.7 2006/11/02 02:42:48 marcel Exp $ */
 /*++
 
-Copyright (c) 1998  Intel Corporation
+Copyright (c)  1999 - 2003 Intel Corporation. All rights reserved
+This software and associated documentation (if any) is furnished
+under a license and may only be used or copied in accordance
+with the terms of the license. Except as permitted by such
+license, no part of this software or documentation may be
+reproduced, stored in a retrieval system, or transmitted in any
+form or by any means without the express written consent of
+Intel Corporation.
 
 Module Name:
 
@@ -18,9 +25,66 @@
 
 --*/
 
+#pragma pack()
+
+
+#ifdef __FreeBSD__
 #include <sys/stdint.h>
+#else
+//
+// Basic int types of various widths
+//
+
+#if (__STDC_VERSION__ < 199901L )
+
+    // No ANSI C 1999/2000 stdint.h integer width declarations 
+
+    #if _MSC_EXTENSIONS
+
+        // Use Microsoft C compiler integer width declarations 
+
+        typedef unsigned __int64    uint64_t;
+        typedef __int64             int64_t;
+        typedef unsigned __int32    uint32_t;
+        typedef __int32             int32_t;
+        typedef unsigned __int16    uint16_t;
+        typedef __int16             int16_t;
+        typedef unsigned __int8     uint8_t;
+        typedef __int8              int8_t;
+    #else             
+        #ifdef UNIX_LP64
+
+            // Use LP64 programming model from C_FLAGS for integer width declarations 
+
+            typedef unsigned long       uint64_t;
+            typedef long                int64_t;
+            typedef unsigned int        uint32_t;
+            typedef int                 int32_t;
+            typedef unsigned short      uint16_t;
+            typedef short               int16_t;
+            typedef unsigned char       uint8_t;
+            typedef char                int8_t;
+        #else
+
+            // Assume P64 programming model from C_FLAGS for integer width declarations 
+
+            typedef unsigned long long  uint64_t;
+            typedef long long           int64_t;
+            typedef unsigned int        uint32_t;
+            typedef int                 int32_t;
+            typedef unsigned short      uint16_t;
+            typedef short               int16_t;
+            typedef unsigned char       uint8_t;
+            typedef char                int8_t;
+        #endif
+    #endif
+#endif
+#endif	/* __FreeBSD__ */
+
+//
+// Basic EFI types of various widths
+//
 
-/* Basic EFI types of various widths. */
 
 typedef uint64_t   UINT64;
 typedef int64_t    INT64;
@@ -39,17 +103,22 @@
 typedef int64_t    INTN;
 typedef uint64_t   UINTN;
 
-/*
- *XXX BugBug: Code to debug
- */
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// BugBug: Code to debug
+//
 #define BIT63   0x8000000000000000
 
-#define PLATFORM_IOBASE_ADDRESS   (0xffffc000000 | BIT63)
+#define PLATFORM_IOBASE_ADDRESS   (0xffffc000000 | BIT63)                                               
 #define PORT_TO_MEMD(_Port) (PLATFORM_IOBASE_ADDRESS | ( ( ( (_Port) & 0xfffc) << 10 ) | ( (_Port) & 0x0fff) ) )
-
-/* Macro's with casts make this much easier to use and read. */
+                                                                           
+//                                                                  
+// Macro's with casts make this much easier to use and read.
+//
 #define PORT_TO_MEM8D(_Port)  (*(UINT8  *)(PORT_TO_MEMD(_Port)))
 #define POST_CODE(_Data)  (PORT_TO_MEM8D(0x80) = (_Data))
+//
+// BugBug: End Debug Code!!!
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 #define EFIERR(a)           (0x8000000000000000 | a)
 #define EFI_ERROR_MASK      0x8000000000000000
@@ -58,12 +127,13 @@
 #define BAD_POINTER         0xFBFBFBFBFBFBFBFB
 #define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF
 
-#define BREAKPOINT()        while (TRUE)
+#pragma intrinsic (__break)  
+#define BREAKPOINT()  __break(0)
 
-/*
- * Pointers must be aligned to these address to function
- *  you will get an alignment fault if this value is less than 8
- */
+//
+// Pointers must be aligned to these address to function
+//  you will get an alignment fault if this value is less than 8
+//
 #define MIN_ALIGNMENT_SIZE  8
 
 #define ALIGN_VARIABLE(Value , Adjustment) \
@@ -72,34 +142,28 @@
                 (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
             Value = (UINTN)Value + (UINTN)Adjustment
 
-/*
- * Define macros to create data structure signatures.
- */
+//
+// Define macros to create data structure signatures.
+//
 
 #define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
 #define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
 #define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
 
-/*
- * To export & import functions in the EFI emulator environment
- */
-
-#define EXPORTAPI
-
-/*
- * EFIAPI - prototype calling convention for EFI function pointers
- * BOOTSERVICE - prototype for implementation of a boot service interface
- * RUNTIMESERVICE - prototype for implementation of a runtime service interface
- * RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
- * RUNTIME_CODE - pragma macro for declaring runtime code    
- */
-
-#ifndef EFIAPI                  /* Forces EFI calling conventions reguardless of compiler options */
-#if _MSC_EXTENSIONS
-#define EFIAPI __cdecl
-#else
-#define EFIAPI
-#endif
+//
+// EFIAPI - prototype calling convention for EFI function pointers
+// BOOTSERVICE - prototype for implementation of a boot service interface
+// RUNTIMESERVICE - prototype for implementation of a runtime service interface
+// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
+// RUNTIME_CODE - pragma macro for declaring runtime code    
+//
+
+#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
+    #if _MSC_EXTENSIONS
+        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
+    #else
+        #define EFIAPI          // Substitute expresion to force C calling convention 
+    #endif
 #endif
 
 #define BOOTSERVICE
@@ -108,27 +172,48 @@
 
 #define RUNTIME_CODE(a)         alloc_text("rtcode", a)
 #define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
-#define END_RUNTIME_DATA()      data_seg("")
+#define END_RUNTIME_DATA()      data_seg()
 
 #define VOLATILE    volatile
 
-/*
- * XXX Need to find out if this is portable across compilers.
- */
-void __mf (void);                       
-#ifndef __GNUC__
-#pragma intrinsic (__mf)  
+//
+// BugBug: Need to find out if this is portable accross compliers.
+//
+void __mfa (void);                       
+#pragma intrinsic (__mfa)  
+#define MEMORY_FENCE()    __mfa()
+
+#ifdef EFI_NO_INTERFACE_DECL
+  #define EFI_FORWARD_DECLARATION(x)
+  #define EFI_INTERFACE_DECL(x)
+#else
+  #define EFI_FORWARD_DECLARATION(x) typedef struct _##x x
+  #define EFI_INTERFACE_DECL(x) typedef struct x
 #endif
-#define MEMORY_FENCE()    __mf()
 
-/*
- * When build similiar to FW, then link everything together as
- * one big module.
- */
+//
+// When build similiar to FW, then link everything together as
+// one big module.
+//
 
 #define EFI_DRIVER_ENTRY_POINT(InitFunction)
 
 #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
-        (_if)->LoadInternal(type, name, entry)
+            (_if)->LoadInternal(type, name, entry)
+//        entry(NULL, ST)
 
+#ifdef __FreeBSD__
 #define INTERFACE_DECL(x) struct x
+#else
+//
+// Some compilers don't support the forward reference construct:
+//  typedef struct XXXXX
+//
+// The following macro provide a workaround for such cases.
+//
+#ifdef NO_INTERFACE_DECL
+#define INTERFACE_DECL(x)
+#else
+#define INTERFACE_DECL(x) typedef struct x
+#endif
+#endif
Index: efi/include/ia64/pe.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/include/ia64/pe.h,v
retrieving revision 1.1
diff -u -r1.1 pe.h
--- efi/include/ia64/pe.h	9 Jun 2001 16:49:50 -0000	1.1
+++ efi/include/ia64/pe.h	2 Nov 2006 02:42:48 -0000
@@ -1,4 +1,4 @@
-/* $FreeBSD: src/sys/boot/efi/include/ia64/pe.h,v 1.1 2001/06/09 16:49:50 dfr Exp $ */
+/* $FreeBSD: src/sys/boot/efi/include/ia64/pe.h,v 1.2 2006/11/02 02:42:48 marcel Exp $ */
 /* 
     PE32+ header file
  */
@@ -595,4 +595,43 @@
     PIMAGE_THUNK_DATA FirstThunk;
 } IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
 
+#define IMAGE_DEBUG_TYPE_CODEVIEW   2
+
+typedef struct {
+  UINT32    Characteristics;
+  UINT32    TimeDateStamp;
+  UINT16    MajorVersion;
+  UINT16    MinorVersion;
+  UINT32    Type;
+  UINT32    SizeOfData;
+  UINT32    RVA;
+  UINT32    FileOffset;
+} IMAGE_DEBUG_DIRECTORY_ENTRY;
+
+#define CODEVIEW_SIGNATURE_NB10  0x3031424E // "NB10"
+
+typedef struct {
+  UINT32    Signature; // "NB10"
+  UINT32    Unknown;
+  UINT32    Unknown2;
+  UINT32    Unknown3;     
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY;
+
+#define CODEVIEW_SIGNATURE_RSDS  0x53445352 // "RSDS"
+
+typedef struct {
+  UINT32    Signature; // "RSDS"
+  UINT32    Unknown;
+  UINT32    Unknown2;
+  UINT32    Unknown3;     
+  UINT32    Unknown4;     
+  UINT32    Unknown5;     
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY;
+
 #endif
Index: efi/libefi/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/libefi/Makefile,v
retrieving revision 1.16
diff -u -r1.16 Makefile
--- efi/libefi/Makefile	28 Nov 2004 00:30:22 -0000	1.16
+++ efi/libefi/Makefile	5 Nov 2006 22:03:03 -0000
@@ -1,27 +1,16 @@
-# $FreeBSD: src/sys/boot/efi/libefi/Makefile,v 1.16 2004/11/28 00:30:22 marcel Exp $
-
-.PATH: ${.CURDIR}/../../../${MACHINE_ARCH}/${MACHINE_ARCH}
+# $FreeBSD: src/sys/boot/efi/libefi/Makefile,v 1.17 2006/11/05 22:03:03 marcel Exp $
 
 LIB=	efi
 INTERNALLIB=
 
-SRCS=	bootinfo.c copy.c delay.c devicename.c efi_console.c efifs.c efinet.c \
-	elf_freebsd.c libefi.c module.c time.c
-
-.if ${MACHINE_ARCH} == "ia64"
-SRCS+=	efifpswa.c pal.S
-.endif
+SRCS=	delay.c efi_console.c efifs.c efinet.c errno.c handles.c libefi.c \
+	time.c
 
 CFLAGS+= -I${.CURDIR}/../include
-CFLAGS+= -I${.CURDIR}/../include/${MACHINE_ARCH}
+CFLAGS+= -I${.CURDIR}/../include/${MACHINE_ARCH:S/amd64/i386/}
 CFLAGS+= -I${.CURDIR}/../../../../lib/libstand
 
 # Pick up the bootstrap header for some interface items
 CFLAGS+= -I${.CURDIR}/../../common
 
-# Make the disk code more talkative
-.if defined(BOOT_DISK_DEBUG)
-CFLAGS+= -DDISK_DEBUG
-.endif
-
 .include <bsd.lib.mk>
Index: efi/libefi/efifs.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/libefi/efifs.c,v
retrieving revision 1.8
diff -u -r1.8 efifs.c
--- efi/libefi/efifs.c	2 Aug 2003 08:22:03 -0000	1.8
+++ efi/libefi/efifs.c	5 Nov 2006 22:03:03 -0000
@@ -1,5 +1,6 @@
 /*-
  * Copyright (c) 2001 Doug Rabson
+ * Copyright (c) 2006 Marcel Moolenaar
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -22,88 +23,100 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- *
- * $FreeBSD: src/sys/boot/efi/libefi/efifs.c,v 1.8 2003/08/02 08:22:03 marcel Exp $
  */
 
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/boot/efi/libefi/efifs.c,v 1.10 2006/11/05 22:03:03 marcel Exp $");
+
 #include <sys/param.h>
 #include <sys/time.h>
 #include <stddef.h>
-#include <stand.h>
 #include <stdarg.h>
 
+#include <bootstrap.h>
+
 #include <efi.h>
 #include <efilib.h>
-#include "efiboot.h"
+#include <efiprot.h>
 
 /* Perform I/O in blocks of size EFI_BLOCK_SIZE. */
 #define	EFI_BLOCK_SIZE	(1024 * 1024)
 
+union fileinfo {
+	EFI_FILE_INFO info;
+	char bytes[sizeof(EFI_FILE_INFO) + 508];
+};
+
+static EFI_GUID sfs_guid = SIMPLE_FILE_SYSTEM_PROTOCOL;
+static EFI_GUID fs_guid = EFI_FILE_SYSTEM_INFO_ID;
+static EFI_GUID fi_guid = EFI_FILE_INFO_ID;
+
 static int
 efifs_open(const char *upath, struct open_file *f)
 {
-	struct efi_devdesc *dev = f->f_devdata;
-	static EFI_GUID sfsid = SIMPLE_FILE_SYSTEM_PROTOCOL;
-	EFI_FILE_IO_INTERFACE *sfs;
-	EFI_FILE *root;
-	EFI_FILE *file;
+	struct devdesc *dev = f->f_devdata;
+	EFI_FILE_IO_INTERFACE *fsif;
+	EFI_FILE *file, *root;
+	EFI_HANDLE h;
 	EFI_STATUS status;
-	CHAR16 *cp;
-	CHAR16 *path;
+	CHAR16 *cp, *path;
+
+	if (f->f_dev != &efifs_dev || dev->d_unit < 0)
+		return (EINVAL);
+
+	h = efi_find_handle(f->f_dev, dev->d_unit);
+	if (h == NULL)
+		return (EINVAL);
 
-	/*
-	 * We cannot blindly assume that f->f_devdata points to a
-	 * efi_devdesc structure. Before we dereference 'dev', make
-	 * sure that the underlying device is ours.
-	 */
-	if (f->f_dev != &efifs_dev || dev->d_handle == NULL)
-		return ENOENT;
+	status = BS->HandleProtocol(h, &sfs_guid, (VOID **)&fsif);
+	if (EFI_ERROR(status))
+		return (efi_status_to_errno(status));
 
-	status = BS->HandleProtocol(dev->d_handle, &sfsid, (VOID **)&sfs);
+	/* Get the root directory. */
+	status = fsif->OpenVolume(fsif, &root);
 	if (EFI_ERROR(status))
-		return ENOENT;
+		return (efi_status_to_errno(status));
 
-	/*
-	 * Find the root directory.
-	 */
-	status = sfs->OpenVolume(sfs, &root);
-
-	/*
-	 * Convert path to CHAR16, skipping leading separators.
-	 */
 	while (*upath == '/')
 		upath++;
-	if (!*upath) {
-		/* Opening the root directory, */
+
+	/* Special case: opening the root directory. */
+	if (*upath == '\0') {
 		f->f_fsdata = root;
-		return 0;
+		return (0);
+	}
+
+	path = malloc((strlen(upath) + 1) * sizeof(CHAR16));
+	if (path == NULL) {
+		root->Close(root);
+		return (ENOMEM);
 	}
-	cp = path = malloc((strlen(upath) + 1) * sizeof(CHAR16));
-	if (path == NULL)
-		return ENOMEM;
-	while (*upath) {
-		if (*upath == '/')
+
+	cp = path;
+	while (*upath != '\0') {
+		if (*upath == '/') {
 			*cp = '\\';
-		else
+			while (upath[1] == '/')
+				upath++;
+		} else
 			*cp = *upath;
 		upath++;
 		cp++;
 	}
-	*cp++ = 0;
+	*cp = 0;
 
-	/*
-	 * Try to open it.
-	 */
-	status = root->Open(root, &file, path, EFI_FILE_MODE_READ, 0);
+	/* Open the file. */
+	status = root->Open(root, &file, path,
+	    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
+	if (status == EFI_ACCESS_DENIED || status == EFI_WRITE_PROTECTED)
+		status = root->Open(root, &file, path, EFI_FILE_MODE_READ, 0);
 	free(path);
-	if (EFI_ERROR(status)) {
-		root->Close(root);
-		return ENOENT;
-	}
-
 	root->Close(root);
+	if (EFI_ERROR(status))
+		return (efi_status_to_errno(status));
+
 	f->f_fsdata = file;
-	return 0;
+	return (0);
 }
 
 static int
@@ -111,8 +124,12 @@
 {
 	EFI_FILE *file = f->f_fsdata;
 
+	if (file == NULL)
+		return (EBADF);
+
 	file->Close(file);
-	return 0;
+	f->f_fsdata = NULL;
+	return (0);
 }
 
 static int
@@ -123,15 +140,17 @@
 	UINTN sz = size;
 	char *bufp;
 
+	if (file == NULL)
+		return (EBADF);
+
 	bufp = buf;
 	while (size > 0) {
 		sz = size;
 		if (sz > EFI_BLOCK_SIZE)
 			sz = EFI_BLOCK_SIZE;
 		status = file->Read(file, &sz, bufp);
-		twiddle();
 		if (EFI_ERROR(status))
-			return EIO;
+			return (efi_status_to_errno(status));
 		if (sz == 0)
 			break;
 		size -= sz;
@@ -139,7 +158,7 @@
 	}
 	if (resid)
 		*resid = size;
-	return 0;
+	return (0);
 }
 
 static int
@@ -150,15 +169,17 @@
 	UINTN sz = size;
 	char *bufp;
 
+	if (file == NULL)
+		return (EBADF);
+
 	bufp = buf;
 	while (size > 0) {
 		sz = size;
 		if (sz > EFI_BLOCK_SIZE)
 			sz = EFI_BLOCK_SIZE;
 		status = file->Write(file, &sz, bufp);
-		twiddle();
 		if (EFI_ERROR(status))
-			return EIO;
+			return (efi_status_to_errno(status));
 		if (sz == 0)
 			break;
 		size -= sz;
@@ -166,7 +187,7 @@
 	}
 	if (resid)
 		*resid = size;
-	return 0;
+	return (0);
 }
 
 static off_t
@@ -175,156 +196,139 @@
 	EFI_FILE *file = f->f_fsdata;
 	EFI_STATUS status;
 	UINT64 base;
-	UINTN sz;
-	static EFI_GUID infoid = EFI_FILE_INFO_ID;
-	EFI_FILE_INFO info;
+
+	if (file == NULL)
+		return (EBADF);
 
 	switch (where) {
 	case SEEK_SET:
-		base = 0;
 		break;
 
+	case SEEK_END:
+		status = file->SetPosition(file, ~0ULL);
+		if (EFI_ERROR(status))
+			return (-1);
+		/* FALLTHROUGH */
+
 	case SEEK_CUR:
 		status = file->GetPosition(file, &base);
 		if (EFI_ERROR(status))
-			return -1;
+			return (-1);
+		offset = (off_t)(base + offset);
 		break;
 
-	case SEEK_END:
-		sz = sizeof(info);
-		status = file->GetInfo(file, &infoid, &sz, &info);
-		if (EFI_ERROR(status))
-			return -1;
-		base = info.FileSize;
-		break;
+	default:
+		return (-1);
 	}
+	if (offset < 0)
+		return (-1);
 
-	status = file->SetPosition(file, base + offset);
-	if (EFI_ERROR(status))
-		return -1;
-	file->GetPosition(file, &base);
-
-	return base;
+	status = file->SetPosition(file, (UINT64)offset);
+	return (EFI_ERROR(status) ? -1 : offset);
 }
 
 static int
 efifs_stat(struct open_file *f, struct stat *sb)
 {
 	EFI_FILE *file = f->f_fsdata;
+	union fileinfo fi;
 	EFI_STATUS status;
-	char *buf;
 	UINTN sz;
-	static EFI_GUID infoid = EFI_FILE_INFO_ID;
-	EFI_FILE_INFO *info;
-
-	bzero(sb, sizeof(*sb));
 
-	buf = malloc(1024);
-	sz = 1024;
+	if (file == NULL)
+		return (EBADF);
 
-	status = file->GetInfo(file, &infoid, &sz, buf);
-	if (EFI_ERROR(status)) {
-		free(buf);
-		return -1;
-	}
+	bzero(sb, sizeof(*sb));
 
-	info = (EFI_FILE_INFO *) buf;
+	sz = sizeof(fi);
+	status = file->GetInfo(file, &fi_guid, &sz, &fi);
+	if (EFI_ERROR(status))
+		return (efi_status_to_errno(status));
 
-	if (info->Attribute & EFI_FILE_READ_ONLY)
-		sb->st_mode = S_IRUSR;
-	else
-		sb->st_mode = S_IRUSR | S_IWUSR;
-	if (info->Attribute & EFI_FILE_DIRECTORY)
+	sb->st_mode = S_IRUSR | S_IRGRP | S_IROTH;
+	if ((fi.info.Attribute & EFI_FILE_READ_ONLY) == 0)
+		sb->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
+	if (fi.info.Attribute & EFI_FILE_DIRECTORY)
 		sb->st_mode |= S_IFDIR;
 	else
 		sb->st_mode |= S_IFREG;
-	sb->st_size = info->FileSize;
-
-	free(buf);
-	return 0;
+	sb->st_nlink = 1;
+	sb->st_atime = efi_time(&fi.info.LastAccessTime);
+	sb->st_mtime = efi_time(&fi.info.ModificationTime);
+	sb->st_ctime = efi_time(&fi.info.CreateTime);
+	sb->st_size = fi.info.FileSize;
+	sb->st_blocks = fi.info.PhysicalSize / S_BLKSIZE;
+	sb->st_blksize = S_BLKSIZE;
+	sb->st_birthtime = sb->st_ctime;
+	return (0);
 }
 
 static int
 efifs_readdir(struct open_file *f, struct dirent *d)
 {
 	EFI_FILE *file = f->f_fsdata;
+	union fileinfo fi;
 	EFI_STATUS status;
-	char *buf;
 	UINTN sz;
-	EFI_FILE_INFO *info;
 	int i;
 
-	buf = malloc(1024);
-	sz = 1024;
-
-	status = file->Read(file, &sz, buf);
-	if (EFI_ERROR(status) || sz < offsetof(EFI_FILE_INFO, FileName))
-	    return ENOENT;
+	if (file == NULL)
+		return (EBADF);
 
-	info = (EFI_FILE_INFO *) buf;
+	sz = sizeof(fi);
+	status = file->Read(file, &sz, &fi);
+	if (EFI_ERROR(status))
+		return (efi_status_to_errno(status));
+	if (sz == 0)
+		return (ENOENT);
 
 	d->d_fileno = 0;
 	d->d_reclen = sizeof(*d);
-	if (info->Attribute & EFI_FILE_DIRECTORY)
+	if (fi.info.Attribute & EFI_FILE_DIRECTORY)
 		d->d_type = DT_DIR;
 	else
 		d->d_type = DT_REG;
-	d->d_namlen = ((info->Size - offsetof(EFI_FILE_INFO, FileName))
-		       / sizeof(CHAR16));
-	for (i = 0; i < d->d_namlen; i++)
-		d->d_name[i] = info->FileName[i];
+	for (i = 0; fi.info.FileName[i] != 0; i++)
+		d->d_name[i] = fi.info.FileName[i];
 	d->d_name[i] = 0;
-
-	free(buf);
-	return 0;
+	d->d_namlen = i;
+	return (0);
 }
 
-struct fs_ops efi_fsops = {
-	"fs",
-	efifs_open,
-	efifs_close,
-	efifs_read,
-	efifs_write,
-	efifs_seek,
-	efifs_stat,
-	efifs_readdir
+struct fs_ops efifs_fsops = {
+	.fs_name = "efifs",
+	.fo_open = efifs_open,
+	.fo_close = efifs_close,
+	.fo_read = efifs_read,
+	.fo_write = efifs_write,
+	.fo_seek = efifs_seek,
+	.fo_stat = efifs_stat,
+	.fo_readdir = efifs_readdir
 };
 
-static EFI_HANDLE *fs_handles;
-UINTN fs_handle_count;
-
-int
-efifs_get_unit(EFI_HANDLE h)
-{
-	UINTN u;
-
-	u = 0;
-	while (u < fs_handle_count && fs_handles[u] != h)
-		u++;
-	return ((u < fs_handle_count) ? u : -1);
-}
-
 static int
 efifs_dev_init(void) 
 {
-	EFI_STATUS	status;
-	UINTN		sz;
-	static EFI_GUID sfsid = SIMPLE_FILE_SYSTEM_PROTOCOL;
+	EFI_HANDLE *handles;
+	EFI_STATUS status;
+	UINTN sz;
+	int err;
 
 	sz = 0;
-	status = BS->LocateHandle(ByProtocol, &sfsid, 0, &sz, 0);
-	if (status != EFI_BUFFER_TOO_SMALL)
-		return ENOENT;
-	fs_handles = (EFI_HANDLE *) malloc(sz);
-	status = BS->LocateHandle(ByProtocol, &sfsid, 0,
-				  &sz, fs_handles);
-	if (EFI_ERROR(status)) {
-		free(fs_handles);
-		return ENOENT;
+	status = BS->LocateHandle(ByProtocol, &sfs_guid, 0, &sz, 0);
+	if (status == EFI_BUFFER_TOO_SMALL) {
+		handles = (EFI_HANDLE *)malloc(sz);
+		status = BS->LocateHandle(ByProtocol, &sfs_guid, 0, &sz,
+		    handles);
+		if (EFI_ERROR(status))
+			free(handles);
 	}
-	fs_handle_count = sz / sizeof(EFI_HANDLE);
-
-	return 0;
+	if (EFI_ERROR(status))
+		return (efi_status_to_errno(status));
+	err = efi_register_handles(&efifs_dev, handles,
+	    sz / sizeof(EFI_HANDLE));
+	free(handles);
+	return (err);
 }
 
 /*
@@ -333,14 +337,55 @@
 static void
 efifs_dev_print(int verbose)
 {
-	int		i;
-	char		line[80];
+	union {
+		EFI_FILE_SYSTEM_INFO info;
+		char buffer[1024];
+	} fi;
+	char line[80];
+	EFI_FILE_IO_INTERFACE *fsif;
+	EFI_FILE *volume;
+	EFI_HANDLE h;
+	EFI_STATUS status;
+	UINTN sz;
+	int i, unit;
 
-	for (i = 0; i < fs_handle_count; i++) {
-		sprintf(line, "    fs%d:   EFI filesystem", i);
+	for (unit = 0, h = efi_find_handle(&efifs_dev, 0);
+	    h != NULL; h = efi_find_handle(&efifs_dev, ++unit)) {
+		sprintf(line, "    %s%d: ", efifs_dev.dv_name, unit);
 		pager_output(line);
-		/* XXX more detail? */
+
+		status = BS->HandleProtocol(h, &sfs_guid, (VOID **)&fsif);
+		if (EFI_ERROR(status))
+			goto err;
+
+		status = fsif->OpenVolume(fsif, &volume);
+		if (EFI_ERROR(status))
+			goto err;
+
+		sz = sizeof(fi);
+		status = volume->GetInfo(volume, &fs_guid, &sz, &fi);
+		volume->Close(volume);
+		if (EFI_ERROR(status))
+			goto err;
+
+		if (fi.info.ReadOnly)
+			pager_output("[RO] ");
+		else
+			pager_output("     ");
+		for (i = 0; fi.info.VolumeLabel[i] != 0; i++)
+			fi.buffer[i] = fi.info.VolumeLabel[i];
+		fi.buffer[i] = 0;
+		if (fi.buffer[0] != 0)
+			pager_output(fi.buffer);
+		else
+			pager_output("EFI filesystem");
 		pager_output("\n");
+		continue;
+
+	err:
+		sprintf(line, "[--] error %d: unable to obtain information\n",
+		    efi_status_to_errno(status));
+		pager_output(line);
 	}
 }
 
@@ -357,45 +402,40 @@
 static int 
 efifs_dev_open(struct open_file *f, ...)
 {
-	va_list			args;
-	struct efi_devdesc	*dev;
-	int			unit;
+	va_list		args;
+	struct devdesc	*dev;
 
 	va_start(args, f);
-	dev = va_arg(args, struct efi_devdesc*);
+	dev = va_arg(args, struct devdesc*);
 	va_end(args);
 
-	unit = dev->d_kind.efidisk.unit;
-	if (unit < 0 || unit >= fs_handle_count) {
-		printf("attempt to open nonexistent EFI filesystem\n");
+	if (dev->d_unit < 0)
 		return(ENXIO);
-	}
-
-	dev->d_handle = fs_handles[unit];
-
-	return 0;
+	return (0);
 }
 
 static int 
 efifs_dev_close(struct open_file *f)
 {
 
-	return 0;
+	return (0);
 }
 
 static int 
 efifs_dev_strategy(void *devdata, int rw, daddr_t dblk, size_t size, char *buf, size_t *rsize)
 {
-	return 0;
+
+	return (ENOSYS);
 }
 
 struct devsw efifs_dev = {
-	"fs", 
-	DEVT_DISK, 
-	efifs_dev_init,
-	efifs_dev_strategy, 
-	efifs_dev_open, 
-	efifs_dev_close, 
-	noioctl,
-	efifs_dev_print
+	.dv_name = "fs", 
+	.dv_type = DEVT_DISK, 
+	.dv_init = efifs_dev_init,
+	.dv_strategy = efifs_dev_strategy, 
+	.dv_open = efifs_dev_open, 
+	.dv_close = efifs_dev_close, 
+	.dv_ioctl = noioctl,
+	.dv_print = efifs_dev_print,
+	.dv_cleanup = NULL
 };
Index: efi/libefi/efinet.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/libefi/efinet.c,v
retrieving revision 1.6
diff -u -r1.6 efinet.c
--- efi/libefi/efinet.c	4 Jan 2004 23:28:16 -0000	1.6
+++ efi/libefi/efinet.c	5 Nov 2006 22:03:03 -0000
@@ -1,5 +1,6 @@
 /*-
  * Copyright (c) 2001 Doug Rabson
+ * Copyright (c) 2002, 2006 Marcel Moolenaar
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -25,7 +26,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/efi/libefi/efinet.c,v 1.6 2004/01/04 23:28:16 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/efi/libefi/efinet.c,v 1.7 2006/11/05 22:03:03 marcel Exp $");
 
 #include <sys/param.h>
 #include <netinet/in.h>
@@ -35,10 +36,31 @@
 #include <net.h>
 #include <netif.h>
 
+#include <dev_net.c>
+
 #include <efi.h>
 #include <efilib.h>
 
-extern struct netif_driver efi_net;
+static EFI_GUID sn_guid = EFI_SIMPLE_NETWORK_PROTOCOL;
+
+static void efinet_end(struct netif *);
+static int efinet_get(struct iodesc *, void *, size_t, time_t);
+static void efinet_init(struct iodesc *, void *);
+static int efinet_match(struct netif *, void *);
+static int efinet_probe(struct netif *, void *);
+static int efinet_put(struct iodesc *, void *, size_t);
+
+struct netif_driver efinetif = {   
+	.netif_bname = "efinet",
+	.netif_match = efinet_match,
+	.netif_probe = efinet_probe,
+	.netif_init = efinet_init,
+	.netif_get = efinet_get,
+	.netif_put = efinet_put,
+	.netif_end = efinet_end,
+	.netif_ifs = NULL,
+	.netif_nifs = 0
+};
 
 #ifdef EFINET_DEBUG
 static void
@@ -74,21 +96,21 @@
 }
 #endif
 
-int
+static int
 efinet_match(struct netif *nif, void *machdep_hint)
 {
 
 	return (1);
 }
 
-int
+static int
 efinet_probe(struct netif *nif, void *machdep_hint)
 {
 
 	return (0);
 }
 
-int
+static int
 efinet_put(struct iodesc *desc, void *pkt, size_t len)
 {
 	struct netif *nif = desc->io_netif;
@@ -100,7 +122,7 @@
 
 	status = net->Transmit(net, 0, len, pkt, 0, 0, 0);
 	if (status != EFI_SUCCESS)
-		return -1;
+		return (-1);
 
 	/* Wait for the buffer to be transmitted */
 	do {
@@ -113,11 +135,10 @@
 	} while (status == EFI_SUCCESS && buf == 0);
 
 	/* XXX How do we deal with status != EFI_SUCCESS now? */
-	return (status == EFI_SUCCESS) ? len : -1;
+	return ((status == EFI_SUCCESS) ? len : -1);
 }
 
-
-int
+static int
 efinet_get(struct iodesc *desc, void *pkt, size_t len, time_t timeout)
 {
 	struct netif *nif = desc->io_netif;
@@ -143,30 +164,37 @@
 			if (bufsz > len)
 				bufsz = len;
 			bcopy(buf, pkt, bufsz);
-			return bufsz;
+			return (bufsz);
 		}
 		if (status != EFI_NOT_READY)
-			return 0;
+			return (0);
 	}
 
-	return 0;
+	return (0);
 }
 
-void
+static void
 efinet_init(struct iodesc *desc, void *machdep_hint)
 {
 	struct netif *nif = desc->io_netif;
 	EFI_SIMPLE_NETWORK *net;
+	EFI_HANDLE h;
 	EFI_STATUS status;
 
-	net = nif->nif_driver->netif_ifs[nif->nif_unit].dif_private;
-	nif->nif_devdata = net;
+	h = nif->nif_driver->netif_ifs[nif->nif_unit].dif_private;
+	status = BS->HandleProtocol(h, &sn_guid, (VOID **)&nif->nif_devdata);
+	if (status != EFI_SUCCESS) {
+		printf("net%d: cannot start interface (status=%ld)\n",
+		    nif->nif_unit, (long)status);
+		return;
+	}
 
+	net = nif->nif_devdata;
 	if (net->Mode->State == EfiSimpleNetworkStopped) {
 		status = net->Start(net);
 		if (status != EFI_SUCCESS) {
 			printf("net%d: cannot start interface (status=%ld)\n",
-			    nif->nif_unit, status);
+			    nif->nif_unit, (long)status);
 			return;
 		}
 	}
@@ -175,7 +203,7 @@
 		status = net->Initialize(net, 0, 0);
 		if (status != EFI_SUCCESS) {
 			printf("net%d: cannot init. interface (status=%ld)\n",
-			    nif->nif_unit, status);
+			    nif->nif_unit, (long)status);
 			return;
 		}
 	}
@@ -187,7 +215,7 @@
 		status = net->ReceiveFilters(net, mask, 0, FALSE, 0, 0);
 		if (status != EFI_SUCCESS) {
 			printf("net%d: cannot set rx. filters (status=%ld)\n",
-			    nif->nif_unit, status);
+			    nif->nif_unit, (long)status);
 			return;
 		}
 	}
@@ -198,71 +226,84 @@
 
 	bcopy(net->Mode->CurrentAddress.Addr, desc->myea, 6);
 	desc->xid = 1;
+}
+
+static void
+efinet_end(struct netif *nif)
+{
+	EFI_SIMPLE_NETWORK *net = nif->nif_devdata; 
 
-	return;
+	net->Shutdown(net);
 }
 
-void
-efinet_init_driver()
+static int efinet_dev_init(void);
+static void efinet_dev_print(int);
+
+struct devsw efinet_dev = {
+	.dv_name = "net",
+	.dv_type = DEVT_NET,
+	.dv_init = efinet_dev_init,
+	.dv_strategy = net_strategy,
+	.dv_open = net_open,
+	.dv_close = net_close,
+	.dv_ioctl = noioctl,
+	.dv_print = efinet_dev_print,
+	.dv_cleanup = NULL
+};
+
+static int
+efinet_dev_init()
 {
-	EFI_STATUS	status;
-	UINTN		sz;
-	static EFI_GUID netid = EFI_SIMPLE_NETWORK_PROTOCOL;
-	EFI_HANDLE	*handles;
-	int		nifs, i;
-#define MAX_INTERFACES	4
-	static struct netif_dif difs[MAX_INTERFACES];
-	static struct netif_stats stats[MAX_INTERFACES];
+	struct netif_dif *dif;
+	struct netif_stats *stats;
+	EFI_HANDLE *handles;
+	EFI_STATUS status;
+	UINTN sz;
+	int err, i, nifs;
 
 	sz = 0;
-	status = BS->LocateHandle(ByProtocol, &netid, 0, &sz, 0);
-	if (status != EFI_BUFFER_TOO_SMALL)
-		return;
-	handles = (EFI_HANDLE *) malloc(sz);
-	status = BS->LocateHandle(ByProtocol, &netid, 0, &sz, handles);
-	if (EFI_ERROR(status)) {
-		free(handles);
-		return;
+	status = BS->LocateHandle(ByProtocol, &sn_guid, 0, &sz, 0);
+	if (status == EFI_BUFFER_TOO_SMALL) {
+		handles = (EFI_HANDLE *)malloc(sz);
+		status = BS->LocateHandle(ByProtocol, &sn_guid, 0, &sz,
+		    handles);
+		if (EFI_ERROR(status))
+			free(handles);
 	}
-
+	if (EFI_ERROR(status))
+		return (efi_status_to_errno(status));
 	nifs = sz / sizeof(EFI_HANDLE);
-	if (nifs > MAX_INTERFACES)
-		nifs = MAX_INTERFACES;
+	err = efi_register_handles(&efinet_dev, handles, nifs);
+	free(handles);
+	if (err != 0)
+		return (err);
+
+	efinetif.netif_nifs = nifs;
+	efinetif.netif_ifs = calloc(nifs, sizeof(struct netif_dif));
 
-	efi_net.netif_nifs = nifs;
-	efi_net.netif_ifs = difs;
+	stats = calloc(nifs, sizeof(struct netif_stats));
 
-	bzero(stats, sizeof(stats));
 	for (i = 0; i < nifs; i++) {
-		struct netif_dif *dif = &efi_net.netif_ifs[i];
+		dif = &efinetif.netif_ifs[i];
 		dif->dif_unit = i;
 		dif->dif_nsel = 1;
 		dif->dif_stats = &stats[i];
-
-		BS->HandleProtocol(handles[i], &netid,
-				   (VOID**) &dif->dif_private);
+		dif->dif_private = efi_find_handle(&efinet_dev, i);
 	}
 
-	return;
+	return (0);
 }
 
-void
-efinet_end(struct netif *nif)
+static void
+efinet_dev_print(int verbose)
 {
-	EFI_SIMPLE_NETWORK *net = nif->nif_devdata;
-
-	net->Shutdown(net);
+	char line[80];
+	EFI_HANDLE h;
+	int unit;
+
+	for (unit = 0, h = efi_find_handle(&efinet_dev, 0);
+	    h != NULL; h = efi_find_handle(&efinet_dev, ++unit)) {
+		sprintf(line, "    %s%d:\n", efinet_dev.dv_name, unit);
+		pager_output(line);
+	}
 }
-
-struct netif_driver efi_net = {
-	"net",			/* netif_bname */
-	efinet_match,		/* netif_match */
-	efinet_probe,		/* netif_probe */
-	efinet_init,		/* netif_init */
-	efinet_get,		/* netif_get */
-	efinet_put,		/* netif_put */
-	efinet_end,		/* netif_end */
-	0,			/* netif_ifs */
-	0			/* netif_nifs */
-};
-
Index: efi/libefi/libefi.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/libefi/libefi.c,v
retrieving revision 1.6
diff -u -r1.6 libefi.c
--- efi/libefi/libefi.c	3 Apr 2003 21:36:29 -0000	1.6
+++ efi/libefi/libefi.c	3 Nov 2006 04:19:31 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/efi/libefi/libefi.c,v 1.6 2003/04/03 21:36:29 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/efi/libefi/libefi.c,v 1.7 2006/11/03 04:19:31 marcel Exp $");
 
 #include <efi.h>
 #include <efilib.h>
@@ -98,7 +98,7 @@
 	if (status != EFI_SUCCESS)
 		BS->Exit(IH, status, 0, NULL);
 
-	setheap((void *)heap, (void *)(heap + heapsize));
+	setheap((void *)(uintptr_t)heap, (void *)(uintptr_t)(heap + heapsize));
 
 	/* Use exit() from here on... */
 
Index: efi/libefi/time.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/efi/libefi/time.c,v
retrieving revision 1.5
diff -u -r1.5 time.c
--- efi/libefi/time.c	5 Jan 2005 22:16:57 -0000	1.5
+++ efi/libefi/time.c	5 Nov 2006 22:03:03 -0000
@@ -39,7 +39,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/efi/libefi/time.c,v 1.5 2005/01/05 22:16:57 imp Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/efi/libefi/time.c,v 1.6 2006/11/05 22:03:03 marcel Exp $");
 
 #include <efi.h>
 #include <efilib.h>
@@ -59,7 +59,7 @@
 #define SECSPERDAY	(24 * SECSPERHOUR)
 
 time_t
-EfiTimeToUnixTime(EFI_TIME *ETime)
+efi_time(EFI_TIME *ETime)
 {
     /*
     //  These arrays give the cumulative number of days up to the first of the
@@ -170,15 +170,15 @@
 	OUT struct timezone *tzp
 	)
 {
-	EFI_TIME				EfiTime;
+	EFI_TIME		EfiTime;
 	EFI_TIME_CAPABILITIES	Capabilities;
-	EFI_STATUS				Status;
+	EFI_STATUS		Status;
 
 	/*
 	//  Get time from EFI
 	*/
 
-	Status = RS->GetTime( &EfiTime, &Capabilities );
+	Status = RS->GetTime(&EfiTime, &Capabilities);
 	if (EFI_ERROR(Status))
 		return (-1);
 
@@ -186,7 +186,7 @@
 	//  Convert to UNIX time (ie seconds since the epoch
 	*/
 
-	tp->tv_sec  = EfiTimeToUnixTime( &EfiTime );
+	tp->tv_sec  = efi_time( &EfiTime );
 	tp->tv_usec = 0; /* EfiTime.Nanosecond * 1000; */
 
 	/*
Index: ficl/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/Makefile,v
retrieving revision 1.41.2.1
diff -u -r1.41.2.1 Makefile
--- ficl/Makefile	25 Oct 2006 15:03:29 -0000	1.41.2.1
+++ ficl/Makefile	28 Sep 2006 10:02:03 -0000
@@ -1,4 +1,4 @@
-# $FreeBSD: src/sys/boot/ficl/Makefile,v 1.41.2.1 2006/10/25 15:03:29 jhb Exp $
+# $FreeBSD: src/sys/boot/ficl/Makefile,v 1.44 2006/09/28 10:02:03 ru Exp $
 #
 .PATH: ${.CURDIR}/${MACHINE_ARCH:S/amd64/i386/}
 BASE_SRCS=	dict.c ficl.c fileaccess.c float.c loader.c math64.c \
@@ -7,13 +7,13 @@
 SRCS=		${BASE_SRCS} sysdep.c softcore.c
 CLEANFILES=	softcore.c testmain testmain.o
 CFLAGS+=	-ffreestanding
-.if ${MACHINE_ARCH} == "alpha"
-CFLAGS+=	-mno-fp-regs -Os
-.endif
 .if ${MACHINE_ARCH} == "i386" || ${MACHINE_ARCH} == "amd64"
 CFLAGS+=	-mpreferred-stack-boundary=2
 CFLAGS+=	-mno-mmx -mno-3dnow -mno-sse -mno-sse2
 .endif
+.if ${MACHINE_ARCH} == "i386"
+CFLAGS+=	-mno-sse3
+.endif
 .if ${MACHINE_ARCH} == "powerpc"
 CFLAGS+=	-msoft-float
 .endif
Index: ficl/ficl.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/ficl.h,v
retrieving revision 1.21
diff -u -r1.21 ficl.h
--- ficl/ficl.h	30 Nov 2004 11:35:30 -0000	1.21
+++ ficl/ficl.h	23 Mar 2007 22:26:01 -0000
@@ -41,7 +41,7 @@
 ** SUCH DAMAGE.
 */
 
-/* $FreeBSD: src/sys/boot/ficl/ficl.h,v 1.21 2004/11/30 11:35:30 scottl Exp $ */
+/* $FreeBSD: src/sys/boot/ficl/ficl.h,v 1.22 2007/03/23 22:26:01 jkim Exp $ */
 
 #if !defined (__FICL_H__)
 #define __FICL_H__
@@ -237,9 +237,9 @@
 /* 
 ** the Good Stuff starts here...
 */
-#define FICL_VER        "3.02"
+#define FICL_VER        "3.03"
 #define FICL_VER_MAJOR  3
-#define FICL_VER_MINOR  2
+#define FICL_VER_MINOR  3
 #if !defined (FICL_PROMPT)
 #define FICL_PROMPT "ok> "
 #endif
@@ -857,7 +857,7 @@
 	FICL_WORD *pDoesParen;
 	FICL_WORD *pExitInner;
 	FICL_WORD *pExitParen;
-	FICL_WORD *pIfParen;
+	FICL_WORD *pBranch0;
 	FICL_WORD *pInterpret;
 	FICL_WORD *pLitParen;
 	FICL_WORD *pTwoLitParen;
@@ -865,7 +865,9 @@
 	FICL_WORD *pPLoopParen;
 	FICL_WORD *pQDoParen;
 	FICL_WORD *pSemiParen;
+	FICL_WORD *pOfParen;
 	FICL_WORD *pStore;
+	FICL_WORD *pDrop;
 	FICL_WORD *pCStringLit;
 	FICL_WORD *pStringLit;
 
@@ -1086,6 +1088,7 @@
     IF,
     LITERAL,
     LOOP,
+    OF,
     PLOOP,
     PRIMITIVE,
     QDO,
Index: ficl/float.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/float.c,v
retrieving revision 1.1
diff -u -r1.1 float.c
--- ficl/float.c	9 Apr 2002 17:45:11 -0000	1.1
+++ ficl/float.c	23 Mar 2007 22:26:01 -0000
@@ -41,7 +41,7 @@
 ** SUCH DAMAGE.
 */
 
-/* $FreeBSD: src/sys/boot/ficl/float.c,v 1.1 2002/04/09 17:45:11 dcs Exp $ */
+/* $FreeBSD: src/sys/boot/ficl/float.c,v 1.2 2007/03/23 22:26:01 jkim Exp $ */
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -977,6 +977,8 @@
     }
 
     PUSHFLOAT(accum);
+    if (pVM->state == COMPILE)
+        fliteralIm(pVM);
 
     return(1);
 }
@@ -1062,3 +1064,4 @@
 #endif
     return;
 }
+
Index: ficl/loader.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/loader.c,v
retrieving revision 1.11
diff -u -r1.11 loader.c
--- ficl/loader.c	30 Nov 2004 11:35:30 -0000	1.11
+++ ficl/loader.c	12 May 2006 04:07:42 -0000
@@ -23,7 +23,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *	$FreeBSD: src/sys/boot/ficl/loader.c,v 1.11 2004/11/30 11:35:30 scottl Exp $
+ *	$FreeBSD: src/sys/boot/ficl/loader.c,v 1.12 2006/05/12 04:07:42 jhb Exp $
  */
 
 /*******************************************************************
@@ -691,22 +691,14 @@
     ficlSetEnv(pSys, "arch-pc98",         FICL_TRUE);
 #elif defined(__i386__)
     ficlSetEnv(pSys, "arch-i386",         FICL_TRUE);
-    ficlSetEnv(pSys, "arch-alpha",        FICL_FALSE);
-    ficlSetEnv(pSys, "arch-ia64",         FICL_FALSE);
-    ficlSetEnv(pSys, "arch-powerpc",      FICL_FALSE);
-#elif defined(__alpha__)
-    ficlSetEnv(pSys, "arch-i386",         FICL_FALSE);
-    ficlSetEnv(pSys, "arch-alpha",        FICL_TRUE);
     ficlSetEnv(pSys, "arch-ia64",         FICL_FALSE);
     ficlSetEnv(pSys, "arch-powerpc",      FICL_FALSE);
 #elif defined(__ia64__)
     ficlSetEnv(pSys, "arch-i386",         FICL_FALSE);
-    ficlSetEnv(pSys, "arch-alpha",        FICL_FALSE);
     ficlSetEnv(pSys, "arch-ia64",         FICL_TRUE);
     ficlSetEnv(pSys, "arch-powerpc",      FICL_FALSE);
 #elif defined(__powerpc__)
     ficlSetEnv(pSys, "arch-i386",         FICL_FALSE);
-    ficlSetEnv(pSys, "arch-alpha",        FICL_FALSE);
     ficlSetEnv(pSys, "arch-ia64",         FICL_FALSE);
     ficlSetEnv(pSys, "arch-powerpc",      FICL_TRUE);
 #endif
Index: ficl/tools.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/tools.c,v
retrieving revision 1.2
diff -u -r1.2 tools.c
--- ficl/tools.c	9 Apr 2002 17:45:11 -0000	1.2
+++ ficl/tools.c	23 Mar 2007 22:26:01 -0000
@@ -54,7 +54,7 @@
 ** Specify breakpoint default action
 */
 
-/* $FreeBSD: src/sys/boot/ficl/tools.c,v 1.2 2002/04/09 17:45:11 dcs Exp $ */
+/* $FreeBSD: src/sys/boot/ficl/tools.c,v 1.3 2007/03/23 22:26:01 jkim Exp $ */
 
 #ifdef TESTMAIN
 #include <stdlib.h>
@@ -244,10 +244,17 @@
                 break;                                                           
             case BRANCH:
                 c = *++pc;
-                if (c.i > 0)
+                if (c.i == 0)
+                    sprintf(cp, "repeat (branch %d)",     pc+c.i-param0);
+                else if (c.i == 1)
                     sprintf(cp, "else (branch %d)",       pc+c.i-param0);
                 else
-                    sprintf(cp, "repeat (branch %d)",     pc+c.i-param0);
+                    sprintf(cp, "endof (branch %d)",       pc+c.i-param0);
+                break;
+
+            case OF:
+                c = *++pc;
+                sprintf(cp, "of (branch %d)",       pc+c.i-param0);
                 break;
 
             case QDO:
Index: ficl/unix.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/unix.c,v
retrieving revision 1.1
diff -u -r1.1 unix.c
--- ficl/unix.c	29 Apr 2001 02:36:34 -0000	1.1
+++ ficl/unix.c	23 Mar 2007 22:26:01 -0000
@@ -1,4 +1,4 @@
-/* $FreeBSD: src/sys/boot/ficl/unix.c,v 1.1 2001/04/29 02:36:34 dcs Exp $ */
+/* $FreeBSD: src/sys/boot/ficl/unix.c,v 1.2 2007/03/23 22:26:01 jkim Exp $ */
 
 #include <string.h>
 #include <netinet/in.h>
@@ -8,9 +8,9 @@
 
 
 unsigned long ficlNtohl(unsigned long number)
-	{
-	return ntohl(number);
-	}
+{
+    return ntohl(number);
+}
 
 
 
Index: ficl/vm.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/vm.c,v
retrieving revision 1.9
diff -u -r1.9 vm.c
--- ficl/vm.c	9 Apr 2002 17:45:11 -0000	1.9
+++ ficl/vm.c	23 Mar 2007 22:26:01 -0000
@@ -47,7 +47,7 @@
 ** SUCH DAMAGE.
 */
 
-/* $FreeBSD: src/sys/boot/ficl/vm.c,v 1.9 2002/04/09 17:45:11 dcs Exp $ */
+/* $FreeBSD: src/sys/boot/ficl/vm.c,v 1.10 2007/03/23 22:26:01 jkim Exp $ */
 
 #ifdef TESTMAIN
 #include <stdlib.h>
@@ -316,15 +316,29 @@
     char *pEnd      = vmGetInBufEnd(pVM);
     STRINGINFO si;
     FICL_UNS count = 0;
-    char ch;
+    char ch = 0;
 
     pSrc = skipSpace(pSrc, pEnd);
     SI_SETPTR(si, pSrc);
 
+/*
     for (ch = *pSrc; (pEnd != pSrc) && !isspace(ch); ch = *++pSrc)
     {
         count++;
     }
+*/
+
+    /* Changed to make Purify happier.  --lch */
+    for (;;)
+    {
+        if (pEnd == pSrc)
+            break;
+        ch = *pSrc;
+        if (isspace(ch))
+            break;
+        count++;
+        pSrc++;
+    }
 
     SI_SETLEN(si, count);
 
Index: ficl/words.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/words.c,v
retrieving revision 1.39
diff -u -r1.39 words.c
--- ficl/words.c	30 Dec 2002 21:18:06 -0000	1.39
+++ ficl/words.c	23 Mar 2007 22:26:01 -0000
@@ -41,7 +41,7 @@
 ** SUCH DAMAGE.
 */
 
-/* $FreeBSD: src/sys/boot/ficl/words.c,v 1.39 2002/12/30 21:18:06 schweikh Exp $ */
+/* $FreeBSD: src/sys/boot/ficl/words.c,v 1.40 2007/03/23 22:26:01 jkim Exp $ */
 
 #ifdef TESTMAIN
 #include <stdlib.h>
@@ -71,6 +71,10 @@
 static char destTag[]  = "target";
 static char origTag[]  = "origin";
 
+static char caseTag[]  = "case";
+static char ofTag[]  = "of";
+static char fallthroughTag[]  = "fallthrough";
+
 #if FICL_WANT_LOCALS
 static void doLocalIm(FICL_VM *pVM);
 static void do2LocalIm(FICL_VM *pVM);
@@ -1220,34 +1224,26 @@
 
 
 /**************************************************************************
-                        i f C o I m
-** IMMEDIATE
-** Compiles code for a conditional branch into the dictionary
-** and pushes the branch patch address on the stack for later
-** patching by ELSE or THEN/ENDIF. 
+                        b r a n c h P a r e n
+** 
+** Runtime for "(branch)" -- expects a literal offset in the next
+** compilation address, and branches to that location.
 **************************************************************************/
 
-static void ifCoIm(FICL_VM *pVM)
+static void branchParen(FICL_VM *pVM)
 {
-    FICL_DICT *dp = vmGetDict(pVM);
-
-    assert(pVM->pSys->pIfParen);
-
-    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pIfParen));
-    markBranch(dp, pVM, origTag);
-    dictAppendUNS(dp, 1);
+    vmBranchRelative(pVM, (uintptr_t)*(pVM->ip));
     return;
 }
 
 
 /**************************************************************************
-                        i f P a r e n
-** Runtime code to do "if" or "until": pop a flag from the stack,
-** fall through if true, branch if false. Probably ought to be 
-** called (not?branch) since it does "branch if false".
+                        b r a n c h 0
+** Runtime code for "(branch0)"; pop a flag from the stack,
+** branch if 0. fall through otherwise.  The heart of "if" and "until".
 **************************************************************************/
 
-static void ifParen(FICL_VM *pVM)
+static void branch0(FICL_VM *pVM)
 {
     FICL_UNS flag;
     
@@ -1270,9 +1266,31 @@
 
 
 /**************************************************************************
+                        i f C o I m
+** IMMEDIATE COMPILE-ONLY
+** Compiles code for a conditional branch into the dictionary
+** and pushes the branch patch address on the stack for later
+** patching by ELSE or THEN/ENDIF. 
+**************************************************************************/
+
+static void ifCoIm(FICL_VM *pVM)
+{
+    FICL_DICT *dp = vmGetDict(pVM);
+
+    assert(pVM->pSys->pBranch0);
+
+    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pBranch0));
+    markBranch(dp, pVM, origTag);
+    dictAppendUNS(dp, 1);
+    return;
+}
+
+
+/**************************************************************************
                         e l s e C o I m
 ** 
-** IMMEDIATE -- compiles an "else"...
+** IMMEDIATE COMPILE-ONLY
+** compiles an "else"...
 ** 1) Compile a branch and a patch address; the address gets patched
 **    by "endif" to point past the "else" code.
 ** 2) Pop the the "if" patch address
@@ -1303,33 +1321,247 @@
 
 
 /**************************************************************************
-                        b r a n c h P a r e n
-** 
-** Runtime for "(branch)" -- expects a literal offset in the next
-** compilation address, and branches to that location.
+                        e n d i f C o I m
+** IMMEDIATE COMPILE-ONLY
 **************************************************************************/
 
-static void branchParen(FICL_VM *pVM)
+static void endifCoIm(FICL_VM *pVM)
 {
-    vmBranchRelative(pVM, (uintptr_t)*(pVM->ip));
+    FICL_DICT *dp = vmGetDict(pVM);
+    resolveForwardBranch(dp, pVM, origTag);
     return;
 }
 
 
 /**************************************************************************
-                        e n d i f C o I m
-** 
+                        c a s e C o I m
+** IMMEDIATE COMPILE-ONLY
+**
+**
+** At compile-time, a CASE-SYS (see DPANS94 6.2.0873) looks like this:
+**			i*addr i caseTag
+** and an OF-SYS (see DPANS94 6.2.1950) looks like this:
+**			i*addr i caseTag addr ofTag
+** The integer under caseTag is the count of fixup addresses that branch
+** to ENDCASE.
 **************************************************************************/
 
-static void endifCoIm(FICL_VM *pVM)
+static void caseCoIm(FICL_VM *pVM)
+{
+#if FICL_ROBUST > 1
+    vmCheckStack(pVM, 0, 2);
+#endif
+
+	PUSHUNS(0);
+	markControlTag(pVM, caseTag);
+    return;
+}
+
+
+/**************************************************************************
+                        e n d c a s eC o I m
+** IMMEDIATE COMPILE-ONLY
+**************************************************************************/
+
+static void endcaseCoIm(FICL_VM *pVM)
+{
+	FICL_UNS fixupCount;
+    FICL_DICT *dp;
+    CELL *patchAddr;
+    FICL_INT offset;
+
+    assert(pVM->pSys->pDrop);
+
+	/*
+	** if the last OF ended with FALLTHROUGH,
+	** just add the FALLTHROUGH fixup to the
+	** ENDOF fixups
+	*/
+	if (stackGetTop(pVM->pStack).p == fallthroughTag)
+	{
+		matchControlTag(pVM, fallthroughTag);
+		patchAddr = POPPTR();
+	    matchControlTag(pVM, caseTag);
+		fixupCount = POPUNS();
+		PUSHPTR(patchAddr);
+		PUSHUNS(fixupCount + 1);
+		markControlTag(pVM, caseTag);
+	}
+
+    matchControlTag(pVM, caseTag);
+
+#if FICL_ROBUST > 1
+    vmCheckStack(pVM, 1, 0);
+#endif
+	fixupCount = POPUNS();
+#if FICL_ROBUST > 1
+    vmCheckStack(pVM, fixupCount, 0);
+#endif
+
+    dp = vmGetDict(pVM);
+
+    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pDrop));
+
+	while (fixupCount--)
+	{
+		patchAddr = (CELL *)stackPopPtr(pVM->pStack);
+		offset = dp->here - patchAddr;
+		*patchAddr = LVALUEtoCELL(offset);
+	}
+    return;
+}
+
+
+static void ofParen(FICL_VM *pVM)
+{
+	FICL_UNS a, b;
+
+#if FICL_ROBUST > 1
+    vmCheckStack(pVM, 2, 1);
+#endif
+
+	a = POPUNS();
+	b = stackGetTop(pVM->pStack).u;
+
+    if (a == b)
+    {                           /* fall through */
+		stackDrop(pVM->pStack, 1);
+        vmBranchRelative(pVM, 1);
+    }
+    else 
+    {                           /* take branch to next of or endswitch */
+        vmBranchRelative(pVM, *(int *)(pVM->ip));
+    }
+
+    return;
+}
+
+
+/**************************************************************************
+                        o f C o I m
+** IMMEDIATE COMPILE-ONLY
+**************************************************************************/
+
+static void ofCoIm(FICL_VM *pVM)
 {
     FICL_DICT *dp = vmGetDict(pVM);
-    resolveForwardBranch(dp, pVM, origTag);
+	CELL *fallthroughFixup = NULL;
+
+    assert(pVM->pSys->pBranch0);
+
+#if FICL_ROBUST > 1
+    vmCheckStack(pVM, 1, 3);
+#endif
+
+	if (stackGetTop(pVM->pStack).p == fallthroughTag)
+	{
+		matchControlTag(pVM, fallthroughTag);
+		fallthroughFixup = POPPTR();
+	}
+
+	matchControlTag(pVM, caseTag);
+
+	markControlTag(pVM, caseTag);
+
+    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pOfParen));
+    markBranch(dp, pVM, ofTag);
+    dictAppendUNS(dp, 2);
+
+	if (fallthroughFixup != NULL)
+	{
+		FICL_INT offset = dp->here - fallthroughFixup;
+		*fallthroughFixup = LVALUEtoCELL(offset);
+	}
+
     return;
 }
 
 
 /**************************************************************************
+                    e n d o f C o I m
+** IMMEDIATE COMPILE-ONLY
+**************************************************************************/
+
+static void endofCoIm(FICL_VM *pVM)
+{
+    CELL *patchAddr;
+    FICL_UNS fixupCount;
+    FICL_INT offset;
+    FICL_DICT *dp = vmGetDict(pVM);
+
+#if FICL_ROBUST > 1
+    vmCheckStack(pVM, 4, 3);
+#endif
+
+    assert(pVM->pSys->pBranchParen);
+
+	/* ensure we're in an OF, */
+    matchControlTag(pVM, ofTag);
+	/* grab the address of the branch location after the OF */
+    patchAddr = (CELL *)stackPopPtr(pVM->pStack);
+	/* ensure we're also in a "case" */
+    matchControlTag(pVM, caseTag);
+	/* grab the current number of ENDOF fixups */
+	fixupCount = POPUNS();
+
+    /* compile branch runtime */
+    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pBranchParen));
+
+	/* push a new ENDOF fixup, the updated count of ENDOF fixups, and the caseTag */
+    PUSHPTR(dp->here);
+    PUSHUNS(fixupCount + 1);
+	markControlTag(pVM, caseTag);
+
+	/* reserve space for the ENDOF fixup */
+    dictAppendUNS(dp, 2);
+
+	/* and patch the original OF */
+    offset = dp->here - patchAddr;
+    *patchAddr = LVALUEtoCELL(offset);
+}
+
+
+/**************************************************************************
+                    f a l l t h r o u g h C o I m
+** IMMEDIATE COMPILE-ONLY
+**************************************************************************/
+
+static void fallthroughCoIm(FICL_VM *pVM)
+{
+    CELL *patchAddr;
+    FICL_INT offset;
+    FICL_DICT *dp = vmGetDict(pVM);
+
+#if FICL_ROBUST > 1
+    vmCheckStack(pVM, 4, 3);
+#endif
+
+	/* ensure we're in an OF, */
+    matchControlTag(pVM, ofTag);
+	/* grab the address of the branch location after the OF */
+    patchAddr = (CELL *)stackPopPtr(pVM->pStack);
+	/* ensure we're also in a "case" */
+    matchControlTag(pVM, caseTag);
+
+	/* okay, here we go.  put the case tag back. */
+	markControlTag(pVM, caseTag);
+
+    /* compile branch runtime */
+    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pBranchParen));
+
+	/* push a new FALLTHROUGH fixup and the fallthroughTag */
+    PUSHPTR(dp->here);
+	markControlTag(pVM, fallthroughTag);
+
+	/* reserve space for the FALLTHROUGH fixup */
+    dictAppendUNS(dp, 2);
+
+	/* and patch the original OF */
+    offset = dp->here - patchAddr;
+    *patchAddr = LVALUEtoCELL(offset);
+}
+
+/**************************************************************************
                         h a s h
 ** hash ( c-addr u -- code)
 ** calculates hashcode of specified string and leaves it on the stack
@@ -2990,9 +3222,9 @@
 {
     FICL_DICT *dp = vmGetDict(pVM);
 
-    assert(pVM->pSys->pIfParen);
+    assert(pVM->pSys->pBranch0);
 
-    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pIfParen));
+    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pBranch0));
     resolveBackBranch(dp, pVM, destTag);
     return;
 }
@@ -3001,9 +3233,9 @@
 {
     FICL_DICT *dp = vmGetDict(pVM);
 
-    assert(pVM->pSys->pIfParen);
+    assert(pVM->pSys->pBranch0);
 
-    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pIfParen));
+    dictAppendCell(dp, LVALUEtoCELL(pVM->pSys->pBranch0));
     markBranch(dp, pVM, origTag);
     twoSwap(pVM);
     dictAppendUNS(dp, 1);
@@ -4554,9 +4786,10 @@
         {CREATE,     createParen},
         {DO,             doParen},
         {DOES,            doDoes},
-        {IF,             ifParen},
+        {IF,             branch0},
         {LITERAL,   literalParen},
         {LOOP,         loopParen},
+        {OF,             ofParen},
         {PLOOP,    plusLoopParen},
         {QDO,           qDoParen},
         {CSTRINGLIT,  cstringLit},
@@ -4582,6 +4815,28 @@
 }
 
 
+#ifdef TESTMAIN
+/**************************************************************************
+**                     r a n d o m
+** FICL-specific
+**************************************************************************/
+static void ficlRandom(FICL_VM *pVM)
+{
+    PUSHINT(rand());
+}
+
+
+/**************************************************************************
+**                     s e e d - r a n d o m
+** FICL-specific
+**************************************************************************/
+static void ficlSeedRandom(FICL_VM *pVM)
+{
+    srand(POPINT());
+}
+#endif
+
+
 /**************************************************************************
                         f i c l C o m p i l e C o r e
 ** Builds the primitive wordset and the environment-query namespace.
@@ -4651,6 +4906,7 @@
     dictAppendWord(dp, "c!",        cStore,         FW_DEFAULT);
     dictAppendWord(dp, "c,",        cComma,         FW_DEFAULT);
     dictAppendWord(dp, "c@",        cFetch,         FW_DEFAULT);
+    dictAppendWord(dp, "case",      caseCoIm,       FW_COMPIMMED);
     dictAppendWord(dp, "cell+",     cellPlus,       FW_DEFAULT);
     dictAppendWord(dp, "cells",     cells,          FW_DEFAULT);
     dictAppendWord(dp, "char",      ficlChar,       FW_DEFAULT);
@@ -4664,14 +4920,18 @@
     dictAppendWord(dp, "depth",     depth,          FW_DEFAULT);
     dictAppendWord(dp, "do",        doCoIm,         FW_COMPIMMED);
     dictAppendWord(dp, "does>",     doesCoIm,       FW_COMPIMMED);
+    pSys->pDrop =
     dictAppendWord(dp, "drop",      drop,           FW_DEFAULT);
     dictAppendWord(dp, "dup",       dup,            FW_DEFAULT);
     dictAppendWord(dp, "else",      elseCoIm,       FW_COMPIMMED);
     dictAppendWord(dp, "emit",      emit,           FW_DEFAULT);
+    dictAppendWord(dp, "endcase",   endcaseCoIm,    FW_COMPIMMED);
+    dictAppendWord(dp, "endof",     endofCoIm,      FW_COMPIMMED);
     dictAppendWord(dp, "environment?", environmentQ,FW_DEFAULT);
     dictAppendWord(dp, "evaluate",  evaluate,       FW_DEFAULT);
     dictAppendWord(dp, "execute",   execute,        FW_DEFAULT);
     dictAppendWord(dp, "exit",      exitCoIm,       FW_COMPIMMED);
+    dictAppendWord(dp, "fallthrough",fallthroughCoIm,FW_COMPIMMED);
     dictAppendWord(dp, "fill",      fill,           FW_DEFAULT);
     dictAppendWord(dp, "find",      cFind,          FW_DEFAULT);
     dictAppendWord(dp, "fm/mod",    fmSlashMod,     FW_DEFAULT);
@@ -4693,6 +4953,7 @@
     dictAppendWord(dp, "mod",       ficlMod,        FW_DEFAULT);
     dictAppendWord(dp, "move",      move,           FW_DEFAULT);
     dictAppendWord(dp, "negate",    negate,         FW_DEFAULT);
+    dictAppendWord(dp, "of",        ofCoIm,         FW_COMPIMMED);
     dictAppendWord(dp, "or",        bitwiseOr,      FW_DEFAULT);
     dictAppendWord(dp, "over",      over,           FW_DEFAULT);
     dictAppendWord(dp, "postpone",  postponeCoIm,   FW_COMPIMMED);
@@ -4741,7 +5002,6 @@
     dictAppendWord(dp, "?do",       qDoCoIm,        FW_COMPIMMED);
     dictAppendWord(dp, "again",     againCoIm,      FW_COMPIMMED);
     dictAppendWord(dp, "c\"",       cstringQuoteIm, FW_IMMEDIATE);
-    /* case of endof endcase */
     dictAppendWord(dp, "hex",       hex,            FW_DEFAULT);
     dictAppendWord(dp, "pad",       pad,            FW_DEFAULT);
     dictAppendWord(dp, "parse",     parse,          FW_DEFAULT);
@@ -4888,6 +5148,10 @@
     dictAppendWord(dp, "(user)",    userParen,      FW_DEFAULT);
     dictAppendWord(dp, "user",      userVariable,   FW_DEFAULT);
 #endif
+#ifdef TESTMAIN
+    dictAppendWord(dp, "random",    ficlRandom,     FW_DEFAULT);
+    dictAppendWord(dp, "seed-random",ficlSeedRandom,FW_DEFAULT);
+#endif
 
     /*
     ** internal support words
@@ -4905,8 +5169,8 @@
     dictAppendWord(dp, "(.\")",     stringLit,      FW_COMPILE);
     pSys->pCStringLit =
     dictAppendWord(dp, "(c\")",     cstringLit,     FW_COMPILE);
-    pSys->pIfParen =
-    dictAppendWord(dp, "(if)",      ifParen,        FW_COMPILE);
+    pSys->pBranch0 =
+    dictAppendWord(dp, "(branch0)",      branch0,        FW_COMPILE);
     pSys->pBranchParen =
     dictAppendWord(dp, "(branch)",  branchParen,    FW_COMPILE);
     pSys->pDoParen =
@@ -4922,6 +5186,8 @@
     pSys->pInterpret =
     dictAppendWord(dp, "interpret", interpret,      FW_DEFAULT);
     dictAppendWord(dp, "lookup",    lookup,         FW_DEFAULT);
+    pSys->pOfParen =
+    dictAppendWord(dp, "(of)",      ofParen,        FW_DEFAULT);
     dictAppendWord(dp, "(variable)",variableParen,  FW_COMPILE);
     dictAppendWord(dp, "(constant)",constantParen,  FW_COMPILE);
     dictAppendWord(dp, "(parse-step)", 
Index: ficl/softwords/fileaccess.fr
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/softwords/fileaccess.fr,v
retrieving revision 1.1
diff -u -r1.1 fileaccess.fr
--- ficl/softwords/fileaccess.fr	9 Apr 2002 17:45:27 -0000	1.1
+++ ficl/softwords/fileaccess.fr	23 Mar 2007 22:26:01 -0000
@@ -4,7 +4,7 @@
 \ ** submitted by Larry Hastings, larry@hastings.org
 \ **
 \
-\ $FreeBSD: src/sys/boot/ficl/softwords/fileaccess.fr,v 1.1 2002/04/09 17:45:27 dcs Exp $
+\ $FreeBSD: src/sys/boot/ficl/softwords/fileaccess.fr,v 1.2 2007/03/23 22:26:01 jkim Exp $
 
 : r/o 1 ;
 : r/w 3 ; 
@@ -15,12 +15,11 @@
     r/o bin open-file 0= if
         locals| f | end-locals
         f include-file
-        f close-file drop
     else
         drop
     endif
     ;
 
-: include parse-word included ; immediate
+: include parse-word included ;
 
 \ #endif
Index: ficl/softwords/jhlocal.fr
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/softwords/jhlocal.fr,v
retrieving revision 1.4
diff -u -r1.4 jhlocal.fr
--- ficl/softwords/jhlocal.fr	29 Apr 2001 02:36:36 -0000	1.4
+++ ficl/softwords/jhlocal.fr	23 Mar 2007 22:26:01 -0000
@@ -14,11 +14,13 @@
 \
 \ revised 2 June 2000 - { | a -- } now works correctly
 \
-\ $FreeBSD: src/sys/boot/ficl/softwords/jhlocal.fr,v 1.4 2001/04/29 02:36:36 dcs Exp $
+\ $FreeBSD: src/sys/boot/ficl/softwords/jhlocal.fr,v 1.5 2007/03/23 22:26:01 jkim Exp $
 
 hide
+
 0 constant zero
 
+
 : ?--   ( c-addr u -- c-addr u flag )
     2dup s" --" compare 0= ;
 : ?}    ( c-addr u -- c-addr u flag )
@@ -74,23 +76,24 @@
             parse-word
             ?delim dup to locstate
         0= while
-		    ?2loc if 
-			    postpone zero postpone zero  (2local)
-			else
-                postpone zero  (local)
-		    endif
+            ?2loc if
+                postpone zero postpone zero (2local)
+            else
+                postpone zero (local)
+            endif
         repeat
     endif
 
     0 0 (local)
 
     \ toss words until }
+    \ (explicitly allow | and -- in the comment)
     locstate 2 = if
         begin
             parse-word
-            ?delim dup to locstate
-        0= while
-            2drop
+            ?delim dup  to locstate
+        3 < while
+            locstate 0=  if 2drop endif
         repeat
     endif
 
Index: ficl/softwords/oo.fr
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/softwords/oo.fr,v
retrieving revision 1.4
diff -u -r1.4 oo.fr
--- ficl/softwords/oo.fr	9 Apr 2002 17:45:28 -0000	1.4
+++ ficl/softwords/oo.fr	23 Mar 2007 22:26:01 -0000
@@ -3,7 +3,7 @@
 \ ** F I C L   O - O   E X T E N S I O N S
 \ ** john sadler aug 1998
 \
-\ $FreeBSD: src/sys/boot/ficl/softwords/oo.fr,v 1.4 2002/04/09 17:45:28 dcs Exp $
+\ $FreeBSD: src/sys/boot/ficl/softwords/oo.fr,v 1.5 2007/03/23 22:26:01 jkim Exp $
 
 17 ficl-vocabulary oop
 also oop definitions
@@ -86,8 +86,6 @@
 \ execute it at run-time...
 \
 
-hide
-
 \ p a r s e - m e t h o d
 \ compiles a method name so that it pushes
 \ the string base address and count at run-time.
@@ -97,6 +95,13 @@
     postpone sliteral
 ; compile-only
 
+
+
+: (lookup-method)  { class 2:name -- class 0 | class xt 1 | class xt -1  }
+    class  name class cell+ @  ( class c-addr u wid )
+    search-wordlist
+;
+
 \ l o o k u p - m e t h o d
 \ takes a counted string method name from the stack (as compiled
 \ by parse-method) and attempts to look this method up in the method list of 
@@ -104,22 +109,18 @@
 \ and pushes the xt of the method. If not, it aborts with an error message.
 
 : lookup-method  { class 2:name -- class xt }
-    name class cell+ @  ( c-addr u wid )
-    search-wordlist     ( 0 | xt 1 | xt -1 )
+    class name (lookup-method)    ( 0 | xt 1 | xt -1 )
     0= if
         name type ."  not found in " 
         class body> >name type
         cr abort 
     endif 
-    class swap
 ;
 
 : find-method-xt   \ name ( class -- class xt )
     parse-word lookup-method
 ;
 
-set-current  ( stop hiding definitions )
-
 : catch-method  ( instance class c-addr u -- <method-signature> exc-flag )
     lookup-method catch
 ;
Index: ficl/softwords/prefix.fr
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/softwords/prefix.fr,v
retrieving revision 1.2
diff -u -r1.2 prefix.fr
--- ficl/softwords/prefix.fr	9 Apr 2002 17:45:28 -0000	1.2
+++ ficl/softwords/prefix.fr	23 Mar 2007 22:26:01 -0000
@@ -5,7 +5,7 @@
 \ (jws) To make a prefix, simply create a new definition in the <prefixes> 
 \ wordlist. start-prefixes and end-prefixes handle the bookkeeping
 \
-\ $FreeBSD: src/sys/boot/ficl/softwords/prefix.fr,v 1.2 2002/04/09 17:45:28 dcs Exp $
+\ $FreeBSD: src/sys/boot/ficl/softwords/prefix.fr,v 1.3 2007/03/23 22:26:01 jkim Exp $
 
 variable save-current
 
@@ -22,7 +22,7 @@
 
 
 \ make .( a prefix (we just create an alias for it in the prefixes list)
-: .(  .( ;
+: .( postpone .( ; immediate
 
 
 \ make \ a prefix, and add // (same thing) as a prefix too
Index: ficl/softwords/softcore.awk
===================================================================
RCS file: /home/ncvs/src/sys/boot/ficl/softwords/softcore.awk,v
retrieving revision 1.8
diff -u -r1.8 softcore.awk
--- ficl/softwords/softcore.awk	3 Nov 2001 01:33:12 -0000	1.8
+++ ficl/softwords/softcore.awk	23 Mar 2007 22:26:01 -0000
@@ -10,25 +10,63 @@
 # Note! This script uses strftime() which is a gawk-ism, and the
 # POSIX [[:space:]] character class.
 #
-# $FreeBSD: src/sys/boot/ficl/softwords/softcore.awk,v 1.8 2001/11/03 01:33:12 obrien Exp $
+# $FreeBSD: src/sys/boot/ficl/softwords/softcore.awk,v 1.9 2007/03/23 22:26:01 jkim Exp $
 
 BEGIN \
 {
-  printf "/***************************************************************\n";
+  printf "/*******************************************************************\n";
   printf "** s o f t c o r e . c\n";
   printf "** Forth Inspired Command Language -\n";
   printf "** Words from CORE set written in FICL\n";
   printf "** Author: John Sadler (john_sadler@alum.mit.edu)\n";
   printf "** Created: 27 December 1997\n";
   printf "** Last update: %s\n", datestamp;
-  printf "***************************************************************/\n";
-  printf "\n/*\n";
+  printf "*******************************************************************/\n";
+  printf "/*\n";
+  printf "** DO NOT EDIT THIS FILE -- it is generated by softwords/softcore.awk\n";
+  printf "** Make changes to the .fr files in ficl/softwords instead.\n";
   printf "** This file contains definitions that are compiled into the\n";
   printf "** system dictionary by the first virtual machine to be created.\n";
   printf "** Created automagically by ficl/softwords/softcore.awk\n";
   printf "*/\n";
+  printf "/*\n";
+  printf "** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu)\n";
+  printf "** All rights reserved.\n";
+  printf "**\n";
+  printf "** Get the latest Ficl release at http://ficl.sourceforge.net\n";
+  printf "**\n";
+  printf "** I am interested in hearing from anyone who uses ficl. If you have\n";
+  printf "** a problem, a success story, a defect, an enhancement request, or\n";
+  printf "** if you would like to contribute to the ficl release, please send\n";
+  printf "** contact me by email at the address above.\n";
+  printf "**\n";
+  printf "** L I C E N S E  and  D I S C L A I M E R\n";
+  printf "** \n";
+  printf "** Redistribution and use in source and binary forms, with or without\n";
+  printf "** modification, are permitted provided that the following conditions\n";
+  printf "** are met:\n";
+  printf "** 1. Redistributions of source code must retain the above copyright\n";
+  printf "**    notice, this list of conditions and the following disclaimer.\n";
+  printf "** 2. Redistributions in binary form must reproduce the above copyright\n";
+  printf "**    notice, this list of conditions and the following disclaimer in the\n";
+  printf "**    documentation and/or other materials provided with the distribution.\n";
+  printf "**\n";
+  printf "** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n";
+  printf "** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n";
+  printf "** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n";
+  printf "** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n";
+  printf "** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n";
+  printf "** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n";
+  printf "** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n";
+  printf "** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n";
+  printf "** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n";
+  printf "** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n";
+  printf "** SUCH DAMAGE.\n";
+  printf "*/\n";
+  printf "\n";
   printf "\n#include \"ficl.h\"\n";
   printf "\nstatic char softWords[] =\n";
+  printf "#if FICL_WANT_SOFTWORDS\n";
 
   commenting = 0;
 }
@@ -127,14 +165,17 @@
 END \
 {
   if (commenting) end_comments();
+  printf "#endif /* WANT_SOFTWORDS */\n";
   printf "    \"quit \";\n";
   printf "\n\nvoid ficlCompileSoftCore(FICL_SYSTEM *pSys)\n";
   printf "{\n";
   printf "    FICL_VM *pVM = pSys->vmList;\n";
+  printf "    CELL id = pVM->sourceID;\n";
   printf "    int ret = sizeof (softWords);\n";
   printf "	  assert(pVM);\n";
-  printf "\n"
+  printf "    pVM->sourceID.i = -1;\n";
   printf "    ret = ficlExec(pVM, softWords);\n";
+  printf "    pVM->sourceID = id;\n";
   printf "    if (ret == VM_ERREXIT)\n";
   printf "        assert(FALSE);\n";
   printf "    return;\n";
Index: forth/beastie.4th
===================================================================
RCS file: /home/ncvs/src/sys/boot/forth/beastie.4th,v
retrieving revision 1.10.2.2
diff -u -r1.10.2.2 beastie.4th
--- forth/beastie.4th	4 Apr 2006 17:03:44 -0000	1.10.2.2
+++ forth/beastie.4th	31 Mar 2006 21:36:17 -0000
@@ -23,7 +23,7 @@
 \ OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 \ SUCH DAMAGE.
 \
-\ $FreeBSD: src/sys/boot/forth/beastie.4th,v 1.10.2.2 2006/04/04 17:03:44 emax Exp $
+\ $FreeBSD: src/sys/boot/forth/beastie.4th,v 1.12 2006/03/31 21:36:17 scottl Exp $
 
 marker task-beastie.4th
 
Index: forth/loader.4th
===================================================================
RCS file: /home/ncvs/src/sys/boot/forth/loader.4th,v
retrieving revision 1.24
diff -u -r1.24 loader.4th
--- forth/loader.4th	24 May 2002 02:28:58 -0000	1.24
+++ forth/loader.4th	12 May 2006 04:09:53 -0000
@@ -22,19 +22,7 @@
 \ OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 \ SUCH DAMAGE.
 \
-\ $FreeBSD: src/sys/boot/forth/loader.4th,v 1.24 2002/05/24 02:28:58 gordon Exp $
-
-s" arch-alpha" environment? [if] [if]
-	s" loader_version" environment?  [if]
-		12 < [if]
-			.( Loader version 1.2+ required) cr
-			abort
-		[then]
-	[else]
-		.( Could not get loader version!) cr
-		abort
-	[then]
-[then] [then]
+\ $FreeBSD: src/sys/boot/forth/loader.4th,v 1.25 2006/05/12 04:09:53 jhb Exp $
 
 s" arch-i386" environment? [if] [if]
 	s" loader_version" environment?  [if]
Index: forth/loader.conf
===================================================================
RCS file: /home/ncvs/src/sys/boot/forth/loader.conf,v
retrieving revision 1.95.2.10
diff -u -r1.95.2.10 loader.conf
--- forth/loader.conf	5 Nov 2006 08:50:38 -0000	1.95.2.10
+++ forth/loader.conf	9 Apr 2007 22:09:09 -0000
@@ -6,7 +6,7 @@
 #
 # All arguments must be in double quotes.
 #
-# $FreeBSD: src/sys/boot/forth/loader.conf,v 1.95.2.10 2006/11/05 08:50:38 hrs Exp $
+# $FreeBSD: src/sys/boot/forth/loader.conf,v 1.120 2007/04/09 22:09:09 pjd Exp $
 
 ##############################################################
 ###  Basic configuration options  ############################
@@ -77,6 +77,9 @@
 #boot_verbose=""	# -v: Causes extra debugging information to be printed
 #init_path="/sbin/init:/sbin/oinit:/sbin/init.bak:/rescue/init:/stand/sysinstall"
 			# Sets the list of init candidates
+#init_shell="/bin/sh"	# The shell binary used by init(8).
+#init_script=""		# Initial script to run by init(8) before chrooting.
+#init_chroot=""		# Directory for init(8) to chroot into.
 
 
 ##############################################################
@@ -134,6 +137,8 @@
 reiserfs_load="NO"		# ReiserFS
 #umapfs_load="NO"		# User-id map filesystem
 unionfs_load="NO"		# Union filesystem
+xfs_load="NO"   		# XFS
+zfs_load="NO"   		# ZFS
 
 # Related stuff
 
@@ -146,13 +151,13 @@
 				# ggatec(8), ggated(8), ggatel(8))
 geom_label_load="NO"		# File system labels (see glabel(8))
 geom_md_load="NO"		# Memory disk driver (vnode/swap/malloc) (see
+				# md(4), mdconfig(8))
 geom_mirror_load="NO"		# RAID1 disk driver (see gmirror(8))
 geom_nop_load="NO"		# Transparent disk driver (see gnop(8))
 geom_raid3_load="NO"		# RAID3 disk driver (see graid3(8))
 geom_shsec_load="NO"		# Shared secret disk driver (see gshsec(8))
 geom_stripe_load="NO"		# RAID0 disk driver (see gstripe(8))
 geom_uzip_load="NO"		# Compressed disk images driver (see mkuzip(8))
-				# md(4), mdconfig(8))
 geom_vinum_load="NO"		# Concatenated/mirror/raid driver (see vinum(4))
 
 
@@ -182,7 +187,8 @@
 ##############################################################
 
 if_disc_load="NO"		# Discard device
-if_ef_load="NO"			# pseudo-device providing support for multiple ethernet frame types
+if_ef_load="NO"			# pseudo-device providing support for multiple
+				# ethernet frame types
 if_faith_load="NO"		# IPv6-to-IPv4 TCP relay capturing interface
 if_gif_load="NO"		# generic tunnel interface
 if_gre_load="NO"		# encapsulating network device
@@ -216,24 +222,29 @@
 if_cue_load="NO"		# CATC USB-EL1210A USB Ethernet
 if_dc_load="NO"			# DEC/Intel 21143 and various workalikes
 if_de_load="NO"			# DEC DC21x4x Ethernet
-if_ed_load="NO"			# National Semiconductor DS8390/WD83C690 Ethernet
-if_el_load="NO"			# 3Com Etherlink 3C501
+if_ed_load="NO"			# National Semiconductor DS8390/WD83C690
+				# Ethernet
 if_em_load="NO"			# Intel(R) PRO/1000 Gigabit Ethernet
 if_en_load="NO"			# Midway-based ATM interfaces
 if_ep_load="NO"			# 3Com Etherlink III (3c5x9)
 if_ex_load="NO"			# Intel EtherExpress Pro/10 Ethernet
-if_fe_load="NO"			# Fujitsu MB86960A/MB86965A based Ethernet adapters
+if_fe_load="NO"			# Fujitsu MB86960A/MB86965A based Ethernet
+				# adapters
 if_fxp_load="NO"		# Intel EtherExpress PRO/100B (82557, 82558)
 if_gem_load="NO"		# Sun GEM/Sun ERI/Apple GMAC
 if_hme_load="NO"		# Sun Microelectronics STP2002-STQ Ethernet
 if_ie_load="NO"			# Intel 82586
 if_ipw_load="NO"		# Intel PRO/Wireless 2100 wireless
-if_iwi_load="NO"		# Intel PRO/Wireless 2200BG/2225BG/2915ABG wireless
+if_iwi_load="NO"		# Intel PRO/Wireless 2200BG/2225BG/2915ABG
+				# wireless
 if_ixgb_load="NO"		# Intel PRO/10Gb Ethernet
 if_le_load="NO"			# AMD Am7900 LANCE and Am79C9xx PCnet
-if_lge_load="NO"		# Level 1 LXT1001 NetCellerator PCI Gigabit Ethernet
-if_lnc_load="NO"		# AMD Lance/PCnet Ethernet
+if_lge_load="NO"		# Level 1 LXT1001 NetCellerator PCI Gigabit
+				# Ethernet
+if_msk_load="NO"		# Marvell/SysKonnect Yukon II Gigabit Ethernet
+if_mxge_load="NO"		# Myricom Myri10GE 10Gb Ethernet
 if_my_load="NO"			# Myson PCI Fast Ethernet
+if_nfe_load="NO"		# NVIDIA nForce MCP Networking Adapter
 if_nge_load="NO"		# National Semiconductor PCI Gigabit Ethernet
 if_nve_load="NO"		# NVIDIA nForce MCP Networking Adapter
 if_oltr_load="NO"		# Olicom
@@ -287,18 +298,21 @@
 ng_ksocket_load="NO"		# kernel socket netgraph node type
 ng_l2tp_load="NO"		# L2TP protocol netgraph node type
 ng_lmi_load="NO"		# frame relay LMI protocol netgraph node type
-ng_mppc_load="NO"		# Microsoft MPPC/MPPE compression and encryption netgraph node type
-ng_netflow_load="NO"		# Cisco's NetFlow netgraph note type
+ng_mppc_load="NO"		# Microsoft MPPC/MPPE compression and
+				# encryption netgraph node type
+ng_netflow_load="NO"		# Cisco's NetFlow netgraph node type
 ng_one2many_load="NO"		# packet multiplexing netgraph node type
 ng_ppp_load="NO"		# PPP protocol netgraph node type
 ng_pppoe_load="NO"		# RFC 2516 PPPOE protocol netgraph node type
 ng_pptpgre_load="NO"		# PPTP GRE protocol netgraph node type
 ng_rfc1490_load="NO"		# RFC 1490 netgraph node type
 ng_socket_load="NO"		# Netgraph socket node type
-ng_split_load="NO"		# netgraph node to separate incoming and outgoing flows
+ng_split_load="NO"		# netgraph node to separate incoming and
+				# outgoing flows
 ng_sppp_load="NO"		# sppp netgraph node type
 ng_tee_load="NO"		# Netgraph ``tee'' node type
-ng_tty_load="NO"		# Netgraph node type that is also a line discipline
+ng_tty_load="NO"		# Netgraph node type that is also a line
+				# discipline
 ng_vjc_load="NO"		# Van Jacobsen compression netgraph node type
 ng_vlan_load="NO"		# IEEE 802.1Q VLAN tagging netgraph node type
 
@@ -315,9 +329,13 @@
 snd_csa_load="NO"		# csa
 snd_ds1_load="NO"		# ds1
 snd_emu10k1_load="NO" 		# Creative Sound Blaster Live
+snd_emu10kx_load="NO" 		# Creative SoundBlaster Live! and Audigy
+snd_envy24_load="NO"		# VIA Envy24
+snd_envy24ht_load="NO"		# VIA Envy24HT
 snd_es137x_load="NO"		# es137x
 snd_ess_load="NO"		# ess
 snd_fm801_load="NO"		# fm801
+snd_hda_load="NO"		# Intel High Definition Audio (Controller)
 snd_ich_load="NO"		# Intel ICH
 snd_maestro_load="NO"		# Maestro
 snd_maestro3_load="NO"		# Maestro3
@@ -327,6 +345,7 @@
 snd_sb8_load="NO"		# Sound Blaster Pro
 snd_sbc_load="NO"		# Sbc
 snd_solo_load="NO"		# Solo
+snd_spicds_load="NO"		# SPI codecs
 snd_t4dwave_load="NO"		# t4dwave
 snd_via8233_load="NO"		# via8233
 snd_via82c686_load="NO"		# via82c686
@@ -400,3 +419,10 @@
 #module_after="cmd"		# executes "cmd" after loading the module
 #module_error="cmd"		# executes "cmd" if load fails
 
+##############################################################
+###  Always try to load ZFS pool cache file  #################
+##############################################################
+
+zpool_cache_load="YES"
+zpool_cache_type="/boot/zfs/zpool.cache"
+zpool_cache_name="/boot/zfs/zpool.cache"
Index: forth/loader.conf.5
===================================================================
RCS file: /home/ncvs/src/sys/boot/forth/loader.conf.5,v
retrieving revision 1.23.2.3
diff -u -r1.23.2.3 loader.conf.5
--- forth/loader.conf.5	14 Feb 2006 06:20:15 -0000	1.23.2.3
+++ forth/loader.conf.5	18 Nov 2005 10:34:24 -0000
@@ -22,7 +22,7 @@
 .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 .\" SUCH DAMAGE.
 .\"
-.\" $FreeBSD: src/sys/boot/forth/loader.conf.5,v 1.23.2.3 2006/02/14 06:20:15 ru Exp $
+.\" $FreeBSD: src/sys/boot/forth/loader.conf.5,v 1.26 2005/11/18 10:34:24 ru Exp $
 .Dd November 15, 2005
 .Dt LOADER.CONF 5
 .Os
Index: forth/support.4th
===================================================================
RCS file: /home/ncvs/src/sys/boot/forth/support.4th,v
retrieving revision 1.15.14.1
diff -u -r1.15.14.1 support.4th
--- forth/support.4th	16 Oct 2006 12:32:38 -0000	1.15.14.1
+++ forth/support.4th	13 Oct 2006 20:48:17 -0000
@@ -22,7 +22,7 @@
 \ OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 \ SUCH DAMAGE.
 \
-\ $FreeBSD: src/sys/boot/forth/support.4th,v 1.15.14.1 2006/10/16 12:32:38 ru Exp $
+\ $FreeBSD: src/sys/boot/forth/support.4th,v 1.16 2006/10/13 20:48:17 ru Exp $
 
 \ Loader.rc support functions:
 \
Index: i386/Makefile.inc
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/Makefile.inc,v
retrieving revision 1.10.2.1
diff -u -r1.10.2.1 Makefile.inc
--- i386/Makefile.inc	25 Oct 2006 15:03:29 -0000	1.10.2.1
+++ i386/Makefile.inc	28 Sep 2006 10:02:04 -0000
@@ -1,12 +1,12 @@
 # Common defines for all of /sys/boot/i386/
 #
-# $FreeBSD: src/sys/boot/i386/Makefile.inc,v 1.10.2.1 2006/10/25 15:03:29 jhb Exp $
+# $FreeBSD: src/sys/boot/i386/Makefile.inc,v 1.12 2006/09/28 10:02:04 ru Exp $
 
 BINDIR?=	/boot
 
 LOADER_ADDRESS?=0x200000
 CFLAGS+=	-ffreestanding -mpreferred-stack-boundary=2 \
-		-mno-mmx -mno-3dnow -mno-sse -mno-sse2
+		-mno-mmx -mno-3dnow -mno-sse -mno-sse2 -mno-sse3
 LDFLAGS+=	-nostdlib
 
 .if ${MACHINE_ARCH} == "amd64"
Index: i386/boot0/boot0.S
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/boot0/boot0.S,v
retrieving revision 1.14.2.1
diff -u -r1.14.2.1 boot0.S
--- i386/boot0/boot0.S	31 May 2006 21:32:24 -0000	1.14.2.1
+++ i386/boot0/boot0.S	26 Mar 2007 21:56:13 -0000
@@ -13,7 +13,7 @@
  * warranties of merchantability and fitness for a particular
  * purpose.
  *
- * $FreeBSD: src/sys/boot/i386/boot0/boot0.S,v 1.14.2.1 2006/05/31 21:32:24 jhb Exp $
+ * $FreeBSD: src/sys/boot/i386/boot0/boot0.S,v 1.16 2007/03/26 21:56:13 thomas Exp $
  */
 
 /* A 512-byte boot manager. */
@@ -96,7 +96,7 @@
 /*
  * Initialize the serial port.  bioscom preserves the driver number in DX.
  */
-		movw COMSPEED,%ax		# defined by Makefile
+		movw $COMSPEED,%ax		# defined by Makefile
 		callw bioscom
 #endif
 /*
Index: i386/boot2/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/boot2/Makefile,v
retrieving revision 1.58
diff -u -r1.58 Makefile
--- i386/boot2/Makefile	15 Mar 2005 18:43:36 -0000	1.58
+++ i386/boot2/Makefile	19 May 2007 05:07:47 -0000
@@ -1,4 +1,4 @@
-# $FreeBSD: src/sys/boot/i386/boot2/Makefile,v 1.58 2005/03/15 18:43:36 obrien Exp $
+# $FreeBSD: src/sys/boot/i386/boot2/Makefile,v 1.60 2007/05/19 05:07:47 kan Exp $
 
 FILES=		boot boot1 boot2
 
@@ -26,7 +26,7 @@
 	-fno-unit-at-a-time \
 	-mno-align-long-strings \
 	-mrtd \
-	-mno-mmx -mno-3dnow -mno-sse -mno-sse2 \
+	-mno-mmx -mno-3dnow -mno-sse -mno-sse2 -mno-sse3 \
 	-D${BOOT2_UFS} \
 	-DFLAGS=${BOOT_BOOT1_FLAGS} \
 	-DSIOPRT=${BOOT_COMCONSOLE_PORT} \
@@ -36,7 +36,8 @@
 	-I${.CURDIR}/../btx/lib -I. \
 	-Wall -Waggregate-return -Wbad-function-cast -Wcast-align \
 	-Wmissing-declarations -Wmissing-prototypes -Wnested-externs \
-	-Wpointer-arith -Wshadow -Wstrict-prototypes -Wwrite-strings
+	-Wpointer-arith -Wshadow -Wstrict-prototypes -Wwrite-strings \
+	-Winline --param max-inline-insns-single=100
 
 LDFLAGS=-static -N --gc-sections
 
Index: i386/boot2/boot1.S
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/boot2/boot1.S,v
retrieving revision 1.30.2.1
diff -u -r1.30.2.1 boot1.S
--- i386/boot2/boot1.S	1 Oct 2006 12:07:07 -0000	1.30.2.1
+++ i386/boot2/boot1.S	11 Apr 2006 20:09:42 -0000
@@ -12,7 +12,7 @@
  * warranties of merchantability and fitness for a particular
  * purpose.
  *
- * $FreeBSD: src/sys/boot/i386/boot2/boot1.S,v 1.30.2.1 2006/10/01 12:07:07 ru Exp $
+ * $FreeBSD: src/sys/boot/i386/boot2/boot1.S,v 1.31 2006/04/11 20:09:42 jhb Exp $
  */
 
 /* Memory Locations */
Index: i386/boot2/boot2.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/boot2/boot2.c,v
retrieving revision 1.72.2.4
diff -u -r1.72.2.4 boot2.c
--- i386/boot2/boot2.c	15 Feb 2006 15:08:51 -0000	1.72.2.4
+++ i386/boot2/boot2.c	2 Nov 2006 17:28:38 -0000
@@ -14,7 +14,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/boot2/boot2.c,v 1.72.2.4 2006/02/15 15:08:51 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/boot2/boot2.c,v 1.83 2006/11/02 17:28:38 ru Exp $");
 
 #include <sys/param.h>
 #include <sys/disklabel.h>
@@ -79,7 +79,7 @@
 #define PATH_KERNEL	"/boot/kernel/kernel"
 
 #define ARGS		0x900
-#define NOPT		12
+#define NOPT		14
 #define NDEV		3
 #define MEM_BASE	0x12
 #define MEM_EXT 	0x15
@@ -99,12 +99,14 @@
 
 extern uint32_t _end;
 
-static const char optstr[NOPT] = "DhaCgmnpqrsv"; /* Also 'P', 'S' */
+static const char optstr[NOPT] = "DhaCcdgmnpqrsv"; /* Also 'P', 'S' */
 static const unsigned char flags[NOPT] = {
     RBX_DUAL,
     RBX_SERIAL,
     RBX_ASKNAME,
     RBX_CDROM,
+    RBX_CONFIG,
+    RBX_KDB,
     RBX_GDB,
     RBX_MUTE,
     RBX_NOINTR,
@@ -332,7 +334,7 @@
 	return;
     }
     if (fmt == 0) {
-	addr = hdr.ex.a_entry;
+	addr = hdr.ex.a_entry & 0xffffff;
 	p = PTOV(addr);
 	fs_off = PAGE_SIZE;
 	if (xfsread(ino, p, hdr.ex.a_text))
@@ -366,7 +368,7 @@
 		j++;
 	}
 	for (i = 0; i < 2; i++) {
-	    p = PTOV(ep[i].p_paddr);
+	    p = PTOV(ep[i].p_paddr & 0xffffff);
 	    fs_off = ep[i].p_offset;
 	    if (xfsread(ino, p, ep[i].p_filesz))
 		return;
@@ -387,7 +389,7 @@
 		p += es[i].sh_size;
 	    }
 	}
-	addr = hdr.eh.e_entry;
+	addr = hdr.eh.e_entry & 0xffffff;
     }
     bootinfo.bi_esymtab = VTOP(p);
     bootinfo.bi_kernelname = VTOP(kname);
Index: i386/boot2/lib.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/boot2/lib.h,v
retrieving revision 1.2.34.1
diff -u -r1.2.34.1 lib.h
--- i386/boot2/lib.h	15 Feb 2006 15:08:51 -0000	1.2.34.1
+++ i386/boot2/lib.h	18 Aug 2005 00:42:45 -0000
@@ -14,7 +14,7 @@
  */
 
 /*
- * $FreeBSD: src/sys/boot/i386/boot2/lib.h,v 1.2.34.1 2006/02/15 15:08:51 ru Exp $
+ * $FreeBSD: src/sys/boot/i386/boot2/lib.h,v 1.3 2005/08/18 00:42:45 iedowse Exp $
  */
 
 void sio_init(int);
Index: i386/boot2/sio.S
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/boot2/sio.S,v
retrieving revision 1.9.8.1
diff -u -r1.9.8.1 sio.S
--- i386/boot2/sio.S	15 Feb 2006 15:08:51 -0000	1.9.8.1
+++ i386/boot2/sio.S	18 Aug 2005 00:42:45 -0000
@@ -12,7 +12,7 @@
  * warranties of merchantability and fitness for a particular
  * purpose.
  *
- * $FreeBSD: src/sys/boot/i386/boot2/sio.S,v 1.9.8.1 2006/02/15 15:08:51 ru Exp $
+ * $FreeBSD: src/sys/boot/i386/boot2/sio.S,v 1.10 2005/08/18 00:42:45 iedowse Exp $
  */
 
 		.set SIO_PRT,SIOPRT		# Base port
Index: i386/btx/btx/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/btx/btx/Makefile,v
retrieving revision 1.19
diff -u -r1.19 Makefile
--- i386/btx/btx/Makefile	21 Dec 2004 08:47:13 -0000	1.19
+++ i386/btx/btx/Makefile	29 May 2007 03:31:00 -0000
@@ -5,10 +5,6 @@
 NO_MAN=
 SRCS=	btx.S
 
-.if defined(PAGING)
-CFLAGS+=-DPAGING
-.endif
-
 .if defined(BOOT_BTX_NOHANG)
 BOOT_BTX_FLAGS=0x1
 .else
Index: i386/btx/btx/btx.S
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/btx/btx/btx.S,v
retrieving revision 1.38.2.1.2.1
diff -u -r1.38.2.1.2.1 btx.S
--- i386/btx/btx/btx.S	7 Dec 2006 22:30:22 -0000	1.38.2.1.2.1
+++ i386/btx/btx/btx.S	29 May 2007 03:31:00 -0000
@@ -12,7 +12,7 @@
  * warranties of merchantability and fitness for a particular
  * purpose.
  *
- * $FreeBSD: src/sys/boot/i386/btx/btx/btx.S,v 1.38.2.1.2.1 2006/12/07 22:30:22 jhb Exp $
+ * $FreeBSD: src/sys/boot/i386/btx/btx/btx.S,v 1.44 2006/12/06 17:45:35 jhb Exp $
  */
 
 /*
@@ -21,12 +21,10 @@
 		.set MEM_BTX,0x1000		# Start of BTX memory
 		.set MEM_ESP0,0x1800		# Supervisor stack
 		.set MEM_BUF,0x1800		# Scratch buffer
-		.set MEM_ESP1,0x1e00		# Link stack
 		.set MEM_IDT,0x1e00		# IDT
-		.set MEM_TSS,0x1f98		# TSS
-		.set MEM_MAP,0x2000		# I/O bit map
-		.set MEM_DIR,0x4000		# Page directory
-		.set MEM_TBL,0x5000		# Page tables
+		.set MEM_TSS,0x2598		# TSS
+		.set MEM_MAP,0x2600		# I/O bit map
+		.set MEM_TSS_END,0x6000		# 
 		.set MEM_ORG,0x9000		# BTX code
 		.set MEM_USR,0xa000		# Start of user memory
 /*
@@ -86,9 +84,8 @@
  * Derivations, for brevity.
  */
 		.set _ESP0H,MEM_ESP0>>0x8	# Byte 1 of ESP0
-		.set _ESP1H,MEM_ESP1>>0x8	# Byte 1 of ESP1
 		.set _TSSIO,MEM_MAP-MEM_TSS	# TSS I/O base
-		.set _TSSLM,MEM_DIR-MEM_TSS-1	# TSS limit
+		.set _TSSLM,MEM_TSS_END-MEM_TSS-1	# TSS limit
 		.set _IDTLM,MEM_TSS-MEM_IDT-1	# IDT limit
 /*
  * Code segment.
@@ -103,7 +100,7 @@
 		.byte 0xe			# Header size
 		.ascii "BTX"			# Magic
 		.byte 0x1			# Major version
-		.byte 0x1			# Minor version
+		.byte 0x2			# Minor version
 		.byte BTX_FLAGS			# Flags
 		.word PAG_CNT-MEM_ORG>>0xc	# Paging control
 		.word break-start		# Text size
@@ -154,62 +151,19 @@
 /*
  * Initialize TSS.
  */
-init.4: 	movb $_ESP0H,TSS_ESP0+1(%di)	# Set ESP0
+init.4: 	movw $MEM_TSS,%di
+		movb $_ESP0H,TSS_ESP0+1(%di)	# Set ESP0
 		movb $SEL_SDATA,TSS_SS0(%di)	# Set SS0
-		movb $_ESP1H,TSS_ESP1+1(%di)	# Set ESP1
 		movb $_TSSIO,TSS_MAP(%di)	# Set I/O bit map base
-#ifdef PAGING
-/*
- * Create page directory.
- */
-		xor %edx,%edx			# Page
-		mov $PAG_SIZ>>0x8,%dh		#  size
-		xor %eax,%eax			# Zero
-		mov $MEM_DIR,%di		# Page directory
-		mov $PAG_CNT>>0xa,%cl		# Entries
-		mov $MEM_TBL|0x7,%ax	 	# First entry
-init.5: 	stosl				# Write entry
-		add %dx,%ax			# To next
-		loop init.5			# Till done
-/*
- * Create page tables.
- */
-		mov $MEM_TBL,%di		# Page table
-		mov $PAG_CNT>>0x8,%ch		# Entries
-		xor %ax,%ax			# Start address
-init.6: 	mov $0x7,%al			# Set U:W:P flags
-		cmp btx_hdr+0x8,%cx	 	# Standard user page?
-		jb init.7			# Yes
-		cmp $PAG_CNT-MEM_BTX>>0xc,%cx	# BTX memory?
-		jae init.7			# No or first page
-		and $~0x2,%al			# Clear W flag
-		cmp $PAG_CNT-MEM_USR>>0xc,%cx	# User page zero?
-		jne init.7			# No
-		testb $0x80,btx_hdr+0x7		# Unmap it?
-		jz init.7			# No
-		and $~0x1,%al			# Clear P flag
-init.7: 	stosl				# Set entry
-		add %edx,%eax			# Next address
-		loop init.6			# Till done
-#endif
 /*
  * Bring up the system.
  */
-		mov $0x2820,%bx			# Set protected mode
+		mov $0x7008,%bx			# Set protected mode
 		callw setpic			#  IRQ offsets
 		lidt idtdesc	 		# Set IDT
-#ifdef PAGING
-		xor %eax,%eax			# Set base
-		mov $MEM_DIR>>0x8,%ah		#  of page
-		mov %eax,%cr3			#  directory
-#endif
 		lgdt gdtdesc	 		# Set GDT
 		mov %cr0,%eax			# Switch to protected
-#ifdef PAGING
-		or $0x80000001,%eax             #  mode and enable paging
-#else
 		inc %ax				#  mode
-#endif
 		mov %eax,%cr0			#
 		ljmp $SEL_SCODE,$init.8		# To 32-bit code
 		.code32
@@ -300,7 +254,7 @@
 /*
  * Set IRQ offsets by reprogramming 8259A PICs.
  */
-setpic: 	in $0x21,%al			# Save master
+setpic:		in $0x21,%al			# Save master
 		push %ax			#  IMR
 		in $0xa1,%al			# Save slave
 		push %ax			#  IMR
@@ -325,10 +279,6 @@
 		retw				# To caller
 		.code32
 /*
- * Initiate return from V86 mode to user mode.
- */
-inthlt: 	hlt				# To supervisor mode
-/*
  * Exception jump table.
  */
 intx00: 	push $0x0			# Int 0x0: #DE
@@ -346,30 +296,33 @@
 		push $0x7			# Int 0x7: #NM
 		jmp ex_noc			# Device not available
 		push $0x8			# Int 0x8: #DF
-		jmp except			# Double fault
+		jmp ex_check			# Double fault
+		push $0x9
+		jmp int_hw
 		push $0xa			# Int 0xa: #TS
-		jmp except			# Invalid TSS
+		jmp ex_check			# Invalid TSS
 		push $0xb			# Int 0xb: #NP
-		jmp except			# Segment not present
+		jmp ex_check			# Segment not present
 		push $0xc			# Int 0xc: #SS
-		jmp except			# Stack segment fault
+		jmp ex_check			# Stack segment fault
 		push $0xd			# Int 0xd: #GP
-		jmp ex_v86			# General protection
+		jmp ex_check			# General protection
 		push $0xe			# Int 0xe: #PF
-		jmp except			# Page fault
+		jmp ex_check			# Page fault
+		pushl $0xf
+		jmp int_hw
 intx10: 	push $0x10			# Int 0x10: #MF
 		jmp ex_noc			# Floating-point error
 /*
- * Handle #GP exception.
- */
-ex_v86: 	testb $0x2,0x12(%esp,1) 	# V86 mode?
-		jz except			# No
-		jmp v86mon			# To monitor
-/*
  * Save a zero error code.
  */
 ex_noc: 	pushl (%esp,1)			# Duplicate int no
 		movb $0x0,0x4(%esp,1)		# Fake error code
+		jmp except
+
+ex_check:	cmpl $(MEM_ESP0-6*4),%esp
+		je int_hw
+		jmp except
 /*
  * Handle exception.
  */
@@ -418,234 +371,6 @@
 except.2a:	jmp exit			# Exit
 except.3:	leal 0x8(%esp,1),%esp		# Discard err, int no
 		iret				# From interrupt
-/*
- * Return to user mode from V86 mode.
- */
-intrtn: 	cld				# String ops inc
-		pushl %ds			# Address
-		popl %es			#  data
-		leal 0x3c(%ebp),%edx		# V86 Segment registers
-		movl MEM_TSS+TSS_ESP1,%esi	# Link stack pointer
-		lodsl				# INT_V86 args pointer
-		movl %esi,%ebx			# Saved exception frame
-		testl %eax,%eax 		# INT_V86 args?
-		jz intrtn.2			# No
-		movl $MEM_USR,%edi		# User base
-		movl 0x1c(%esi),%ebx		# User ESP
-		movl %eax,(%edi,%ebx,1) 	# Restore to user stack
-		leal 0x8(%edi,%eax,1),%edi	# Arg segment registers
-		testb $0x4,-0x6(%edi)		# Return flags?
-		jz intrtn.1			# No
-		movl 0x30(%ebp),%eax		# Get V86 flags
-		movw %ax,0x18(%esi)		# Set user flags
-intrtn.1:	leal 0x10(%esi),%ebx		# Saved exception frame
-		xchgl %edx,%esi 		# Segment registers
-		movb $0x4,%cl			# Update seg regs
-		rep				#  in INT_V86
-		movsl				#  args
-intrtn.2:	xchgl %edx,%esi			# Segment registers
-		leal 0x28(%ebp),%edi		# Set up seg
-		movb $0x4,%cl			#  regs for
-		rep				#  later
-		movsl				#  pop
-		xchgl %ebx,%esi			# Restore exception
-		movb $0x5,%cl			#  frame to
-		rep				#  supervisor
-		movsl				#  stack
-		movl %esi,MEM_TSS+TSS_ESP1	# Link stack pointer
-		popa				# Restore
-		leal 0x8(%esp,1),%esp		# Discard err, int no
-		popl %es			# Restore
-		popl %ds			#  user
-		popl %fs			#  segment
-		popl %gs			#  registers
-		iret				# To user mode
-/*
- * V86 monitor.
- */
-v86mon: 	cld				# String ops inc
-		pushl $SEL_SDATA		# Set up for
-		popl %ds			#  flat addressing
-		pusha				# Save registers
-		movl %esp,%ebp			# Address stack frame
-		movzwl 0x2c(%ebp),%edi		# Load V86 CS
-		shll $0x4,%edi			# To linear
-		movl 0x28(%ebp),%esi		# Load V86 IP
-		addl %edi,%esi			# Code pointer
-		xorl %ecx,%ecx			# Zero
-		movb $0x2,%cl			# 16-bit operands
-		xorl %eax,%eax			# Zero
-v86mon.1:	lodsb				# Get opcode
-		cmpb $0x66,%al			# Operand size prefix?
-		jne v86mon.2			# No
-		movb $0x4,%cl			# 32-bit operands
-		jmp v86mon.1			# Continue
-v86mon.2:	cmpb $0xf4,%al			# HLT?
-		jne v86mon.3			# No
-		cmpl $inthlt+0x1,%esi		# Is inthlt?
-		jne v86mon.7			# No (ignore)
-		jmp intrtn			# Return to user mode
-v86mon.3:	cmpb $0xf,%al			# Prefixed instruction?
-		jne v86mon.4			# No
-		cmpb $0x09,(%esi)		# Is it a WBINVD?
-		je v86wbinvd			# Yes
-		cmpb $0x30,(%esi)		# Is it a WRMSR?
-		je v86wrmsr			# Yes
-		cmpb $0x32,(%esi)		# Is it a RDMSR?
-		je v86rdmsr			# Yes
-		cmpb $0x20,(%esi)		# Is this a MOV reg,CRx?
-		je v86mov			# Yes
-v86mon.4:	cmpb $0xfa,%al			# CLI?
-		je v86cli			# Yes
-		cmpb $0xfb,%al			# STI?
-		je v86sti			# Yes
-		cmpb $0xcc,%al			# INT3?
-		je v86mon.7			# Yes, ignore
-		movzwl 0x38(%ebp),%ebx		# Load V86 SS
-		shll $0x4,%ebx			# To offset
-		pushl %ebx			# Save
-		addl 0x34(%ebp),%ebx		# Add V86 SP
-		movl 0x30(%ebp),%edx		# Load V86 flags
-		cmpb $0x9c,%al			# PUSHF/PUSHFD?
-		je v86pushf			# Yes
-		cmpb $0x9d,%al			# POPF/POPFD?
-		je v86popf			# Yes
-		cmpb $0xcd,%al			# INT imm8?
-		je v86intn			# Yes
-		cmpb $0xcf,%al			# IRET/IRETD?
-		je v86iret			# Yes
-		popl %ebx			# Restore
-		popa				# Restore
-		jmp except			# Handle exception
-v86mon.5:	movl %edx,0x30(%ebp)		# Save V86 flags
-v86mon.6:	popl %edx			# V86 SS adjustment
-		subl %edx,%ebx			# Save V86
-		movl %ebx,0x34(%ebp)		#  SP
-v86mon.7:	subl %edi,%esi			# From linear
-		movl %esi,0x28(%ebp)		# Save V86 IP
-		popa				# Restore
-		leal 0x8(%esp,1),%esp		# Discard int no, error
-		iret				# To V86 mode
-/*
- * Emulate MOV reg,CRx.
- */
-v86mov: 	movb 0x1(%esi),%bl		# Fetch Mod R/M byte
-		testb $0x10,%bl			# Read CR2 or CR3?
-		jnz v86mov.1			# Yes
-		movl %cr0,%eax			# Read CR0
-		testb $0x20,%bl			# Read CR4 instead?
-		jz v86mov.2			# No
-		movl %cr4,%eax			# Read CR4
-		jmp v86mov.2
-v86mov.1:	movl %cr2,%eax			# Read CR2
-		testb $0x08,%bl			# Read CR3 instead?
-		jz v86mov.2			# No
-		movl %cr3,%eax			# Read CR3
-v86mov.2:	andl $0x7,%ebx			# Compute offset in
-		shl $2,%ebx			#  frame of destination
-		neg %ebx			#  register
-		movl %eax,0x1c(%ebp,%ebx,1)	# Store CR to reg
-		incl %esi			# Adjust IP
-/*
- * Return from emulating a 0x0f prefixed instruction
- */
-v86preret:	incl %esi			# Adjust IP
-		jmp v86mon.7			# Finish up
-/*
- * Emulate WBINVD
- */
-v86wbinvd:	wbinvd				# Write back and invalidate
-						#  cache
-		jmp v86preret			# Finish up
-/*
- * Emulate WRMSR
- */
-v86wrmsr:	movl 0x18(%ebp),%ecx		# Get user's %ecx (MSR to write)
-		movl 0x14(%ebp),%edx		# Load the value
-		movl 0x1c(%ebp),%eax		#  to write
-		wrmsr				# Write MSR
-		jmp v86preret			# Finish up
-/*
- * Emulate RDMSR
- */
-v86rdmsr:	movl 0x18(%ebp),%ecx		# MSR to read
-		rdmsr				# Read the MSR
-		movl %eax,0x1c(%ebp)		# Return the value of
-		movl %edx,0x14(%ebp)		#  the MSR to the user
-		jmp v86preret			# Finish up
-/*
- * Emulate CLI.
- */
-v86cli: 	andb $~0x2,0x31(%ebp)		# Clear IF
-		jmp v86mon.7			# Finish up
-/*
- * Emulate STI.
- */
-v86sti: 	orb $0x2,0x31(%ebp)		# Set IF
-		jmp v86mon.7			# Finish up
-/*
- * Emulate PUSHF/PUSHFD.
- */
-v86pushf:	subl %ecx,%ebx			# Adjust SP
-		cmpb $0x4,%cl			# 32-bit
-		je v86pushf.1			# Yes
-		data16				# 16-bit
-v86pushf.1:	movl %edx,(%ebx)		# Save flags
-		jmp v86mon.6			# Finish up
-/*
- * Emulate IRET/IRETD.
- */
-v86iret:	movzwl (%ebx),%esi		# Load V86 IP
-		movzwl 0x2(%ebx),%edi		# Load V86 CS
-		leal 0x4(%ebx),%ebx		# Adjust SP
-		movl %edi,0x2c(%ebp)		# Save V86 CS
-		xorl %edi,%edi			# No ESI adjustment
-/*
- * Emulate POPF/POPFD (and remainder of IRET/IRETD).
- */
-v86popf:	cmpb $0x4,%cl			# 32-bit?
-		je v86popf.1			# Yes
-		movl %edx,%eax			# Initialize
-		data16				# 16-bit
-v86popf.1:	movl (%ebx),%eax		# Load flags
-		addl %ecx,%ebx			# Adjust SP
-		andl $V86_FLG,%eax		# Merge
-		andl $~V86_FLG,%edx		#  the
-		orl %eax,%edx			#  flags
-		jmp v86mon.5			# Finish up
-/*
- * trap int 15, function 87
- * reads %es:%si from saved registers on stack to find a GDT containing
- * source and destination locations
- * reads count of words from saved %cx
- * returns success by setting %ah to 0
- */
-int15_87:	pushl %esi			# Save 
-		pushl %edi			#  registers
-		movl 0x3C(%ebp),%edi		# Load ES
-		movzwl 0x4(%ebp),%eax		# Load user's SI
-		shll $0x4,%edi			# EDI = (ES << 4) +
-		addl %eax,%edi			#   SI
-		movl 0x11(%edi),%eax		# Read base of
-		movb 0x17(%edi),%al		#  GDT entry
-		ror $8,%eax			#  for source
-		xchgl %eax,%esi			#  into %esi
-		movl 0x19(%edi),%eax		# Read base of
-		movb 0x1f(%edi),%al		#  GDT entry for
-		ror $8,%eax			#  destination
-		xchgl %eax,%edi			#  into %edi
-		pushl %ds			# Make:
-		popl %es			# es = ds
-		movzwl 0x18(%ebp),%ecx		# Get user's CX
-		shll $0x1,%ecx			# Convert count from words
-		rep				# repeat...
-		movsb				#  perform copy.
-		popl %edi			# Restore
-		popl %esi			#  registers
-		movb $0x0,0x1d(%ebp)		# set ah = 0 to indicate
-						#  success
-		andb $0xfe,%dl			# clear CF
-		jmp v86mon.5			# Finish up
 
 /*
  * Reboot the machine by setting the reboot flag and exiting
@@ -654,54 +379,9 @@
 		jmp exit			# Terminate BTX and reboot
 
 /*
- * Emulate INT imm8... also make sure to check if it's int 15/87
+ * Hardware interrupt jump table for slave PIC.
  */
-v86intn:	lodsb				# Get int no
-		cmpb $0x19,%al			# is it int 19?
-		je reboot			#  yes, reboot the machine
-		cmpb $0x15,%al			# is it int 15?
-		jne v86intn.1			#  no, skip parse
-		cmpb $0x87,0x1d(%ebp)		# is it the memcpy subfunction?
-		je int15_87			#  yes
-		cmpw $0x4f53,0x1c(%ebp)		# is it the delete key callout?
-		jne v86intn.1			#  no, handle the int normally
-		movb BDA_KEYFLAGS,%ch		# get the shift key state
-		andb $0xc,%ch			# mask off just Ctrl and Alt
-		cmpb $0xc,%ch			# are both Ctrl and Alt down?
-		je reboot			# yes, reboot the machine
-v86intn.1:	subl %edi,%esi			# From
-		shrl $0x4,%edi			#  linear
-		movw %dx,-0x2(%ebx)		# Save flags
-		movw %di,-0x4(%ebx)		# Save CS
-		leal -0x6(%ebx),%ebx		# Adjust SP
-		movw %si,(%ebx) 		# Save IP
-		shll $0x2,%eax			# Scale
-		movzwl (%eax),%esi		# Load IP
-		movzwl 0x2(%eax),%edi		# Load CS
-		movl %edi,0x2c(%ebp)		# Save CS
-		xorl %edi,%edi			# No ESI adjustment
-		andb $~0x1,%dh			# Clear TF
-		jmp v86mon.5			# Finish up
-/*
- * Hardware interrupt jump table.
- */
-intx20: 	push $0x8			# Int 0x20: IRQ0
-		jmp int_hw			# V86 int 0x8
-		push $0x9			# Int 0x21: IRQ1
-		jmp int_hw			# V86 int 0x9
-		push $0xa			# Int 0x22: IRQ2
-		jmp int_hw			# V86 int 0xa
-		push $0xb			# Int 0x23: IRQ3
-		jmp int_hw			# V86 int 0xb
-		push $0xc			# Int 0x24: IRQ4
-		jmp int_hw			# V86 int 0xc
-		push $0xd			# Int 0x25: IRQ5
-		jmp int_hw			# V86 int 0xd
-		push $0xe			# Int 0x26: IRQ6
-		jmp int_hw			# V86 int 0xe
-		push $0xf			# Int 0x27: IRQ7
-		jmp int_hw			# V86 int 0xf
-		push $0x70			# Int 0x28: IRQ8
+intx70:		push $0x70			# Int 0x28: IRQ8
 		jmp int_hw			# V86 int 0x70
 		push $0x71			# Int 0x29: IRQ9
 		jmp int_hw			# V86 int 0x71
@@ -717,127 +397,193 @@
 		jmp int_hw			# V86 int 0x76
 		push $0x77			# Int 0x2f: IRQ15
 		jmp int_hw			# V86 int 0x77
-/*
- * Reflect hardware interrupts.
- */
-int_hw: 	testb $0x2,0xe(%esp,1)		# V86 mode?
-		jz intusr			# No
-		pushl $SEL_SDATA		# Address
-		popl %ds			#  data
-		xchgl %eax,(%esp,1)		# Swap EAX, int no
-		pushl %ebp			# Address
-		movl %esp,%ebp			#  stack frame
-		pushl %ebx			# Save
-		shll $0x2,%eax			# Get int
-		movl (%eax),%eax		#  vector
-		subl $0x6,0x14(%ebp)		# Adjust V86 ESP
-		movzwl 0x18(%ebp),%ebx		# V86 SS
-		shll $0x4,%ebx			#  * 0x10
-		addl 0x14(%ebp),%ebx		#  + V86 ESP
-		xchgw %ax,0x8(%ebp)		# Swap V86 IP
-		rorl $0x10,%eax 		# Swap words
-		xchgw %ax,0xc(%ebp)		# Swap V86 CS
-		roll $0x10,%eax 		# Swap words
-		movl %eax,(%ebx)		# CS:IP for IRET
-		movl 0x10(%ebp),%eax		# V86 flags
-		movw %ax,0x4(%ebx)		# Flags for IRET
-		andb $~0x3,0x11(%ebp)		# Clear IF, TF
-		popl %ebx			# Restore
-		popl %ebp			#  saved
-		popl %eax			#  registers
-		iret				# To V86 mode
-/*
- * Invoke V86 interrupt from user mode, with arguments.
- */
-intx31: 	stc				# Have btx_v86
-		pushl %eax			# Missing int no
-/*
- * Invoke V86 interrupt from user mode.
- */
-intusr: 	std				# String ops dec
-		pushl %eax			# Expand
-		pushl %eax			#  stack
-		pushl %eax			#  frame
-		pusha				# Save
-		pushl %gs			# Save
-		movl %esp,%eax			#  seg regs
-		pushl %fs			#  and
-		pushl %ds			#  point
-		pushl %es			#  to them
-		push $SEL_SDATA			# Set up
-		popl %ds			#  to
-		pushl %ds			#  address
-		popl %es			#  data
-		movl $MEM_USR,%ebx		# User base
-		movl %ebx,%edx			#  address
-		jc intusr.1			# If btx_v86
-		xorl %edx,%edx			# Control flags
-		xorl %ebp,%ebp			# btx_v86 pointer
-intusr.1:	leal 0x50(%esp,1),%esi		# Base of frame
-		pushl %esi			# Save
-		addl -0x4(%esi),%ebx		# User ESP
-		movl MEM_TSS+TSS_ESP1,%edi	# Link stack pointer
-		leal -0x4(%edi),%edi		# Adjust for push
-		xorl %ecx,%ecx			# Zero
-		movb $0x5,%cl			# Push exception
-		rep				#  frame on
-		movsl				#  link stack
-		xchgl %eax,%esi 		# Saved seg regs
-		movl 0x40(%esp,1),%eax		# Get int no
-		testl %edx,%edx 		# Have btx_v86?
-		jz intusr.2			# No
-		movl (%ebx),%ebp		# btx_v86 pointer
-		movb $0x4,%cl			# Count
-		addl %ecx,%ebx			# Adjust for pop
-		rep				# Push saved seg regs
-		movsl				#  on link stack
-		addl %ebp,%edx			# Flatten btx_v86 ptr
-		leal 0x14(%edx),%esi		# Seg regs pointer
-		movl 0x4(%edx),%eax		# Get int no/address
-		movzwl 0x2(%edx),%edx		# Get control flags
-intusr.2:	movl %ebp,(%edi)		# Push btx_v86 and
-		movl %edi,MEM_TSS+TSS_ESP1	#  save link stack ptr
-		popl %edi			# Base of frame
-		xchgl %eax,%ebp 		# Save intno/address
-		movl 0x48(%esp,1),%eax		# Get flags
-		testb $0x2,%dl			# Simulate CALLF?
-		jnz intusr.3			# Yes
-		decl %ebx			# Push flags
-		decl %ebx			#  on V86
-		movw %ax,(%ebx) 		#  stack
-intusr.3:	movb $0x4,%cl			# Count
-		subl %ecx,%ebx			# Push return address
-		movl $inthlt,(%ebx)		#  on V86 stack
-		rep				# Copy seg regs to
-		movsl				#  exception frame
-		xchgl %eax,%ecx 		# Save flags
-		movl %ebx,%eax			# User ESP
-		subl $V86_STK,%eax		# Less bytes
-		ja intusr.4			#  to
-		xorl %eax,%eax			#  keep
-intusr.4:	shrl $0x4,%eax			# Gives segment
-		stosl				# Set SS
-		shll $0x4,%eax			# To bytes
-		xchgl %eax,%ebx 		# Swap
-		subl %ebx,%eax			# Gives offset
-		stosl				# Set ESP
-		xchgl %eax,%ecx 		# Get flags
-		btsl $0x11,%eax 		# Set VM
-		andb $~0x1,%ah			# Clear TF
-		stosl				# Set EFL
-		xchgl %eax,%ebp 		# Get int no/address
-		testb $0x1,%dl			# Address?
-		jnz intusr.5			# Yes
-		shll $0x2,%eax			# Scale
-		movl (%eax),%eax		# Load int vector
-intusr.5:	movl %eax,%ecx			# Save
-		shrl $0x10,%eax 		# Gives segment
-		stosl				# Set CS
-		movw %cx,%ax			# Restore
-		stosl				# Set EIP
-		leal 0x10(%esp,1),%esp		# Discard seg regs
-		popa				# Restore
-		iret				# To V86 mode
+
+intx31r:	pushl $-1			# fake intno
+int_hw:		pushl %gs
+		pushl %fs
+		pushl %ds
+		pushl %es
+		subl $(7*4),%esp	# space for iret and tramp frames, rsegs
+		pushal
+		pushl $SEL_SDATA
+		popl %ds
+		pushl %ds
+		popl %es
+		cld
+		movl $MEM_USR, %ebx
+		movl %ebx, %edi
+		addl (23*4)(%esp),%edi	# %edi = pointer to user stack (linear)
+		movl $25,%ecx
+		movl %esp,%esi
+		# copy the frame to the user stack
+		movl $(25*4),%edx
+		subl %edx,%edi
+		rep movsl
+		addl (%edi),%ebx	# %ebx = pointer to __v86 (linear)
+		subl %edx,%edi
+	# form the return trampoline structure on user stack
+		movl (19*4)(%edi),%eax		# intno
+		movl $2,%ecx
+		cmpl $-1,%eax
+		jne intx31r.2
+intx31r.1:	movl (5*4)(%ebx),%edx		# rgs
+		movl %edx,(11*4)(%edi)
+		movl (4*4)(%ebx),%edx		# rfs
+		movl %edx,(10*4)(%edi)
+		movl (3*4)(%ebx),%edx		# rds
+		movl %edx,(9*4)(%edi)
+		movl (2*4)(%ebx),%edx		# res
+		movl %edx,(8*4)(%edi)
+		movl 4(%ebx),%eax		# v86.addr
+		movw $0x202,%cx
+		testb $0x2,2(%ebx)		# V86_CALLF
+		jne intx31r.3
+intx31r.2:	shll $2,%eax			# %eax = intno
+		movl (%eax),%eax
+		movl $rret,%esi
+		jmp set_tramp
+intx31r.3:	movl $callftramp,%esi
+		testb $0x1,2(%ebx)		# V86_ADDR
+		jne set_tramp
+		movl %eax,%edx
+		shrl $4,%edx
+		shll $4,%edx
+		subl %edx,%eax
+		shll $16,%edx
+		movw %ax,%dx
+		movl %edx,%eax
+set_tramp:	movl %eax,(12*4)(%edi)		# tramp addr
+		movw %cx,(12*4+4)(%edi)		# tramp flags
+		movl %esi,(13*4+2)(%edi)	# iret addr
+		movw $0x2,(14*4+2)(%edi)	# iret flags
+
+#if 0
+		movl (19*4)(%edi),%eax
+		cmpl $-1,%eax
+		jne 1f
+		movl $10,%eax
+		movb $0x8b,%bl
+		jmp 2f
+		movb $0xa2,%bl
+		cmp $0x70,%eax
+		jae 1f
+		subl $0x8,%eax
+		jmp 2f
+1:		subl $(0x70-0x8),%eax
+2:		xorl %ecx,%ecx
+		leal intstat(%ecx,%eax,4),%edx
+		incl (%edx)
+		movl (%edx),%edx
+		andl $0xf,%edx
+		cmpl $9,%edx
+		jbe 1f
+		addl $('A'-10),%edx
+		jmp 2f
+1:		addl $'0',%edx
+2:		movb %bl,%dh
+		movw %dx,(0xb8000+80-20)(%ecx,%eax,2)
+#endif
+		
+	# go to real mode
+	# %edi = start of stack frame
+go.to.real:	ljmpw $SEL_RCODE,$intx31r.r1
+		.code16
+intx31r.r1: 	movw $SEL_RDATA,%cx
+		movw %cx,%ss
+		movw %cx,%ds
+		movw %cx,%es
+		movw %cx,%fs
+		movw %cx,%gs
+		movl %cr0,%eax
+		andl $~0x1,%eax
+		movl %eax,%cr0
+		ljmp $0x0,$intx31r.r2
+intx31r.r2: # recalc rmode stack
+		movl %edi, %eax
+		subl $V86_STK,%eax
+		ja intx31r.r3
+		xorl %eax,%eax
+intx31r.r3:	shrl $0x4,%eax
+		movl %eax,%ecx
+		shll $0x4,%eax
+		subl %eax,%edi
+		movw %cx,%ss
+		movl %edi,%esp
+		lidt ivtdesc
+		popal
+		popl %es
+		popl %ds
+		popl %fs
+		popl %gs
+		iret
+		.code32
+
+		.code16
+callftramp:	pushw %bp	# for CALLF calls, remove flags from stack
+		movw %sp,%bp
+		movw %ax,2(%bp)
+		popw %bp
+		popw %ax
+rret:		cli
+		pushal
+		pushfl
+		pushl %gs
+		pushl %fs
+		pushl %ds
+		pushl %es
+		xorl %esi,%esi
+		movw %si,%ds
+		movw %si,%es
+		movw %ss,%si
+		shll $4,%esi
+		addl %esp,%esi			# %esi = start of saved frame
+		lidt idtdesc
+		lgdt gdtdesc
+		movl %cr0,%eax
+		orl $1,%eax
+		movl %eax,%cr0
+		ljmp $SEL_SCODE,$rret.1
+		.code32
+rret.1: 	xorl %ecx,%ecx
+		movb $SEL_SDATA,%cl
+		movl %ecx,%es
+		movl %ecx,%ds
+		movl %ecx,%ss
+		movl %esi,%esp
+		andb $~0x2,tss_desc+0x5		# clear TSS busy
+		movw $SEL_TSS,%cx
+		ltr %cx
+	# copy the v86 dump frame to v86
+		cmpl $-1,(17*4)(%esi)		# intno
+		jne rret.2
+		movl $MEM_USR,%ebx	# return from int $31
+		addl (23*4)(%esi),%ebx	# %ebx = pointer to __v86 (linear)
+		movl (3*4)(%esi),%edx	# rgs
+		movl %edx,(5*4)(%ebx)
+		movl (2*4)(%esi),%edx	# rfs
+		movl %edx,(4*4)(%ebx)
+		movl (1*4)(%esi),%edx	# rds
+		movl %edx,(3*4)(%ebx)
+		movl (%esi),%edx	# res
+		movl %edx,(2*4)(%ebx)
+		testb $0x4,2(%ebx)
+		jz rret.2
+		movw (4*4)(%esi),%dx	# eflags
+		orl $0x3202,%edx
+		andl $~0x1f4000,%edx
+		jmp rret.3
+rret.2:		movw $0x202,%dx
+rret.3:		movw %dx,(20*4)(%esi)
+		addl $(5*4),%esp	# remove the saved rsegs and eflags
+		popal
+		popl %es
+		popl %ds
+		popl %fs
+		popl %gs
+		movl %eax,(%esp)
+		popl %eax		# shut intno
+		iret
+
 /*
  * System Call.
  */
@@ -854,13 +600,6 @@
 		movl $MEM_USR,%eax		# User base address
 		addl 0xc(%esp,1),%eax		# Change to user
 		leal 0x4(%eax),%esp		#  stack
-#ifdef PAGING
-		movl %cr0,%eax			# Turn
-		andl $~0x80000000,%eax		#  off
-		movl %eax,%cr0			#  paging
-		xorl %eax,%eax			# Flush
-		movl %eax,%cr3			#  TLB
-#endif
 		popl %eax			# Call
 		call *%eax			#  program
 intx30.1:	orb $0x1,%ss:btx_hdr+0x7	# Flag reboot
@@ -1097,7 +836,7 @@
 		.word 0xffff,0x0,0x9200,0x0	# SEL_RDATA
 		.word 0xffff,MEM_USR,0xfa00,0xcf# SEL_UCODE
 		.word 0xffff,MEM_USR,0xf200,0xcf# SEL_UDATA
-		.word _TSSLM,MEM_TSS,0x8900,0x0 # SEL_TSS
+tss_desc:	.word _TSSLM,MEM_TSS,0x8900,0x0 # SEL_TSS
 gdt.1:
 /*
  * Pseudo-descriptors.
@@ -1109,15 +848,25 @@
  * IDT construction control string.
  */
 idtctl: 	.byte 0x10,  0x8e		# Int 0x0-0xf
-		.word 0x7dfb,intx00		#  (exceptions)
+		.word 0xfffb,intx00		#  (exceptions/hw)
 		.byte 0x10,  0x8e		# Int 0x10
 		.word 0x1,   intx10		#  (exception)
-		.byte 0x10,  0x8e		# Int 0x20-0x2f
-		.word 0xffff,intx20		#  (hardware)
+		.byte 0x10,  0			# Int 0x20-0x2f
+		.word 0x0,   0			#  (empty)
 		.byte 0x1,   0xee		# int 0x30
 		.word 0x1,   intx30		#  (system call)
-		.byte 0x2,   0xee		# Int 0x31-0x32
-		.word 0x1,   intx31		#  (V86, null)
+		.byte 0x1,   0xee		# Int 0x31
+		.word 0x1,   intx31r		#  (V86)
+		.byte 0xe,   0			# Int 0x32-0x3f
+		.word 0x0,   0			#  (empty)
+		.byte 0x10,  0			# Int 0x40-0x4f
+		.word 0x0,   0			#  (empty)
+		.byte 0x10,  0			# Int 0x50-0x5f
+		.word 0x0,   0			#  (empty)
+		.byte 0x10,  0			# Int 0x60-0x6f
+		.word 0x0,   0			#  (empty)
+		.byte 0x8,   0x8e		# Int 0x70-0x77
+		.word 0xff,  intx70		#  (hardware)
 		.byte 0x0			# End of string
 /*
  * Dump format string.
@@ -1168,5 +917,12 @@
 /*
  * End of BTX memory.
  */
+#if 0
+		.p2align 4
+intstat:	.rept 17
+		.word 0
+		.endr
+#endif
+	
 		.p2align 4
 break:
Index: i386/cdboot/cdboot.s
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/cdboot/cdboot.s,v
retrieving revision 1.13.8.3
diff -u -r1.13.8.3 cdboot.s
--- i386/cdboot/cdboot.s	13 Sep 2006 15:17:41 -0000	1.13.8.3
+++ i386/cdboot/cdboot.s	23 Feb 2007 21:07:44 -0000
@@ -27,7 +27,7 @@
 # SUCH DAMAGE.
 #
 
-# $FreeBSD: src/sys/boot/i386/cdboot/cdboot.s,v 1.13.8.3 2006/09/13 15:17:41 jhb Exp $
+# $FreeBSD: src/sys/boot/i386/cdboot/cdboot.s,v 1.17 2007/02/23 21:07:44 remko Exp $
 
 #
 # This program is a freestanding boot program to load an a.out binary
@@ -472,7 +472,7 @@
 twiddle:	push %ax			# Save
 		push %bx			# Save
 		mov twiddle_index,%al		# Load index
-		mov twiddle_chars,%bx		# Address table
+		mov $twiddle_chars,%bx		# Address table
 		inc %al				# Next
 		and $3,%al			#  char
 		mov %al,twiddle_index		# Save index for next call
Index: i386/libi386/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/Makefile,v
retrieving revision 1.37.2.2
diff -u -r1.37.2.2 Makefile
--- i386/libi386/Makefile	1 Oct 2006 12:07:07 -0000	1.37.2.2
+++ i386/libi386/Makefile	11 Apr 2006 20:11:30 -0000
@@ -1,4 +1,4 @@
-# $FreeBSD: src/sys/boot/i386/libi386/Makefile,v 1.37.2.2 2006/10/01 12:07:07 ru Exp $
+# $FreeBSD: src/sys/boot/i386/libi386/Makefile,v 1.42 2006/04/11 20:11:30 jhb Exp $
 #
 LIB=			i386
 INTERNALLIB=
Index: i386/libi386/biosacpi.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/biosacpi.c,v
retrieving revision 1.10.2.1
diff -u -r1.10.2.1 biosacpi.c
--- i386/libi386/biosacpi.c	1 Oct 2006 12:07:07 -0000	1.10.2.1
+++ i386/libi386/biosacpi.c	22 Mar 2007 18:16:39 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biosacpi.c,v 1.10.2.1 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biosacpi.c,v 1.12 2007/03/22 18:16:39 jkim Exp $");
 
 #include <stand.h>
 #include <machine/stdarg.h>
@@ -44,15 +44,15 @@
  * environment.
  */
 
-static RSDP_DESCRIPTOR	*biosacpi_find_rsdp(void);
-static RSDP_DESCRIPTOR	*biosacpi_search_rsdp(char *base, int length);
+static ACPI_TABLE_RSDP	*biosacpi_find_rsdp(void);
+static ACPI_TABLE_RSDP	*biosacpi_search_rsdp(char *base, int length);
 
 #define RSDP_CHECKSUM_LENGTH 20
 
 void
 biosacpi_detect(void)
 {
-    RSDP_DESCRIPTOR	*rsdp;
+    ACPI_TABLE_RSDP	*rsdp;
     char		buf[24];
     int			revision;
 
@@ -63,6 +63,8 @@
 	return;
 
     /* export values from the RSDP */
+    sprintf(buf, "%p", VTOP(rsdp));
+    setenv("hint.acpi.0.rsdp", buf, 1);
     revision = rsdp->Revision;
     if (revision == 0)
 	revision = 1;
@@ -88,10 +90,10 @@
 /*
  * Find the RSDP in low memory.  See section 5.2.2 of the ACPI spec.
  */
-static RSDP_DESCRIPTOR *
+static ACPI_TABLE_RSDP *
 biosacpi_find_rsdp(void)
 {
-    RSDP_DESCRIPTOR	*rsdp;
+    ACPI_TABLE_RSDP	*rsdp;
     uint16_t		*addr;
 
     /* EBDA is the 1 KB addressed by the 16 bit pointer at 0x40E. */
@@ -106,19 +108,19 @@
     return (NULL);
 }
 
-static RSDP_DESCRIPTOR *
+static ACPI_TABLE_RSDP *
 biosacpi_search_rsdp(char *base, int length)
 {
-    RSDP_DESCRIPTOR	*rsdp;
+    ACPI_TABLE_RSDP	*rsdp;
     u_int8_t		*cp, sum;
     int			ofs, idx;
 
     /* search on 16-byte boundaries */
     for (ofs = 0; ofs < length; ofs += 16) {
-	rsdp = (RSDP_DESCRIPTOR *)PTOV(base + ofs);
+	rsdp = (ACPI_TABLE_RSDP *)PTOV(base + ofs);
 
 	/* compare signature, validate checksum */
-	if (!strncmp(rsdp->Signature, RSDP_SIG, strlen(RSDP_SIG))) {
+	if (!strncmp(rsdp->Signature, ACPI_SIG_RSDP, strlen(ACPI_SIG_RSDP))) {
 	    cp = (u_int8_t *)rsdp;
 	    sum = 0;
 	    for (idx = 0; idx < RSDP_CHECKSUM_LENGTH; idx++)
Index: i386/libi386/bioscd.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/bioscd.c,v
retrieving revision 1.8
diff -u -r1.8 bioscd.c
--- i386/libi386/bioscd.c	20 May 2005 13:14:18 -0000	1.8
+++ i386/libi386/bioscd.c	2 Nov 2006 01:23:17 -0000
@@ -26,7 +26,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bioscd.c,v 1.8 2005/05/20 13:14:18 charnier Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bioscd.c,v 1.9 2006/11/02 01:23:17 marcel Exp $");
 
 /*
  * BIOS CD device handling for CD's that have been booted off of via no
@@ -195,7 +195,7 @@
 	va_start(ap, f);
 	dev = va_arg(ap, struct i386_devdesc *);
 	va_end(ap);
-	if (dev->d_kind.bioscd.unit >= nbcinfo) {
+	if (dev->d_unit >= nbcinfo) {
 		DEBUG("attempt to open nonexistent disk");
 		return(ENXIO);
 	}
@@ -230,7 +230,7 @@
 	if (rw != F_READ)
 		return(EROFS);
 	dev = (struct i386_devdesc *)devdata;
-	unit = dev->d_kind.bioscd.unit;
+	unit = dev->d_unit;
 	blks = size / BIOSCD_SECSIZE;
 	if (dblk % (BIOSCD_SECSIZE / DEV_BSIZE) != 0)
 		return (EINVAL);
@@ -331,7 +331,7 @@
     int major;
     int rootdev;
 
-    unit = dev->d_kind.bioscd.unit;
+    unit = dev->d_unit;
     biosdev = bc_unit2bios(unit);
     DEBUG("unit %d BIOS device %d", unit, biosdev);
     if (biosdev == -1)				/* not a BIOS device */
Index: i386/libi386/biosdisk.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/biosdisk.c,v
retrieving revision 1.45.2.2
diff -u -r1.45.2.2 biosdisk.c
--- i386/libi386/biosdisk.c	1 Oct 2006 12:07:07 -0000	1.45.2.2
+++ i386/libi386/biosdisk.c	2 Nov 2006 01:23:17 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biosdisk.c,v 1.45.2.2 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biosdisk.c,v 1.48 2006/11/02 01:23:17 marcel Exp $");
 
 /*
  * BIOS disk device handling.
@@ -251,7 +251,7 @@
 	pager_output(line);
 
 	/* try to open the whole disk */
-	dev.d_kind.biosdisk.unit = i;
+	dev.d_unit = i;
 	dev.d_kind.biosdisk.slice = -1;
 	dev.d_kind.biosdisk.partition = -1;
 	
@@ -454,7 +454,7 @@
     int				error;
     char			buf[BUFSIZE];
 
-    if (dev->d_kind.biosdisk.unit >= nbdinfo) {
+    if (dev->d_unit >= nbdinfo) {
 	DEBUG("attempt to open nonexistent disk");
 	return(ENXIO);
     }
@@ -466,14 +466,14 @@
     }
 
     /* Look up BIOS unit number, intialise open_disk structure */
-    od->od_dkunit = dev->d_kind.biosdisk.unit;
+    od->od_dkunit = dev->d_unit;
     od->od_unit = bdinfo[od->od_dkunit].bd_unit;
     od->od_flags = bdinfo[od->od_dkunit].bd_flags;
     od->od_boff = 0;
     od->od_nslices = 0;
     error = 0;
     DEBUG("open '%s', unit 0x%x slice %d partition %c",
-	     i386_fmtdev(dev), dev->d_kind.biosdisk.unit, 
+	     i386_fmtdev(dev), dev->d_unit, 
 	     dev->d_kind.biosdisk.slice, dev->d_kind.biosdisk.partition + 'a');
 
     /* Get geometry for this open (removable device may have changed) */
@@ -1177,8 +1177,8 @@
     char			*nip, *cp;
     int				unitofs = 0, i, unit;
 
-    biosdev = bd_unit2bios(dev->d_kind.biosdisk.unit);
-    DEBUG("unit %d BIOS device %d", dev->d_kind.biosdisk.unit, biosdev);
+    biosdev = bd_unit2bios(dev->d_unit);
+    DEBUG("unit %d BIOS device %d", dev->d_unit, biosdev);
     if (biosdev == -1)				/* not a BIOS device */
 	return(-1);
     if (bd_opendisk(&od, dev) != 0)		/* oops, not a viable device */
@@ -1186,7 +1186,7 @@
 
     if (biosdev < 0x80) {
 	/* floppy (or emulated floppy) or ATAPI device */
-	if (bdinfo[dev->d_kind.biosdisk.unit].bd_type == DT_ATAPI) {
+	if (bdinfo[dev->d_unit].bd_type == DT_ATAPI) {
 	    /* is an ATAPI disk */
 	    major = WFDMAJOR;
 	} else {
Index: i386/libi386/biosmem.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/biosmem.c,v
retrieving revision 1.7.10.1
diff -u -r1.7.10.1 biosmem.c
--- i386/libi386/biosmem.c	1 Oct 2006 12:07:07 -0000	1.7.10.1
+++ i386/libi386/biosmem.c	21 Dec 2005 02:17:58 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biosmem.c,v 1.7.10.1 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biosmem.c,v 1.8 2005/12/21 02:17:58 sobomax Exp $");
 
 /*
  * Obtain memory configuration information from the BIOS
Index: i386/libi386/biospci.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/biospci.c,v
retrieving revision 1.5
diff -u -r1.5 biospci.c
--- i386/libi386/biospci.c	22 Oct 2004 14:56:23 -0000	1.5
+++ i386/libi386/biospci.c	29 Sep 2006 20:27:41 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biospci.c,v 1.5 2004/10/22 14:56:23 simokawa Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biospci.c,v 1.6 2006/09/29 20:27:41 ru Exp $");
 
 /*
  * PnP enumerator using the PCI BIOS.
@@ -36,6 +36,7 @@
 #include <bootstrap.h>
 #include <isapnp.h>
 #include <btxv86.h>
+#include "libi386.h"
 
 /*
  * Stupid PCI BIOS interface doesn't let you simply enumerate everything
Index: i386/libi386/biospnp.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/biospnp.c,v
retrieving revision 1.9.10.1
diff -u -r1.9.10.1 biospnp.c
--- i386/libi386/biospnp.c	1 Oct 2006 12:07:07 -0000	1.9.10.1
+++ i386/libi386/biospnp.c	19 Dec 2005 09:00:11 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biospnp.c,v 1.9.10.1 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biospnp.c,v 1.10 2005/12/19 09:00:11 sobomax Exp $");
 
 /*
  * PnP BIOS enumerator.
Index: i386/libi386/biossmap.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/biossmap.c,v
retrieving revision 1.3.2.2
diff -u -r1.3.2.2 biossmap.c
--- i386/libi386/biossmap.c	19 Oct 2006 14:47:21 -0000	1.3.2.2
+++ i386/libi386/biossmap.c	29 Sep 2006 20:07:16 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biossmap.c,v 1.3.2.2 2006/10/19 14:47:21 jhb Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/biossmap.c,v 1.6 2006/09/29 20:07:16 jhb Exp $");
 
 /*
  * Obtain memory configuration information from the BIOS
Index: i386/libi386/bootinfo.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/bootinfo.c,v
retrieving revision 1.37.2.1
diff -u -r1.37.2.1 bootinfo.c
--- i386/libi386/bootinfo.c	14 Feb 2006 06:20:15 -0000	1.37.2.1
+++ i386/libi386/bootinfo.c	22 Sep 2005 15:14:12 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bootinfo.c,v 1.37.2.1 2006/02/14 06:20:15 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bootinfo.c,v 1.39 2005/09/22 15:14:12 ru Exp $");
 
 #include <stand.h>
 #include <sys/param.h>
Index: i386/libi386/bootinfo32.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/bootinfo32.c,v
retrieving revision 1.36
diff -u -r1.36 bootinfo32.c
--- i386/libi386/bootinfo32.c	25 Aug 2003 23:28:31 -0000	1.36
+++ i386/libi386/bootinfo32.c	2 Nov 2006 01:23:17 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bootinfo32.c,v 1.36 2003/08/25 23:28:31 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bootinfo32.c,v 1.37 2006/11/02 01:23:17 marcel Exp $");
 
 #include <stand.h>
 #include <sys/param.h>
@@ -172,13 +172,13 @@
     switch(rootdev->d_type) {
     case DEVT_CD:
 	    /* Pass in BIOS device number. */
-	    bi.bi_bios_dev = bc_unit2bios(rootdev->d_kind.bioscd.unit);
+	    bi.bi_bios_dev = bc_unit2bios(rootdev->d_unit);
 	    bootdevnr = bc_getdev(rootdev);
 	    break;
 
     case DEVT_DISK:
 	/* pass in the BIOS device number of the current disk */
-	bi.bi_bios_dev = bd_unit2bios(rootdev->d_kind.biosdisk.unit);
+	bi.bi_bios_dev = bd_unit2bios(rootdev->d_unit);
 	bootdevnr = bd_getdev(rootdev);
 	break;
 
Index: i386/libi386/bootinfo64.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/bootinfo64.c,v
retrieving revision 1.36
diff -u -r1.36 bootinfo64.c
--- i386/libi386/bootinfo64.c	25 Aug 2003 23:28:31 -0000	1.36
+++ i386/libi386/bootinfo64.c	29 Sep 2006 20:27:41 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bootinfo64.c,v 1.36 2003/08/25 23:28:31 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/bootinfo64.c,v 1.37 2006/09/29 20:27:41 ru Exp $");
 
 #include <stand.h>
 #include <sys/param.h>
@@ -143,9 +143,7 @@
     u_int64_t			envp;
     vm_offset_t			size;
     char			*rootdevname;
-    int				i, howto;
-    char			*kernelname;
-    const char			*kernelpath;
+    int				howto;
 
     howto = bi_getboothowto(args);
 
Index: i386/libi386/comconsole.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/comconsole.c,v
retrieving revision 1.10.10.1
diff -u -r1.10.10.1 comconsole.c
--- i386/libi386/comconsole.c	27 Jan 2006 01:36:24 -0000	1.10.10.1
+++ i386/libi386/comconsole.c	18 Aug 2005 01:39:43 -0000
@@ -24,7 +24,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/comconsole.c,v 1.10.10.1 2006/01/27 01:36:24 emaste Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/comconsole.c,v 1.11 2005/08/18 01:39:43 iedowse Exp $");
 
 #include <stand.h>
 #include <bootstrap.h>
Index: i386/libi386/devicename.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/devicename.c,v
retrieving revision 1.7
diff -u -r1.7 devicename.c
--- i386/libi386/devicename.c	27 May 2005 19:28:04 -0000	1.7
+++ i386/libi386/devicename.c	2 Nov 2006 01:23:17 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/devicename.c,v 1.7 2005/05/27 19:28:04 jhb Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/devicename.c,v 1.8 2006/11/02 01:23:17 marcel Exp $");
 
 #include <stand.h>
 #include <string.h>
@@ -142,7 +142,7 @@
 	    goto fail;
 	}
 
-	idev->d_kind.biosdisk.unit = unit;
+	idev->d_unit = unit;
 	idev->d_kind.biosdisk.slice = slice;
 	idev->d_kind.biosdisk.partition = partition;
 	if (path != NULL)
@@ -165,10 +165,7 @@
 	    goto fail;
 	}
 
-	if (dv->dv_type == DEVT_NET)
-	    idev->d_kind.netif.unit = unit;
-	else
-	    idev->d_kind.bioscd.unit = unit;
+	idev->d_unit = unit;
 	if (path != NULL)
 	    *path = (*cp == 0) ? cp : cp + 1;
 	break;
@@ -205,12 +202,12 @@
 	break;
 
     case DEVT_CD:
-	sprintf(buf, "%s%d:", dev->d_dev->dv_name, dev->d_kind.bioscd.unit);
+	sprintf(buf, "%s%d:", dev->d_dev->dv_name, dev->d_unit);
 	break;
 
     case DEVT_DISK:
 	cp = buf;
-	cp += sprintf(cp, "%s%d", dev->d_dev->dv_name, dev->d_kind.biosdisk.unit);
+	cp += sprintf(cp, "%s%d", dev->d_dev->dv_name, dev->d_unit);
 	if (dev->d_kind.biosdisk.slice > 0)
 	    cp += sprintf(cp, "s%d", dev->d_kind.biosdisk.slice);
 	if (dev->d_kind.biosdisk.partition >= 0)
@@ -219,7 +216,7 @@
 	break;
 
     case DEVT_NET:
-	sprintf(buf, "%s%d:", dev->d_dev->dv_name, dev->d_kind.netif.unit);
+	sprintf(buf, "%s%d:", dev->d_dev->dv_name, dev->d_unit);
 	break;
     }
     return(buf);
Index: i386/libi386/elf32_freebsd.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/elf32_freebsd.c,v
retrieving revision 1.14
diff -u -r1.14 elf32_freebsd.c
--- i386/libi386/elf32_freebsd.c	29 Aug 2004 00:48:41 -0000	1.14
+++ i386/libi386/elf32_freebsd.c	2 Nov 2006 17:28:38 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/elf32_freebsd.c,v 1.14 2004/08/29 00:48:41 iedowse Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/elf32_freebsd.c,v 1.17 2006/11/02 17:28:38 ru Exp $");
 
 #include <sys/param.h>
 #include <sys/exec.h>
@@ -46,7 +46,7 @@
 struct file_format i386_elf_obj = { elf32_obj_loadfile, elf32_obj_exec };
 
 /*
- * There is an a.out kernel and one or more a.out modules loaded.  
+ * There is an ELF kernel and one or more ELF modules loaded.  
  * We wish to start executing the kernel image, so make such 
  * preparations as are required, and do so.
  */
Index: i386/libi386/elf64_freebsd.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/elf64_freebsd.c,v
retrieving revision 1.15
diff -u -r1.15 elf64_freebsd.c
--- i386/libi386/elf64_freebsd.c	29 Aug 2004 00:48:41 -0000	1.15
+++ i386/libi386/elf64_freebsd.c	26 Oct 2006 20:04:22 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/elf64_freebsd.c,v 1.15 2004/08/29 00:48:41 iedowse Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/elf64_freebsd.c,v 1.17 2006/10/26 20:04:22 ru Exp $");
 
 #define __ELF_WORD_SIZE 64
 #include <sys/param.h>
@@ -61,10 +61,10 @@
 u_int32_t entry_hi;
 u_int32_t entry_lo;
 
-extern amd64_tramp();
+extern void amd64_tramp();
 
 /*
- * There is an a.out kernel and one or more a.out modules loaded.  
+ * There is an ELF kernel and one or more ELF modules loaded.  
  * We wish to start executing the kernel image, so make such 
  * preparations as are required, and do so.
  */
Index: i386/libi386/i386_copy.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/i386_copy.c,v
retrieving revision 1.10.10.1
diff -u -r1.10.10.1 i386_copy.c
--- i386/libi386/i386_copy.c	1 Oct 2006 12:07:07 -0000	1.10.10.1
+++ i386/libi386/i386_copy.c	21 Dec 2005 02:17:58 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/i386_copy.c,v 1.10.10.1 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/i386_copy.c,v 1.12 2005/12/21 02:17:58 sobomax Exp $");
 
 /*
  * MD primitives supporting placement of module data 
Index: i386/libi386/libi386.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/libi386.h,v
retrieving revision 1.20.2.3
diff -u -r1.20.2.3 libi386.h
--- i386/libi386/libi386.h	1 Oct 2006 12:07:07 -0000	1.20.2.3
+++ i386/libi386/libi386.h	2 Nov 2006 01:23:17 -0000
@@ -23,7 +23,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/i386/libi386/libi386.h,v 1.20.2.3 2006/10/01 12:07:07 ru Exp $
+ * $FreeBSD: src/sys/boot/i386/libi386/libi386.h,v 1.27 2006/11/02 01:23:17 marcel Exp $
  */
 
 
@@ -36,24 +36,19 @@
 {
     struct devsw	*d_dev;
     int			d_type;
+    int			d_unit;
     union 
     {
 	struct 
 	{
-	    int		unit;
+	    void	*data;
 	    int		slice;
 	    int		partition;
-	    void	*data;
 	} biosdisk;
 	struct
 	{
-	    int		unit;
 	    void	*data;
 	} bioscd;
-	struct 
-	{
-	    int		unit;		/* XXX net layer lives over these? */
-	} netif;
     } d_kind;
 };
 
@@ -96,8 +91,8 @@
 					/*  when heap is at the top of extended memory */
 					/*  for other cases - just the same as memtop */
 
-int biospci_find_devclass(uint32_t class, int index);
-int biospci_write_config(uint32_t locator, int offset, int width, int val);
+int biospci_find_devclass(uint32_t class, int index, uint32_t *locator);
+int biospci_write_config(uint32_t locator, int offset, int width, uint32_t val);
 int biospci_read_config(uint32_t locator, int offset, int width, uint32_t *val);
 
 void	biosacpi_detect(void);
Index: i386/libi386/smbios.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/libi386/smbios.c,v
retrieving revision 1.6.2.1
diff -u -r1.6.2.1 smbios.c
--- i386/libi386/smbios.c	22 May 2006 23:31:30 -0000	1.6.2.1
+++ i386/libi386/smbios.c	21 May 2007 18:48:18 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/smbios.c,v 1.6.2.1 2006/05/22 23:31:30 jkim Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/libi386/smbios.c,v 1.7 2007/05/21 18:48:18 jkim Exp $");
 
 #include <stand.h>
 #include <bootstrap.h>
@@ -239,9 +239,9 @@
 			break;
 	}
 	if (f != 16 && z != 16) {
-		sprintf(uuid, "%02X%02X%02X%02X-"
-		    "%02X%02X-%02X%02X-%02X%02X-"
-		    "%02X%02X%02X%02X%02X%02X",
+		sprintf(uuid, "%02x%02x%02x%02x-"
+		    "%02x%02x-%02x%02x-%02x%02x-"
+		    "%02x%02x%02x%02x%02x%02x",
 		    idp[0], idp[1], idp[2], idp[3],
 		    idp[4], idp[5], idp[6], idp[7], idp[8], idp[9],
 		    idp[10], idp[11], idp[12], idp[13], idp[14], idp[15]);
Index: i386/loader/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/loader/Makefile,v
retrieving revision 1.81.2.1
diff -u -r1.81.2.1 Makefile
--- i386/loader/Makefile	30 Oct 2005 14:37:02 -0000	1.81.2.1
+++ i386/loader/Makefile	2 Nov 2006 00:26:44 -0000
@@ -1,4 +1,6 @@
-# $FreeBSD: src/sys/boot/i386/loader/Makefile,v 1.81.2.1 2005/10/30 14:37:02 scottl Exp $
+# $FreeBSD: src/sys/boot/i386/loader/Makefile,v 1.84 2006/11/02 00:26:44 marcel Exp $
+
+.include <bsd.own.mk>
 
 PROG=		loader.sym
 INTERNALPROG=
@@ -14,11 +16,14 @@
 CFLAGS+=	-DLOADER_NFS_SUPPORT
 .endif
 
+# Include bcache code.
+HAVE_BCACHE=	yes
+
 # Enable PnP and ISA-PnP code.
 HAVE_PNP=	yes
 HAVE_ISABUS=	yes
 
-.if !defined(NO_FORTH)
+.if ${MK_FORTH} != "no"
 # Enable BootForth
 BOOT_FORTH=	yes
 CFLAGS+=	-DBOOT_FORTH -I${.CURDIR}/../../ficl -I${.CURDIR}/../../ficl/i386
Index: i386/loader/loader.rc
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/loader/loader.rc,v
retrieving revision 1.4.2.1
diff -u -r1.4.2.1 loader.rc
--- i386/loader/loader.rc	30 Oct 2005 14:37:02 -0000	1.4.2.1
+++ i386/loader/loader.rc	30 Oct 2005 05:41:42 -0000
@@ -1,5 +1,5 @@
 \ Loader.rc
-\ $FreeBSD: src/sys/boot/i386/loader/loader.rc,v 1.4.2.1 2005/10/30 14:37:02 scottl Exp $
+\ $FreeBSD: src/sys/boot/i386/loader/loader.rc,v 1.4 2005/10/30 05:41:42 scottl Exp $
 \
 \ Includes additional commands
 include /boot/loader.4th
Index: i386/loader/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/loader/main.c,v
retrieving revision 1.31.2.3
diff -u -r1.31.2.3 main.c
--- i386/loader/main.c	1 Oct 2006 12:07:07 -0000	1.31.2.3
+++ i386/loader/main.c	16 Nov 2006 13:32:30 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/i386/loader/main.c,v 1.31.2.3 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/i386/loader/main.c,v 1.39 2006/11/16 13:32:30 ru Exp $");
 
 /*
  * MD bootstrap main() and assorted miscellaneous
@@ -191,7 +191,7 @@
 extract_currdev(void)
 {
     struct i386_devdesc	new_currdev;
-    int			major, biosdev = -1;
+    int			biosdev = -1;
 
     /* Assume we are booting from a BIOS disk by default */
     new_currdev.d_dev = &biosdisk;
@@ -201,11 +201,11 @@
         if ((kargs->bootflags & KARGS_FLAGS_CD) != 0) {
 	    /* we are booting from a CD with cdboot */
 	    new_currdev.d_dev = &bioscd;
-	    new_currdev.d_kind.bioscd.unit = bc_bios2unit(initial_bootdev);
+	    new_currdev.d_unit = bc_bios2unit(initial_bootdev);
 	} else if ((kargs->bootflags & KARGS_FLAGS_PXE) != 0) {
 	    /* we are booting from pxeldr */
 	    new_currdev.d_dev = &pxedisk;
-	    new_currdev.d_kind.netif.unit = 0;
+	    new_currdev.d_unit = 0;
 	} else {
 	    /* we don't know what our boot device is */
 	    new_currdev.d_kind.biosdisk.slice = -1;
@@ -222,7 +222,6 @@
 					     B_CONTROLLER(initial_bootdev) - 1;
 	new_currdev.d_kind.biosdisk.partition = B_PARTITION(initial_bootdev);
 	biosdev = initial_bootinfo->bi_bios_dev;
-	major = B_TYPE(initial_bootdev);
 
 	/*
 	 * If we are booted by an old bootstrap, we have to guess at the BIOS
@@ -240,10 +239,10 @@
      * which one we booted off of, just use disk0: as a reasonable default.
      */
     if ((new_currdev.d_type == biosdisk.dv_type) &&
-	((new_currdev.d_kind.biosdisk.unit = bd_bios2unit(biosdev)) == -1)) {
+	((new_currdev.d_unit = bd_bios2unit(biosdev)) == -1)) {
 	printf("Can't work out which disk we are booting from.\n"
 	       "Guessed BIOS device 0x%x not found by probes, defaulting to disk0:\n", biosdev);
-	new_currdev.d_kind.biosdisk.unit = 0;
+	new_currdev.d_unit = 0;
     }
     env_setenv("currdev", EV_VOLATILE, i386_fmtdev(&new_currdev),
 	       i386_setcurrdev, env_nounset);
Index: i386/pxeldr/pxeboot.8
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/pxeldr/pxeboot.8,v
retrieving revision 1.7
diff -u -r1.7 pxeboot.8
--- i386/pxeldr/pxeboot.8	12 Dec 2002 17:25:59 -0000	1.7
+++ i386/pxeldr/pxeboot.8	7 Oct 2006 10:39:34 -0000
@@ -22,7 +22,7 @@
 .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 .\" SUCH DAMAGE.
 .\"
-.\" $FreeBSD: src/sys/boot/i386/pxeldr/pxeboot.8,v 1.7 2002/12/12 17:25:59 ru Exp $
+.\" $FreeBSD: src/sys/boot/i386/pxeldr/pxeboot.8,v 1.8 2006/10/07 10:39:34 pav Exp $
 .\"
 .\" Note: The date here should be updated whenever a non-trivial
 .\" change is made to the manual page.
@@ -103,7 +103,7 @@
 .Pp
 For further information on Intel's PXE specifications and Wired for
 Management (WfM) systems, see
-.Li http://developer.intel.com/ial/wfm/ .
+.Li http://www.intel.com/design/archives/wfm/ .
 .Sh SEE ALSO
 .Xr loader 8
 .Sh HISTORY
Index: i386/pxeldr/pxeldr.S
===================================================================
RCS file: /home/ncvs/src/sys/boot/i386/pxeldr/pxeldr.S,v
retrieving revision 1.13.8.2
diff -u -r1.13.8.2 pxeldr.S
--- i386/pxeldr/pxeldr.S	8 Sep 2006 15:33:26 -0000	1.13.8.2
+++ i386/pxeldr/pxeldr.S	5 Sep 2006 19:28:03 -0000
@@ -12,7 +12,7 @@
  * warranties of merchantability and fitness for a particular
  * purpose.
  *
- * $FreeBSD: src/sys/boot/i386/pxeldr/pxeldr.S,v 1.13.8.2 2006/09/08 15:33:26 ru Exp $
+ * $FreeBSD: src/sys/boot/i386/pxeldr/pxeldr.S,v 1.15 2006/09/05 19:28:03 ru Exp $
  */
 
 /*
Index: ia64/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/Makefile,v
retrieving revision 1.4
diff -u -r1.4 Makefile
--- ia64/Makefile	23 Nov 2004 06:03:03 -0000	1.4
+++ ia64/Makefile	5 Nov 2006 22:03:03 -0000
@@ -1,5 +1,5 @@
-# $FreeBSD: src/sys/boot/ia64/Makefile,v 1.4 2004/11/23 06:03:03 marcel Exp $
+# $FreeBSD: src/sys/boot/ia64/Makefile,v 1.5 2006/11/05 22:03:03 marcel Exp $
 
-SUBDIR=		efi ski
+SUBDIR= common efi ski
 
 .include <bsd.subdir.mk>
Index: ia64/efi/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/efi/Makefile,v
retrieving revision 1.26
diff -u -r1.26 Makefile
--- ia64/efi/Makefile	21 Dec 2004 12:32:14 -0000	1.26
+++ ia64/efi/Makefile	5 Nov 2006 22:03:03 -0000
@@ -1,46 +1,27 @@
-# $FreeBSD: src/sys/boot/ia64/efi/Makefile,v 1.26 2004/12/21 12:32:14 ru Exp $
+# $FreeBSD: src/sys/boot/ia64/efi/Makefile,v 1.28 2006/11/05 22:03:03 marcel Exp $
 
-PROG=		loader.sym
-INTERNALPROG=
-SRCS=		conf.c dev_net.c efimd.c main.c start.S vers.c
 NO_MAN=
 
-CFLAGS+=	-DLOADER
-CFLAGS+=	-I${.CURDIR}/../../efi/include
-CFLAGS+=	-I${.CURDIR}/../../efi/include/${MACHINE_ARCH}
-CFLAGS+=	-I${.CURDIR}/../../efi/libefi
-CFLAGS+=	-I${.CURDIR}/../../../../lib/libstand
+.include <bsd.own.mk>
 
-.if !defined(NO_FORTH)
-BOOT_FORTH=	yes
-CFLAGS+=	-DBOOT_FORTH
-CFLAGS+=	-I${.CURDIR}/../../ficl
-CFLAGS+=	-I${.CURDIR}/../../ficl/${MACHINE_ARCH}
-LIBFICL=	${.OBJDIR}/../../ficl/libficl.a
-.endif
+PROG=		loader.sym
+INTERNALPROG=
+SRCS=		conf.c efimd.c main.c pal.S start.S vers.c
 
-# Always add MI sources 
-.PATH: ${.CURDIR}/../../common
-.include "${.CURDIR}/../../common/Makefile.inc"
+.PATH: ${.CURDIR}/../../../${MACHINE_ARCH}/${MACHINE_ARCH}
 
+CFLAGS+=	-I${.CURDIR}/../common
 CFLAGS+=	-I${.CURDIR}/../../common
-
-.PATH: ${.CURDIR}/../../forth
-FILES=		loader.efi loader.help loader.4th support.4th loader.conf
-FILESMODE_loader.efi= ${BINMODE}
-FILESDIR_loader.conf= /boot/defaults
-
-.if !exists(${DESTDIR}/boot/loader.rc)
-FILES+=		loader.rc
-.endif
+CFLAGS+=	-I${.CURDIR}/../../efi/include
+CFLAGS+=	-I${.CURDIR}/../../efi/include/${MACHINE_ARCH}
+CFLAGS+=	-I${.CURDIR}/../../..
+CFLAGS+=	-I${.CURDIR}/../../../../lib/libstand
 
 LDSCRIPT=	${.CURDIR}/ldscript.${MACHINE_ARCH}
 LDFLAGS=	-Wl,-T${LDSCRIPT} -shared -symbolic
 
 ${PROG}: ${LDSCRIPT}
 
-CLEANFILES=	vers.c loader.efi loader.help
-
 NEWVERSWHAT=	"EFI boot" ${MACHINE_ARCH}
 
 vers.c: ${.CURDIR}/../../common/newvers.sh ${.CURDIR}/version
@@ -49,22 +30,29 @@
 OBJCOPY?=	objcopy
 OBJDUMP?=	objdump
 
+FILES=		loader.efi
+FILESMODE_loader.efi= ${BINMODE}
+
 loader.efi: loader.sym
 	if [ `${OBJDUMP} -t ${.ALLSRC} | fgrep '*UND*' | wc -l` != 0 ]; then \
 		${OBJDUMP} -t ${.ALLSRC} | fgrep '*UND*'; \
+		rm ${.ALLSRC}; \
 		exit 1; \
 	fi
 	${OBJCOPY} -j .data -j .dynamic -j .dynstr -j .dynsym -j .hash \
 	    -j .rela.dyn -j .reloc -j .sdata -j .text \
 	    --target=efi-app-${MACHINE_ARCH} ${.ALLSRC} ${.TARGET}
 
-loader.help:	help.common
-	cat ${.ALLSRC} | awk -f ${.CURDIR}/../../common/merge_help.awk \
-	    > ${.TARGET}
+CLEANFILES=	vers.c loader.efi
 
+LIBIA64=	${.OBJDIR}/../common/libia64.a
 LIBEFI=		${.OBJDIR}/../../efi/libefi/libefi.a
+.if ${MK_FORTH} != "no"
+LIBFICL=        ${.OBJDIR}/../../ficl/libficl.a
+.endif
 
-DPADD=		${LIBFICL} ${LIBEFI} ${LIBSTAND}
-LDADD=		${LIBFICL} ${LIBEFI} -lstand
+DPADD=		${LIBIA64} ${LIBFICL} ${LIBEFI} ${LIBSTAND}
+LDADD=		-Wl,--whole-archive ${LIBIA64} -Wl,--no-whole-archive \
+		    ${LIBFICL} ${LIBEFI} -lstand
 
 .include <bsd.prog.mk>
Index: ia64/efi/conf.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/efi/conf.c,v
retrieving revision 1.11
diff -u -r1.11 conf.c
--- ia64/efi/conf.c	5 Jan 2005 22:16:57 -0000	1.11
+++ ia64/efi/conf.c	5 Nov 2006 22:03:04 -0000
@@ -32,14 +32,12 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/efi/conf.c,v 1.11 2005/01/05 22:16:57 imp Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/efi/conf.c,v 1.12 2006/11/05 22:03:04 marcel Exp $");
 
 #include <stand.h>
 #include <efi.h>
 #include <efilib.h>
 
-#include "efiboot.h"
-
 /*
  * We could use linker sets for some or all of these, but
  * then we would have to control what ended up linked into
@@ -52,24 +50,23 @@
 /* Exported for libstand */
 struct devsw *devsw[] = {
 	&efifs_dev,
-	&netdev,
+	&efinet_dev,
 	NULL
 };
 
 struct fs_ops *file_system[] = {
-	&efi_fsops,
-/*	&ufs_fsops, */
+	&efifs_fsops,
 	&nfs_fsops,
+	&ufs_fsops,
 	&gzipfs_fsops,
 	NULL
 };
 
 struct netif_driver *netif_drivers[] = {
-	&efi_net,
-	NULL,
+	&efinetif,
+	NULL
 };
 
-/* Exported for ia64 only */
 /* 
  * Sort formats so that those that can detect based on arguments
  * rather than reading the file go first.
Index: ia64/efi/efimd.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/efi/efimd.c,v
retrieving revision 1.2
diff -u -r1.2 efimd.c
--- ia64/efi/efimd.c	5 Jan 2005 22:16:57 -0000	1.2
+++ ia64/efi/efimd.c	5 Nov 2006 22:03:04 -0000
@@ -1,5 +1,5 @@
 /*-
- * Copyright (c) 2004 Marcel Moolenaar
+ * Copyright (c) 2004, 2006 Marcel Moolenaar
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -25,16 +25,114 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/efi/efimd.c,v 1.2 2005/01/05 22:16:57 imp Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/efi/efimd.c,v 1.3 2006/11/05 22:03:04 marcel Exp $");
+
+#include <stand.h>
 
 #include <efi.h>
 #include <efilib.h>
 
-#include <machine/vmparam.h>
+#include <libia64.h>
+
+#define EFI_INTEL_FPSWA		\
+    {0xc41b6531,0x97b9,0x11d3,{0x9a,0x29,0x00,0x90,0x27,0x3f,0xc1,0x4d}}
+
+static EFI_GUID fpswa_guid = EFI_INTEL_FPSWA;
+
+/* DIG64 Headless Console & Debug Port Table. */
+#define	HCDP_TABLE_GUID		\
+    {0xf951938d,0x620b,0x42ef,{0x82,0x79,0xa8,0x4b,0x79,0x61,0x78,0x98}}
+
+static EFI_GUID hcdp_guid = HCDP_TABLE_GUID;
+
+static UINTN mapkey;
+
+uint64_t
+ldr_alloc(vm_offset_t va)
+{
+
+	return (0);
+}
+
+int
+ldr_bootinfo(struct bootinfo *bi, uint64_t *bi_addr)
+{
+	VOID *fpswa;
+	EFI_MEMORY_DESCRIPTOR *mm;
+	EFI_PHYSICAL_ADDRESS addr;
+	EFI_HANDLE handle;
+	EFI_STATUS status;
+	size_t bisz;
+	UINTN mmsz, pages, sz;
+	UINT32 mmver;
+
+	bi->bi_systab = (uint64_t)ST;
+	bi->bi_hcdp = (uint64_t)efi_get_table(&hcdp_guid);
+
+	sz = sizeof(EFI_HANDLE);
+	status = BS->LocateHandle(ByProtocol, &fpswa_guid, 0, &sz, &handle);
+	if (status == 0)
+		status = BS->HandleProtocol(handle, &fpswa_guid, &fpswa);
+	bi->bi_fpswa = (status == 0) ? (uint64_t)fpswa : 0;
+
+	bisz = (sizeof(struct bootinfo) + 0x0f) & ~0x0f;
 
-EFI_PHYSICAL_ADDRESS
-efimd_va2pa(EFI_VIRTUAL_ADDRESS va)
+	/*
+	 * Allocate enough pages to hold the bootinfo block and the memory
+	 * map EFI will return to us. The memory map has an unknown size,
+	 * so we have to determine that first. Note that the AllocatePages
+	 * call can itself modify the memory map, so we have to take that
+	 * into account as well. The changes to the memory map are caused
+	 * by splitting a range of free memory into two (AFAICT), so that
+	 * one is marked as being loader data.
+	 */
+	sz = 0;
+	BS->GetMemoryMap(&sz, NULL, &mapkey, &mmsz, &mmver);
+	sz += mmsz;
+	sz = (sz + 15) & ~15;
+	pages = EFI_SIZE_TO_PAGES(sz + bisz);
+	status = BS->AllocatePages(AllocateAnyPages, EfiLoaderData, pages,
+	    &addr);
+	if (EFI_ERROR(status)) {
+		printf("%s: AllocatePages() returned 0x%lx\n", __func__,
+		    (long)status);
+		return (ENOMEM);
+	}
+
+	/*
+	 * Read the memory map and stash it after bootinfo. Align the
+	 * memory map on a 16-byte boundary (the bootinfo block is page
+	 * aligned).
+	 */
+	*bi_addr = addr;
+	mm = (void *)(addr + bisz);
+	sz = (EFI_PAGE_SIZE * pages) - bisz;
+	status = BS->GetMemoryMap(&sz, mm, &mapkey, &mmsz, &mmver);
+	if (EFI_ERROR(status)) {
+		printf("%s: GetMemoryMap() returned 0x%lx\n", __func__,
+		    (long)status);
+		return (EINVAL);
+	}
+	bi->bi_memmap = (uint64_t)mm;
+	bi->bi_memmap_size = sz;
+	bi->bi_memdesc_size = mmsz;
+	bi->bi_memdesc_version = mmver;
+
+	bcopy(bi, (void *)(*bi_addr), sizeof(*bi));
+	return (0);
+}
+
+int
+ldr_enter(const char *kernel)
 {
+	EFI_STATUS status;
+
+	status = BS->ExitBootServices(IH, mapkey);
+	if (EFI_ERROR(status)) {
+		printf("%s: ExitBootServices() returned 0x%lx\n", __func__,
+		    (long)status);
+		return (EINVAL);
+	}
 
-	return (IA64_RR_MASK(va));
+	return (0);
 }
Index: ia64/efi/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/efi/main.c,v
retrieving revision 1.24
diff -u -r1.24 main.c
--- ia64/efi/main.c	23 Nov 2004 05:37:47 -0000	1.24
+++ ia64/efi/main.c	5 Nov 2006 22:03:04 -0000
@@ -26,7 +26,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/efi/main.c,v 1.24 2004/11/23 05:37:47 marcel Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/efi/main.c,v 1.27 2006/11/05 22:03:04 marcel Exp $");
 
 #include <stand.h>
 #include <string.h>
@@ -39,16 +39,19 @@
 #include <efi.h>
 #include <efilib.h>
 
-#include "bootstrap.h"
-#include "efiboot.h"
+#include <libia64.h>
 
+/* DIG64 Headless Console & Debug Port Table. */
+#define	HCDP_TABLE_GUID		\
+    {0xf951938d,0x620b,0x42ef,{0x82,0x79,0xa8,0x4b,0x79,0x61,0x78,0x98}}
+ 
 extern char bootprog_name[];
 extern char bootprog_rev[];
 extern char bootprog_date[];
 extern char bootprog_maker[];
 
-struct efi_devdesc	currdev;	/* our current device */
-struct arch_switch	archsw;		/* MI/MD interface boundary */
+struct devdesc currdev;		/* our current device */
+struct arch_switch archsw;	/* MI/MD interface boundary */
 
 extern u_int64_t	ia64_pal_entry;
 
@@ -112,11 +115,6 @@
 	 */
 	cons_probe();
 
-	/*
-	 * Initialise the block cache
-	 */
-	bcache_init(32, 512);		/* 16k XXX tune this */
-
 	find_pal_proc();
 
 	/*
@@ -126,8 +124,6 @@
 		if (devsw[i]->dv_init != NULL)
 			(devsw[i]->dv_init)();
 
-	efinet_init_driver();
-
 	/* Get our loaded image protocol interface structure. */
 	BS->HandleProtocol(IH, &imgid, (VOID**)&img);
 
@@ -137,17 +133,7 @@
 	printf("%s, Revision %s\n", bootprog_name, bootprog_rev);
 	printf("(%s, %s)\n", bootprog_maker, bootprog_date);
 
-	i = efifs_get_unit(img->DeviceHandle);
-	if (i >= 0) {
-		currdev.d_dev = devsw[0];		/* XXX disk */
-		currdev.d_kind.efidisk.unit = i;
-		/* XXX should be able to detect this, default to autoprobe */
-		currdev.d_kind.efidisk.slice = -1;
-		currdev.d_kind.efidisk.partition = 0;
-	} else {
-		currdev.d_dev = devsw[1];		/* XXX net */
-		currdev.d_kind.netif.unit = 0;		/* XXX */
-	}
+	efi_handle_lookup(img->DeviceHandle, &currdev.d_dev, &currdev.d_unit);
 	currdev.d_type = currdev.d_dev->dv_type;
 
 	/*
@@ -161,18 +147,18 @@
 	 */
 	BS->SetWatchdogTimer(0, 0, 0, NULL);
 
-	env_setenv("currdev", EV_VOLATILE, efi_fmtdev(&currdev),
-	    efi_setcurrdev, env_nounset);
-	env_setenv("loaddev", EV_VOLATILE, efi_fmtdev(&currdev), env_noset,
+	env_setenv("currdev", EV_VOLATILE, ia64_fmtdev(&currdev),
+	    ia64_setcurrdev, env_nounset);
+	env_setenv("loaddev", EV_VOLATILE, ia64_fmtdev(&currdev), env_noset,
 	    env_nounset);
 
 	setenv("LINES", "24", 1);	/* optional */
     
-	archsw.arch_autoload = efi_autoload;
-	archsw.arch_getdev = efi_getdev;
-	archsw.arch_copyin = efi_copyin;
-	archsw.arch_copyout = efi_copyout;
-	archsw.arch_readin = efi_readin;
+	archsw.arch_autoload = ia64_autoload;
+	archsw.arch_getdev = ia64_getdev;
+	archsw.arch_copyin = ia64_copyin;
+	archsw.arch_copyout = ia64_copyout;
+	archsw.arch_readin = ia64_readin;
 
 	interact();			/* doesn't return */
 
Index: ia64/efi/start.S
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/efi/start.S,v
retrieving revision 1.8.2.1
diff -u -r1.8.2.1 start.S
--- ia64/efi/start.S	28 Jan 2006 18:40:55 -0000	1.8.2.1
+++ ia64/efi/start.S	18 Jan 2006 18:49:25 -0000
@@ -23,7 +23,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *	$FreeBSD: src/sys/boot/ia64/efi/start.S,v 1.8.2.1 2006/01/28 18:40:55 marcel Exp $
+ *	$FreeBSD: src/sys/boot/ia64/efi/start.S,v 1.10 2006/01/18 18:49:25 marcel Exp $
  */
 
 	.text
Index: ia64/efi/version
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/efi/version,v
retrieving revision 1.6
diff -u -r1.6 version
--- ia64/efi/version	23 Nov 2004 05:37:47 -0000	1.6
+++ ia64/efi/version	5 Nov 2006 22:03:04 -0000
@@ -1,8 +1,9 @@
-$FreeBSD: src/sys/boot/ia64/efi/version,v 1.6 2004/11/23 05:37:47 marcel Exp $
+$FreeBSD: src/sys/boot/ia64/efi/version,v 1.7 2006/11/05 22:03:04 marcel Exp $
 
 NOTE ANY CHANGES YOU MAKE TO THE BOOTBLOCKS HERE.  The format of this
 file is important.  Make sure the current version number is on line 6.
 
+1.2:	Restructured. Has some user visible differences.
 1.1:	Pass the HCDP table address to the kernel via bootinfo if one
 	is present in the EFI system table.
 1.0:	Don't map the I/O port range. We expect the kernel to do it. It
Index: ia64/ski/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/Makefile,v
retrieving revision 1.18
diff -u -r1.18 Makefile
--- ia64/ski/Makefile	21 Dec 2004 12:32:14 -0000	1.18
+++ ia64/ski/Makefile	5 Nov 2006 22:03:04 -0000
@@ -1,46 +1,38 @@
-# $FreeBSD: src/sys/boot/ia64/ski/Makefile,v 1.18 2004/12/21 12:32:14 ru Exp $
+# $FreeBSD: src/sys/boot/ia64/ski/Makefile,v 1.20 2006/11/05 22:03:04 marcel Exp $
 
-PROG=		skiload
 NO_MAN=
-NEWVERSWHAT=	"ia64 SKI boot" ${MACHINE_ARCH}
-STRIP=		# We must not strip skiload at install time.
 
-SRCS=		acpi_stub.c bootinfo.c conf.c copy.c delay.c devicename.c \
-		efi_stub.c elf_freebsd.c exit.c main.c pal_stub.S sal_stub.c \
-		skiconsole.c skifs.c ssc.c start.S time.c vers.c
+.include <bsd.own.mk>
 
-CFLAGS+=	-DLOADER
-CFLAGS+=	-I${.CURDIR}
-CFLAGS+=	-I${.CURDIR}/../../..
-CFLAGS+=	-I${.CURDIR}/../../efi/include
-CFLAGS+=	-I${.CURDIR}/../../efi/include/${MACHINE_ARCH}
-LDFLAGS=	-Wl,-T${.CURDIR}/ldscript.ia64
-
-.if !defined(NO_FORTH)
-CFLAGS+=	-DBOOT_FORTH
-CFLAGS+=	-I${.CURDIR}/../../ficl
-CFLAGS+=	-I${.CURDIR}/../../ficl/${MACHINE_ARCH}
-LIBFICL=	${.OBJDIR}/../../ficl/libficl.a
-BOOT_FORTH=	yes
-.endif
+PROG=		skiload
+STRIP=		# We must not strip skiload at install time.
+
+SRCS=		acpi_stub.c conf.c delay.c efi_stub.c exit.c main.c \
+		pal_stub.S sal_stub.c skiconsole.c skifs.c skimd.c \
+		ssc.c start.S time.c vers.c
 
-# Always add MI sources (needs BOOT_FORTH)
-.PATH: ${.CURDIR}/../../common
+CFLAGS+=	-I${.CURDIR}/../common
 CFLAGS+=	-I${.CURDIR}/../../common
-.include "${.CURDIR}/../../common/Makefile.inc"
+CFLAGS+=	-I${.CURDIR}/../../..
+CFLAGS+=	-I${.CURDIR}/../../../../lib/libstand
 
-DPADD=	${LIBFICL} ${LIBSTAND}
-LDADD=	${LIBFICL} -lstand
+LDSCRIPT=	${.CURDIR}/ldscript.${MACHINE_ARCH}
+LDFLAGS=	-Wl,-T${LDSCRIPT}
 
-CLEANFILES=	vers.c ${PROG}.help
+NEWVERSWHAT=	"SKI boot" ${MACHINE_ARCH}
 
 vers.c: ${.CURDIR}/../../common/newvers.sh ${.CURDIR}/version
 	sh ${.CURDIR}/../../common/newvers.sh ${.CURDIR}/version ${NEWVERSWHAT}
 
-${PROG}.help: help.common
-	cat ${.ALLSRC} | awk -f ${.CURDIR}/../../common/merge_help.awk \
-	    > ${.TARGET}
+CLEANFILES=	vers.c
+
+LIBIA64=	${.OBJDIR}/../common/libia64.a
+.if ${MK_FORTH} != "no"
+LIBFICL=	${.OBJDIR}/../../ficl/libficl.a
+.endif
 
-FILES=	${PROG}.help
+DPADD=		${LIBIA64} ${LIBFICL} ${LIBSTAND}
+LDADD=		-Wl,--whole-archive ${LIBIA64} -Wl,--no-whole-archive \
+		    ${LIBFICL} -lstand
 
 .include <bsd.prog.mk>
Index: ia64/ski/acpi_stub.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/acpi_stub.c,v
retrieving revision 1.6
diff -u -r1.6 acpi_stub.c
--- ia64/ski/acpi_stub.c	5 Jan 2005 22:16:58 -0000	1.6
+++ ia64/ski/acpi_stub.c	22 Mar 2007 18:16:39 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/acpi_stub.c,v 1.6 2005/01/05 22:16:58 imp Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/acpi_stub.c,v 1.8 2007/03/22 18:16:39 jkim Exp $");
 
 #include <contrib/dev/acpica/acpi.h>
 
@@ -36,41 +36,41 @@
 
 typedef struct  /* LOCAL SAPIC */
 {
-        APIC_HEADER     Header;
-        UINT8           ProcessorId;            /* ACPI processor id */
-        UINT8           LocalSapicId;           /* Processor local SAPIC id */
-        UINT8           LocalSapicEid;          /* Processor local SAPIC eid */
-        UINT8           Reserved[3];
-        UINT32          ProcessorEnabled: 1;
-        UINT32          FlagsReserved: 31;
+	ACPI_SUBTABLE_HEADER Header;
+	UINT8		ProcessorId;		/* ACPI processor id */
+	UINT8		LocalSapicId;		/* Processor local SAPIC id */
+	UINT8		LocalSapicEid;		/* Processor local SAPIC eid */
+	UINT8		Reserved[3];
+	UINT32		ProcessorEnabled: 1;
+	UINT32		FlagsReserved: 31;
 } LOCAL_SAPIC;
 
 typedef struct  /* IO SAPIC */
 {
-        APIC_HEADER     Header;
-        UINT8           IoSapicId;              /* I/O SAPIC ID */
-        UINT8           Reserved;               /* reserved - must be zero */
-        UINT32          Vector;                 /* interrupt base */
-        UINT64          IoSapicAddress;         /* SAPIC's physical address */
+	ACPI_SUBTABLE_HEADER Header;
+	UINT8		IoSapicId;		/* I/O SAPIC ID */
+	UINT8		Reserved;		/* reserved - must be zero */
+	UINT32		Vector;			/* interrupt base */
+	UINT64		IoSapicAddress;		/* SAPIC's physical address */
 } IO_SAPIC;
 
 /*
  */
 
 struct {
-	MULTIPLE_APIC_TABLE	Header;
-	MADT_LOCAL_SAPIC	cpu0;
-	MADT_LOCAL_SAPIC	cpu1;
-	MADT_LOCAL_SAPIC	cpu2;
-	MADT_LOCAL_SAPIC	cpu3;
-	MADT_IO_SAPIC		sapic;
+	ACPI_TABLE_MADT		MADT;
+	ACPI_MADT_LOCAL_SAPIC	cpu0;
+	ACPI_MADT_LOCAL_SAPIC	cpu1;
+	ACPI_MADT_LOCAL_SAPIC	cpu2;
+	ACPI_MADT_LOCAL_SAPIC	cpu3;
+	ACPI_MADT_IO_SAPIC	sapic;
 } apic = {
 	/* Header. */
 	{
-		APIC_SIG,			/* Signature. */
+		ACPI_SIG_MADT,			/* Signature. */
 		sizeof(apic),			/* Length of table. */
 		0,				/* ACPI minor revision. */
-		0,				/* XXX checksum. */
+		0,				/* Checksum. */
 		"FBSD",				/* OEM Id. */
 		"SKI",				/* OEM table Id. */
 		0,				/* OEM revision. */
@@ -134,7 +134,7 @@
 	UINT64			apic_tbl;
 } xsdt = {
 	{
-		XSDT_SIG,		/* Signature. */
+		ACPI_SIG_XSDT,		/* Signature. */
 		sizeof(xsdt),		/* Length of table. */
 		0,			/* ACPI minor revision. */
 		0,			/* XXX checksum. */
@@ -147,8 +147,8 @@
 	0UL				/* XXX APIC table address. */
 };
 
-RSDP_DESCRIPTOR acpi_root = {
-	RSDP_SIG,
+ACPI_TABLE_RSDP acpi_root = {
+	ACPI_SIG_RSDP,
 	0,				/* XXX checksum. */
 	"FBSD",
 	2,				/* ACPI Rev 2.0. */
@@ -177,6 +177,7 @@
 	cksum(&acpi_root, 20, &acpi_root.Checksum);
 	cksum(&acpi_root, sizeof(acpi_root), &acpi_root.ExtendedChecksum);
 
+	cksum(&apic, sizeof(apic), &apic.MADT.Header.Checksum);
 	xsdt.apic_tbl = (UINT32)&apic;
 	cksum(&xsdt, sizeof(xsdt), &xsdt.Header.Checksum);
 }
Index: ia64/ski/conf.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/conf.c,v
retrieving revision 1.6
diff -u -r1.6 conf.c
--- ia64/ski/conf.c	5 Jan 2005 22:16:58 -0000	1.6
+++ ia64/ski/conf.c	12 May 2006 04:09:53 -0000
@@ -32,7 +32,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/conf.c,v 1.6 2005/01/05 22:16:58 imp Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/conf.c,v 1.7 2006/05/12 04:09:53 jhb Exp $");
 
 #include <stand.h>
 
@@ -75,7 +75,7 @@
 /* 
  * Consoles 
  *
- * We don't prototype these in libalpha.h because they require
+ * We don't prototype these in libski.h because they require
  * data structures from bootstrap.h as well.
  */
 extern struct console ski_console;
Index: ia64/ski/efi_stub.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/efi_stub.c,v
retrieving revision 1.5
diff -u -r1.5 efi_stub.c
--- ia64/ski/efi_stub.c	5 Jan 2005 22:16:58 -0000	1.5
+++ ia64/ski/efi_stub.c	5 Nov 2006 22:03:04 -0000
@@ -25,20 +25,17 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/efi_stub.c,v 1.5 2005/01/05 22:16:58 imp Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/efi_stub.c,v 1.6 2006/11/05 22:03:04 marcel Exp $");
 
 #include <sys/types.h>
-#include <machine/bootinfo.h>
 #include <machine/efi.h>
+#include <ia64/include/bootinfo.h>
 #include <stand.h>
 #include "libski.h"
 
 extern void acpi_root;
 extern void sal_systab;
 
-extern void acpi_stub_init(void);
-extern void sal_stub_init(void);
-
 struct efi_cfgtbl efi_cfgtab[] = {
 	{ EFI_TABLE_ACPI20,	(intptr_t)&acpi_root },
 	{ EFI_TABLE_SAL,	(intptr_t)&sal_systab }
@@ -223,8 +220,8 @@
 	return (unsupported(__func__));
 }
 
-int
-ski_init_stubs(struct bootinfo *bi)
+void
+efi_stub_init(struct bootinfo *bi)
 {
 	struct efi_md *memp;
 
@@ -261,9 +258,4 @@
 	memp[3].md_attr = EFI_MD_ATTR_UC;
 
 	bi->bi_systab = (u_int64_t)&efi_systab;
-
-	sal_stub_init();
-	acpi_stub_init();
-
-	return (0);
 }
Index: ia64/ski/libski.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/libski.h,v
retrieving revision 1.6
diff -u -r1.6 libski.h
--- ia64/ski/libski.h	24 Sep 2004 04:06:22 -0000	1.6
+++ ia64/ski/libski.h	5 Nov 2006 22:03:04 -0000
@@ -23,34 +23,9 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/ia64/ski/libski.h,v 1.6 2004/09/24 04:06:22 marcel Exp $
+ * $FreeBSD: src/sys/boot/ia64/ski/libski.h,v 1.8 2006/11/05 22:03:04 marcel Exp $
  */
 
-/*
- * SKI fully-qualified device descriptor
- */
-struct ski_devdesc {
-	struct	devsw	*d_dev;
-	int		d_type;
-#define	DEVT_NONE	0
-#define	DEVT_DISK	1
-#define	DEVT_NET	2
-	union {
-		struct {
-			int	unit;
-			int	slice;
-			int	partition;
-		} skidisk;
-		struct {
-			int	unit;	/* XXX net layer lives over these? */
-		} netif;
-	} d_kind;
-};
-
-extern int	ski_getdev(void **vdev, const char *devspec, const char **path);
-extern char	*ski_fmtdev(void *vdev);
-extern int	ski_setcurrdev(struct env_var *ev, int flags, void *value);
-
 #define	MAXDEV	31	/* maximum number of distinct devices */
 
 typedef unsigned long physaddr_t;
@@ -67,10 +42,6 @@
 extern void		delay(int);
 extern void		reboot(void);
 
-extern ssize_t		ski_copyin(const void *src, vm_offset_t dest, size_t len);
-extern ssize_t		ski_copyout(const vm_offset_t src, void *dest, size_t len);
-extern ssize_t		ski_readin(int fd, vm_offset_t dest, size_t len);
-
 extern int		ski_boot(void);
 
 struct bootinfo;
Index: ia64/ski/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/main.c,v
retrieving revision 1.6
diff -u -r1.6 main.c
--- ia64/ski/main.c	24 Sep 2004 04:06:22 -0000	1.6
+++ ia64/ski/main.c	5 Nov 2006 22:03:04 -0000
@@ -26,14 +26,14 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/main.c,v 1.6 2004/09/24 04:06:22 marcel Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/main.c,v 1.9 2006/11/05 22:03:04 marcel Exp $");
 
 #include <stand.h>
 #include <string.h>
 #include <setjmp.h>
 #include <machine/fpu.h>
 
-#include "bootstrap.h"
+#include <libia64.h>
 #include "libski.h"
 
 extern char bootprog_name[];
@@ -41,15 +41,8 @@
 extern char bootprog_date[];
 extern char bootprog_maker[];
 
-struct ski_devdesc	currdev;	/* our current device */
-struct arch_switch	archsw;		/* MI/MD interface boundary */
-
-static int
-ski_autoload(void)
-{
-
-	return (0);
-}
+struct devdesc currdev;		/* our current device */
+struct arch_switch archsw;	/* MI/MD interface boundary */
 
 void
 ski_main(void)
@@ -73,11 +66,6 @@
 	cons_probe();
 
 	/*
-	 * Initialise the block cache
-	 */
-	bcache_init(32, 512);		/* 16k XXX tune this */
-
-	/*
 	 * March through the device switch probing for things.
 	 */
 	for (i = 0; devsw[i] != NULL; i++)
@@ -90,15 +78,11 @@
 #if 0
 	printf("Memory: %ld k\n", memsize() / 1024);
 #endif
-    
+
 	/* XXX presumes that biosdisk is first in devsw */
 	currdev.d_dev = devsw[0];
 	currdev.d_type = currdev.d_dev->dv_type;
-	currdev.d_kind.skidisk.unit = 0;
-	/* XXX should be able to detect this, default to autoprobe */
-	currdev.d_kind.skidisk.slice = -1;
-	/* default to 'a' */
-	currdev.d_kind.skidisk.partition = 0;
+	currdev.d_unit = 0;
 
 #if 0
 	/* Create arc-specific variables */
@@ -107,18 +91,18 @@
 		setenv("bootfile", bootfile, 1);
 #endif
 
-	env_setenv("currdev", EV_VOLATILE, ski_fmtdev(&currdev),
-	    ski_setcurrdev, env_nounset);
-	env_setenv("loaddev", EV_VOLATILE, ski_fmtdev(&currdev), env_noset,
+	env_setenv("currdev", EV_VOLATILE, ia64_fmtdev(&currdev),
+	    ia64_setcurrdev, env_nounset);
+	env_setenv("loaddev", EV_VOLATILE, ia64_fmtdev(&currdev), env_noset,
 	    env_nounset);
 
 	setenv("LINES", "24", 1);	/* optional */
     
-	archsw.arch_autoload = ski_autoload;
-	archsw.arch_getdev = ski_getdev;
-	archsw.arch_copyin = ski_copyin;
-	archsw.arch_copyout = ski_copyout;
-	archsw.arch_readin = ski_readin;
+	archsw.arch_autoload = ia64_autoload;
+	archsw.arch_getdev = ia64_getdev;
+	archsw.arch_copyin = ia64_copyin;
+	archsw.arch_copyout = ia64_copyout;
+	archsw.arch_readin = ia64_readin;
 
 	interact();			/* doesn't return */
 
Index: ia64/ski/skifs.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/skifs.c,v
retrieving revision 1.3
diff -u -r1.3 skifs.c
--- ia64/ski/skifs.c	24 Sep 2004 03:53:50 -0000	1.3
+++ ia64/ski/skifs.c	5 Nov 2006 22:03:04 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/skifs.c,v 1.3 2004/09/24 03:53:50 marcel Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ia64/ski/skifs.c,v 1.4 2006/11/05 22:03:04 marcel Exp $");
 
 #include <sys/param.h>
 #include <sys/time.h>
@@ -33,6 +33,7 @@
 #include <stand.h>
 #include <stdarg.h>
 
+#include <bootstrap.h>
 #include "libski.h"
 
 struct disk_req {
Index: ia64/ski/version
===================================================================
RCS file: /home/ncvs/src/sys/boot/ia64/ski/version,v
retrieving revision 1.3
diff -u -r1.3 version
--- ia64/ski/version	24 Sep 2004 03:51:06 -0000	1.3
+++ ia64/ski/version	5 Nov 2006 22:03:04 -0000
@@ -1,8 +1,11 @@
-$FreeBSD: src/sys/boot/ia64/ski/version,v 1.3 2004/09/24 03:51:06 marcel Exp $
+$FreeBSD: src/sys/boot/ia64/ski/version,v 1.4 2006/11/05 22:03:04 marcel Exp $
 
 NOTE ANY CHANGES YOU MAKE TO THE BOOTBLOCKS HERE.  The format of this
 file is important.  Make sure the current version number is on line 6.
 
+1.2:    Restructured. Has some user visible differences. Due to code
+	sharing, has been given the same version number as the EFI
+	loader.
 0.2:	Pass the address of the bootinfo block to the kernel in register
 	r8. Keep it at the hardwired address for now.
 0.1:	Initial SKI version.
Index: ofw/common/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/common/main.c,v
retrieving revision 1.7
diff -u -r1.7 main.c
--- ofw/common/main.c	16 Aug 2004 15:45:24 -0000	1.7
+++ ofw/common/main.c	2 Nov 2006 00:26:45 -0000
@@ -26,7 +26,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/common/main.c,v 1.7 2004/08/16 15:45:24 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/common/main.c,v 1.8 2006/11/02 00:26:45 marcel Exp $");
 
 #include <stand.h>
 #include "openfirm.h"
@@ -125,11 +125,6 @@
 	init_heap();
 
 	/*
-	 * Initialise the block cache
-	 */
-	bcache_init(32, 512);		/* 16k XXX tune this */
-
-	/*
 	 * March through the device switch probing for things.
 	 */
 	for (i = 0; devsw[i] != NULL; i++)
Index: ofw/libofw/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/Makefile,v
retrieving revision 1.9
diff -u -r1.9 Makefile
--- ofw/libofw/Makefile	24 Oct 2004 15:32:50 -0000	1.9
+++ ofw/libofw/Makefile	9 Oct 2006 04:43:06 -0000
@@ -1,11 +1,11 @@
-# $FreeBSD: src/sys/boot/ofw/libofw/Makefile,v 1.9 2004/10/24 15:32:50 ru Exp $
+# $FreeBSD: src/sys/boot/ofw/libofw/Makefile,v 1.10 2006/10/09 04:43:06 kmacy Exp $
 
 LIB=		ofw
 INTERNALLIB=
 
 SRCS=	devicename.c elf_freebsd.c ofw_console.c ofw_copy.c ofw_disk.c \
 	ofw_memory.c ofw_module.c ofw_net.c ofw_reboot.c \
-	ofw_time.c openfirm.c
+	ofw_time.c openfirm.c openfirm_mmu.c
 
 CFLAGS+=	-I${.CURDIR}/../../../../lib/libstand/
 
Index: ofw/libofw/devicename.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/devicename.c,v
retrieving revision 1.15.8.1
diff -u -r1.15.8.1 devicename.c
--- ofw/libofw/devicename.c	30 Nov 2005 13:24:53 -0000	1.15.8.1
+++ ofw/libofw/devicename.c	25 Oct 2005 12:49:56 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/devicename.c,v 1.15.8.1 2005/11/30 13:24:53 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/devicename.c,v 1.16 2005/10/25 12:49:56 marius Exp $");
 
 #include <stand.h>
 #include "libofw.h"
Index: ofw/libofw/elf_freebsd.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/elf_freebsd.c,v
retrieving revision 1.9.2.1
diff -u -r1.9.2.1 elf_freebsd.c
--- ofw/libofw/elf_freebsd.c	30 Nov 2005 13:13:53 -0000	1.9.2.1
+++ ofw/libofw/elf_freebsd.c	20 Oct 2005 10:39:09 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/elf_freebsd.c,v 1.9.2.1 2005/11/30 13:13:53 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/elf_freebsd.c,v 1.10 2005/10/20 10:39:09 marius Exp $");
 
 #include <sys/param.h>
 #include <sys/linker.h>
Index: ofw/libofw/libofw.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/libofw.h,v
retrieving revision 1.10.2.1
diff -u -r1.10.2.1 libofw.h
--- ofw/libofw/libofw.h	30 Nov 2005 13:19:03 -0000	1.10.2.1
+++ ofw/libofw/libofw.h	2 Nov 2006 01:23:18 -0000
@@ -22,7 +22,7 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * $FreeBSD: src/sys/boot/ofw/libofw/libofw.h,v 1.10.2.1 2005/11/30 13:19:03 marius Exp $
+ * $FreeBSD: src/sys/boot/ofw/libofw/libofw.h,v 1.12 2006/11/02 01:23:18 marcel Exp $
  */
 
 #include "openfirm.h"
@@ -31,6 +31,7 @@
 struct ofw_devdesc {
 	struct devsw	*d_dev;
 	int		d_type;
+	int		d_unit;
 	ihandle_t	d_handle;
 	char		d_path[256];
 };
Index: ofw/libofw/ofw_console.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/ofw_console.c,v
retrieving revision 1.10.2.1
diff -u -r1.10.2.1 ofw_console.c
--- ofw/libofw/ofw_console.c	30 Nov 2005 13:13:53 -0000	1.10.2.1
+++ ofw/libofw/ofw_console.c	20 Oct 2005 10:39:09 -0000
@@ -27,7 +27,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_console.c,v 1.10.2.1 2005/11/30 13:13:53 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_console.c,v 1.11 2005/10/20 10:39:09 marius Exp $");
 
 #include <sys/types.h>
 
Index: ofw/libofw/ofw_copy.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/ofw_copy.c,v
retrieving revision 1.15
diff -u -r1.15 ofw_copy.c
--- ofw/libofw/ofw_copy.c	19 May 2005 07:21:46 -0000	1.15
+++ ofw/libofw/ofw_copy.c	22 Jul 2005 23:22:29 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_copy.c,v 1.15 2005/05/19 07:21:46 grehan Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_copy.c,v 1.16 2005/07/22 23:22:29 grehan Exp $");
 
 /*
  * MD primitives supporting placement of module data 
@@ -39,6 +39,8 @@
 #define	READIN_BUF	(4 * 1024)
 #define	PAGE_SIZE	0x1000
 #define	PAGE_MASK	0x0fff
+#define MAPMEM_PAGE_INC 16
+
 
 #define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))
 
@@ -76,10 +78,10 @@
 
 	/*
 	 * To avoid repeated mappings on small allocations,
-	 * never map anything less than 16 pages at a time
+	 * never map anything less than MAPMEM_PAGE_INC pages at a time
 	 */
-	if ((nlen + resid) < PAGE_SIZE*8) {
-		dlen = PAGE_SIZE*8;
+	if ((nlen + resid) < PAGE_SIZE*MAPMEM_PAGE_INC) {
+		dlen = PAGE_SIZE*MAPMEM_PAGE_INC;
 	} else
 		dlen = roundup(nlen + resid, PAGE_SIZE);
 
Index: ofw/libofw/ofw_disk.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/ofw_disk.c,v
retrieving revision 1.12.2.1
diff -u -r1.12.2.1 ofw_disk.c
--- ofw/libofw/ofw_disk.c	30 Nov 2005 13:37:22 -0000	1.12.2.1
+++ ofw/libofw/ofw_disk.c	25 Oct 2005 12:51:49 -0000
@@ -24,7 +24,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_disk.c,v 1.12.2.1 2005/11/30 13:37:22 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_disk.c,v 1.13 2005/10/25 12:51:49 marius Exp $");
 
 /*
  * Disk I/O routines using Open Firmware
Index: ofw/libofw/ofw_memory.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/ofw_memory.c,v
retrieving revision 1.6.2.1
diff -u -r1.6.2.1 ofw_memory.c
--- ofw/libofw/ofw_memory.c	30 Nov 2005 13:13:53 -0000	1.6.2.1
+++ ofw/libofw/ofw_memory.c	20 Oct 2005 10:39:09 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_memory.c,v 1.6.2.1 2005/11/30 13:13:53 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/ofw_memory.c,v 1.7 2005/10/20 10:39:09 marius Exp $");
 
 #include <sys/param.h>
 #include <sys/types.h>
Index: ofw/libofw/openfirm.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/ofw/libofw/openfirm.c,v
retrieving revision 1.11.2.1
diff -u -r1.11.2.1 openfirm.c
--- ofw/libofw/openfirm.c	30 Nov 2005 13:13:53 -0000	1.11.2.1
+++ ofw/libofw/openfirm.c	9 Oct 2006 04:43:07 -0000
@@ -56,7 +56,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/openfirm.c,v 1.11.2.1 2005/11/30 13:13:53 marius Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/ofw/libofw/openfirm.c,v 1.13 2006/10/09 04:43:07 kmacy Exp $");
 
 #include <machine/stdarg.h>
 
@@ -87,6 +87,20 @@
 		panic("failed to get mmu ihandle");
 }
 
+phandle_t
+OF_chosennode(void)
+{
+        static phandle_t        chosen;
+
+        if (chosen)
+                return (chosen);
+
+        if ((chosen = OF_finddevice("/chosen")) == -1)
+                OF_exit();
+
+        return (chosen);
+}
+
 /*
  * Generic functions
  */
Index: pc98/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/Makefile,v
retrieving revision 1.8.14.1
diff -u -r1.8.14.1 Makefile
--- pc98/Makefile	16 Jun 2006 13:14:15 -0000	1.8.14.1
+++ pc98/Makefile	14 May 2006 07:26:01 -0000
@@ -1,4 +1,4 @@
-# $FreeBSD: src/sys/boot/pc98/Makefile,v 1.8.14.1 2006/06/16 13:14:15 nyan Exp $
+# $FreeBSD: src/sys/boot/pc98/Makefile,v 1.9 2006/05/14 07:26:01 nyan Exp $
 
 SUBDIR=		btx boot0 boot0.5 boot2 cdboot kgzldr libpc98 loader
 
Index: pc98/Makefile.inc
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/Makefile.inc,v
retrieving revision 1.5.8.1
diff -u -r1.5.8.1 Makefile.inc
--- pc98/Makefile.inc	6 Nov 2005 04:40:57 -0000	1.5.8.1
+++ pc98/Makefile.inc	13 Sep 2005 08:27:38 -0000
@@ -1,6 +1,6 @@
 # Common defines for all of /sys/boot/pc98/
 #
-# $FreeBSD: src/sys/boot/pc98/Makefile.inc,v 1.5.8.1 2005/11/06 04:40:57 nyan Exp $
+# $FreeBSD: src/sys/boot/pc98/Makefile.inc,v 1.6 2005/09/13 08:27:38 nyan Exp $
 
 BINDIR?=	/boot
 
Index: pc98/boot0.5/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot0.5/Makefile,v
retrieving revision 1.4
diff -u -r1.4 Makefile
--- pc98/boot0.5/Makefile	21 Dec 2004 08:47:16 -0000	1.4
+++ pc98/boot0.5/Makefile	7 Apr 2007 13:37:45 -0000
@@ -1,10 +1,11 @@
-# $FreeBSD: src/sys/boot/pc98/boot0.5/Makefile,v 1.4 2004/12/21 08:47:16 ru Exp $
+# $FreeBSD: src/sys/boot/pc98/boot0.5/Makefile,v 1.6 2007/04/07 13:37:45 nyan Exp $
 
 PROG=	${BOOT}.out
 INTERNALPROG=
 FILES=	${BOOT}
 NO_MAN=
-SRCS=	start.s boot.s boot0.5.s disk.s selector.s support.s syscons.s
+SRCS=	start.s boot.s boot0.5.s disk.s selector.s support.s syscons.s \
+	putssjis.s
 CLEANFILES= ${BOOT} ${BOOT}.bin
 
 BOOT=	boot0.5
@@ -13,7 +14,7 @@
 # unless you are glutton for punishment.
 BOOT_BOOT0_ORG?=	0x0000
 
-LDFLAGS=-N -e start -Ttext ${BOOT_BOOT0_ORG}
+LDFLAGS=-N -e start -Ttext ${BOOT_BOOT0_ORG} -Wl,-T,${.CURDIR}/ldscript
 
 # The size of boot0.5 must be 7168 bytes
 ${BOOT}: ${BOOT}.bin
Index: pc98/boot0.5/boot.s
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot0.5/boot.s,v
retrieving revision 1.2
diff -u -r1.2 boot.s
--- pc98/boot0.5/boot.s	3 Aug 2000 13:01:45 -0000	1.2
+++ pc98/boot0.5/boot.s	17 Mar 2007 05:30:03 -0000
@@ -25,7 +25,7 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
-# $FreeBSD: src/sys/boot/pc98/boot0.5/boot.s,v 1.2 2000/08/03 13:01:45 kato Exp $
+# $FreeBSD: src/sys/boot/pc98/boot0.5/boot.s,v 1.3 2007/03/17 05:30:03 kato Exp $
 #
 
 	.code16
@@ -60,7 +60,7 @@
 	movw	parttable(%si), %ax
 	movw	%ax, b_cylinder
 
-	# Step 2: Calculate egment address of bootstrap routine
+	# Step 2: Calculate the segment address of the bootstrap routine
 	movw	$0x1d00, %ax
 	movw	b_secsize, %cx
 	shrw	%cx
Index: pc98/boot0.5/boot0.5.s
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot0.5/boot0.5.s,v
retrieving revision 1.2
diff -u -r1.2 boot0.5.s
--- pc98/boot0.5/boot0.5.s	6 Aug 2000 14:35:37 -0000	1.2
+++ pc98/boot0.5/boot0.5.s	7 Apr 2007 08:37:04 -0000
@@ -1,4 +1,4 @@
-# Copyright (c) KATO Takenori, 1999, 2000.
+# Copyright (c) KATO Takenori, 1999, 2000, 2007.
 #
 # All rights reserved.  Unpublished rights reserved under the copyright
 # laws of Japan.
@@ -25,7 +25,7 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
-# $FreeBSD: src/sys/boot/pc98/boot0.5/boot0.5.s,v 1.2 2000/08/06 14:35:37 kato Exp $
+# $FreeBSD: src/sys/boot/pc98/boot0.5/boot0.5.s,v 1.4 2007/04/07 08:37:04 kato Exp $
 #
 	.global	main
 	.code16
@@ -60,7 +60,7 @@
 	jmp	exit			# No hard drives
 
 drives_found:
-	# Setup sector size depended parameters
+	# Setup sector size dependent parameters
 	movw	%si, %cx		# %cx = number of devices
 setup_loop:
 	movw	%cx, %di
@@ -254,22 +254,15 @@
 	ret
 
 	.data
-	.global	curdevice, daua, secsize, defflagoff, defpartoff
-	.global	maxpart, partoff, ndevice
+	.global	curdevice, ndevice
 ndevice:	.word	0		# number of device
 curdevice:	.word	0		# current device
-daua:		.space	12		# DA/DU list
-secsize:	.space	12 * 2		# Sector soize
-defflagoff:	.space	12 * 2
-defpartoff:	.space	12 * 2
-maxpart:	.space	12 * 2
-partoff:	.space	12 * 2
 
 	.global	ishireso
 ishireso:	.byte	0
 
-title:		.asciz	"PC98 Boot Selector Version 1.1"
-copyright:	.ascii	"(C)Copyright 1999, 2000 KATO Takenori. "
+title:		.asciz	"PC98 Boot Selector Version 1.2"
+copyright:	.ascii	"(C)Copyright 1999-2007 KATO Takenori. "
 		.asciz	"All rights reserved."
 msg_device:	.asciz	"Device"
 msg_sasi:	.asciz	"SASI/IDE unit "
@@ -288,3 +281,13 @@
 msg_usage10:	.asciz	">>: selected device/slice"
 msg_usage11:	.asciz	"*: default slice to boot"
 msg_usage12:	.asciz	"!: unbootable slice"
+
+	.bss
+	.global	daua, secsize, defflagoff, defpartoff
+	.global	maxpart, partoff
+daua:		.space	12		# DA/DU list
+secsize:	.space	12 * 2		# Sector soize
+defflagoff:	.space	12 * 2
+defpartoff:	.space	12 * 2
+maxpart:	.space	12 * 2
+partoff:	.space	12 * 2
Index: pc98/boot0.5/disk.s
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot0.5/disk.s,v
retrieving revision 1.4
diff -u -r1.4 disk.s
--- pc98/boot0.5/disk.s	31 Aug 2000 10:24:06 -0000	1.4
+++ pc98/boot0.5/disk.s	17 Mar 2007 05:30:03 -0000
@@ -25,7 +25,7 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
-# $FreeBSD: src/sys/boot/pc98/boot0.5/disk.s,v 1.4 2000/08/31 10:24:06 kato Exp $
+# $FreeBSD: src/sys/boot/pc98/boot0.5/disk.s,v 1.5 2007/03/17 05:30:03 kato Exp $
 #
 
 	.code16
@@ -284,11 +284,13 @@
 	ret
 
 	.data
-	.global	partnum, parttable, defpartflag, defpartnum, npartition
-partnum:	.space	32		# Index of parttable
-parttable:	.space	1024		# Copy of valid partition table
+	.global	defpartflag, defpartnum, npartition
 defpartflag:	.byte	0
 defpartnum:	.byte	0
 npartition:	.word	0		# number of partitions
+
 	.bss
-iplbuf:		.space	0x400
+	.global	partnum, parttable
+iplbuf:		.space	0x400		# Read buffer for IPL
+partnum:	.space	32		# Index of parttable
+parttable:	.space	1024		# Copy of valid partition table
Index: pc98/boot0.5/selector.s
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot0.5/selector.s,v
retrieving revision 1.2
diff -u -r1.2 selector.s
--- pc98/boot0.5/selector.s	6 Aug 2000 14:35:37 -0000	1.2
+++ pc98/boot0.5/selector.s	7 Apr 2007 08:37:04 -0000
@@ -1,4 +1,4 @@
-# Copyright (c) KATO Takenori, 1999, 2000.
+# Copyright (c) KATO Takenori, 1999, 2000, 2007.
 #
 # All rights reserved.  Unpublished rights reserved under the copyright
 # laws of Japan.
@@ -25,7 +25,7 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
-# $FreeBSD: src/sys/boot/pc98/boot0.5/selector.s,v 1.2 2000/08/06 14:35:37 kato Exp $
+# $FreeBSD: src/sys/boot/pc98/boot0.5/selector.s,v 1.3 2007/04/07 08:37:04 kato Exp $
 #
 
 	.code16
@@ -299,6 +299,11 @@
 	jne	dev_right
 	movw	$3, mode		# N88-BASIC
 	ret
+
+	# XXX
+	.space	5, 0x90
+	ret				# Dummy ret @0x9ab
+
 dev_up:
 	cmpw	$0, curdevice
 	je	devmode_loop
Index: pc98/boot0.5/start.s
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot0.5/start.s,v
retrieving revision 1.2
diff -u -r1.2 start.s
--- pc98/boot0.5/start.s	2 May 2003 09:33:12 -0000	1.2
+++ pc98/boot0.5/start.s	7 Apr 2007 08:37:04 -0000
@@ -1,4 +1,4 @@
-# Copyright (c) KATO Takenori, 1999, 2000.
+# Copyright (c) KATO Takenori, 1999, 2000, 2007.
 # 
 # All rights reserved.  Unpublished rights reserved under the copyright
 # laws of Japan.
@@ -25,7 +25,7 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
-# $FreeBSD: src/sys/boot/pc98/boot0.5/start.s,v 1.2 2003/05/02 09:33:12 kato Exp $
+# $FreeBSD: src/sys/boot/pc98/boot0.5/start.s,v 1.3 2007/04/07 08:37:04 kato Exp $
 #
 	.global	start
 	.code16
@@ -34,8 +34,19 @@
 start:
 	jmp	start1
 
+	# Magic
+	.org	0x053, 0x20
+	.byte	0x4e, 0x45, 0x43
+
+	.org	0x8f
+	.byte	0x32, 0x2e, 0x37, 0x30
+
 	.org	0x2d4
 start1:
+	# The instruction 'call 0x9ab' can be here.  See also selector.s.
+	nop
+	nop
+	nop
 	cli
 	movw	%cs, %ax
 	movw	%ax, %ds
Index: pc98/boot2/boot.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot2/boot.c,v
retrieving revision 1.14
diff -u -r1.14 boot.c
--- pc98/boot2/boot.c	27 May 2005 19:26:11 -0000	1.14
+++ pc98/boot2/boot.c	6 Apr 2007 20:50:24 -0000
@@ -49,7 +49,7 @@
 */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/pc98/boot2/boot.c,v 1.14 2005/05/27 19:26:11 jhb Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/pc98/boot2/boot.c,v 1.17 2007/04/06 20:50:24 kan Exp $");
 
 #include "boot.h"
 #include <a.out.h>
@@ -70,7 +70,7 @@
 static char kernel_config_namebuf[NAMEBUF_LEN + sizeof "config"];
 static char linebuf[NAMEBUF_LEN];
 static char namebuf[NAMEBUF_LEN];
-static struct bootinfo bootinfo;
+struct bootinfo bootinfo;
 int loadflags;
 
 static void getbootdev(char *ptr, int *howto);
Index: pc98/boot2/inode.h
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot2/inode.h,v
retrieving revision 1.4
diff -u -r1.4 inode.h
--- pc98/boot2/inode.h	16 Jun 2004 18:21:22 -0000	1.4
+++ pc98/boot2/inode.h	26 Sep 2006 04:15:57 -0000
@@ -33,7 +33,7 @@
  *
  *	@(#)inode.h	8.9 (Berkeley) 5/14/95
  * %FreeBSD: src/sys/ufs/ufs/inode.h,v 1.28.2.2 2001/09/29 12:52:52 iedowse Exp %
- * $FreeBSD: src/sys/boot/pc98/boot2/inode.h,v 1.4 2004/06/16 18:21:22 phk Exp $
+ * $FreeBSD: src/sys/boot/pc98/boot2/inode.h,v 1.5 2006/09/26 04:15:57 tegge Exp $
  */
 
 #ifndef _UFS_UFS_INODE_H_
@@ -147,7 +147,7 @@
 
 /* Determine if soft dependencies are being done */
 #define DOINGSOFTDEP(vp)	((vp)->v_mount->mnt_flag & MNT_SOFTDEP)
-#define DOINGASYNC(vp)		((vp)->v_mount->mnt_flag & MNT_ASYNC)
+#define DOINGASYNC(vp)		((vp)->v_mount->mnt_kern_flag & MNTK_ASYNC)
 
 /* This overlays the fid structure (see mount.h). */
 struct ufid {
Index: pc98/boot2/io.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/boot2/io.c,v
retrieving revision 1.8.2.2
diff -u -r1.8.2.2 io.c
--- pc98/boot2/io.c	21 May 2006 11:20:27 -0000	1.8.2.2
+++ pc98/boot2/io.c	9 May 2006 14:20:17 -0000
@@ -27,7 +27,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/pc98/boot2/io.c,v 1.8.2.2 2006/05/21 11:20:27 nyan Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/pc98/boot2/io.c,v 1.10 2006/05/09 14:20:17 nyan Exp $");
 
 #include "boot.h"
 #include <machine/cpufunc.h>
Index: pc98/btx/btx/btx.S
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/btx/btx/btx.S,v
retrieving revision 1.21
diff -u -r1.21 btx.S
--- pc98/btx/btx/btx.S	8 May 2005 14:17:27 -0000	1.21
+++ pc98/btx/btx/btx.S	9 Nov 2006 08:05:51 -0000
@@ -12,7 +12,7 @@
  * warranties of merchantability and fitness for a particular
  * purpose.
  *
- * $FreeBSD: src/sys/boot/pc98/btx/btx/btx.S,v 1.21 2005/05/08 14:17:27 nyan Exp $
+ * $FreeBSD: src/sys/boot/pc98/btx/btx/btx.S,v 1.22 2006/11/09 08:05:51 nyan Exp $
  */
 
 /*
@@ -206,7 +206,7 @@
 #ifdef PAGING
 		or $0x80000001,%eax             #  mode and enable paging
 #else
-		or $0x01,%eax			#  mode
+		inc %ax				#  mode
 #endif
 		mov %eax,%cr0			#
 		ljmp $SEL_SCODE,$init.8		# To 32-bit code
@@ -473,12 +473,12 @@
 		movb $0x4,%cl			# Update seg regs
 		rep				#  in INT_V86
 		movsl				#  args
-intrtn.2:	movl %edx,%esi			# Segment registers
+intrtn.2:	xchgl %edx,%esi			# Segment registers
 		leal 0x28(%ebp),%edi		# Set up seg
 		movb $0x4,%cl			#  regs for
 		rep				#  later
 		movsl				#  pop
-		movl %ebx,%esi			# Restore exception
+		xchgl %ebx,%esi			# Restore exception
 		movb $0x5,%cl			#  frame to
 		rep				#  supervisor
 		movsl				#  stack
@@ -523,9 +523,7 @@
 		je v86wrmsr			# Yes
 		cmpb $0x32,(%esi)		# Is it a RDMSR?
 		je v86rdmsr			# Yes
-		cmpb $0x20,(%esi)		# Is this a
-		jne v86mon.4			#  MOV EAX,CR0
-		cmpb $0xc0,0x1(%esi)		#  instruction?
+		cmpb $0x20,(%esi)		# Is this a MOV reg,CRx?
 		je v86mov			# Yes
 v86mon.4:	cmpb $0xfa,%al			# CLI?
 		je v86cli			# Yes
@@ -557,10 +555,24 @@
 		leal 0x8(%esp,1),%esp		# Discard int no, error
 		iret				# To V86 mode
 /*
- * Emulate MOV EAX,CR0.
+ * Emulate MOV reg,CRx.
  */
-v86mov: 	movl %cr0,%eax			# CR0 to
-		movl %eax,0x1c(%ebp)		#  saved EAX
+v86mov: 	movb 0x1(%esi),%bl		# Fetch Mod R/M byte
+		testb $0x10,%bl			# Read CR2 or CR3?
+		jnz v86mov.1			# Yes
+		movl %cr0,%eax			# Read CR0
+		testb $0x20,%bl			# Read CR4 instead?
+		jz v86mov.2			# No
+		movl %cr4,%eax			# Read CR4
+		jmp v86mov.2
+v86mov.1:	movl %cr2,%eax			# Read CR2
+		testb $0x08,%bl			# Read CR3 instead?
+		jz v86mov.2			# No
+		movl %cr3,%eax			# Read CR3
+v86mov.2:	andl $0x7,%ebx			# Compute offset in
+		shl $2,%ebx			#  frame of destination
+		neg %ebx			#  register
+		movl %eax,0x1c(%ebp,%ebx,1)	# Store CR to reg
 		incl %esi			# Adjust IP
 /*
  * Return from emulating a 0x0f prefixed instruction
@@ -636,41 +648,28 @@
  * reads count of words from saved %cx
  * returns success by setting %ah to 0
  */
-int15_87:	pushl %eax			# Save
-		pushl %ebx			#  some information
-		pushl %esi			#  onto the stack.
-		pushl %edi
-		xorl %eax,%eax			# clean EAX
-		xorl %ebx,%ebx			# clean EBX
-		movl 0x4(%ebp),%esi		# Get user's ESI
-		movl 0x3C(%ebp),%ebx		# store ES
-		movw %si,%ax			# store SI
-		shll $0x4,%ebx			# Make it a seg.
-		addl %eax,%ebx			# ebx=(es<<4)+si
-		movb 0x14(%ebx),%al		# Grab the
-		movb 0x17(%ebx),%ah		#  necessary
-		shll $0x10,%eax			#  information
-		movw 0x12(%ebx),%ax		#  from
-		movl %eax,%esi			#  the
-		movb 0x1c(%ebx),%al		#  GDT in order to
-		movb 0x1f(%ebx),%ah		#  have %esi offset
-		shll $0x10,%eax			#  of source and %edi
-		movw 0x1a(%ebx),%ax		#  of destination.
-		movl %eax,%edi
+int15_87:	pushl %esi			# Save 
+		pushl %edi			#  registers
+		movl 0x3C(%ebp),%edi		# Load ES
+		movzwl 0x4(%ebp),%eax		# Load user's SI
+		shll $0x4,%edi			# EDI = (ES << 4) +
+		addl %eax,%edi			#   SI
+		movl 0x11(%edi),%eax		# Read base of
+		movb 0x17(%edi),%al		#  GDT entry
+		ror $8,%eax			#  for source
+		xchgl %eax,%esi			#  into %esi
+		movl 0x19(%edi),%eax		# Read base of
+		movb 0x1f(%edi),%al		#  GDT entry for
+		ror $8,%eax			#  destination
+		xchgl %eax,%edi			#  into %edi
 		pushl %ds			# Make:
 		popl %es			# es = ds
-		pushl %ecx			# stash ECX
-		xorl %ecx,%ecx			# highw of ECX is clear
-		movw 0x18(%ebp),%cx		# Get user's ECX
-		shll $0x1,%ecx			# Convert from num words to num
-						#  bytes
+		movzwl 0x18(%ebp),%ecx		# Get user's CX
+		shll $0x1,%ecx			# Convert count from words
 		rep				# repeat...
 		movsb				#  perform copy.
-		popl %ecx			# Restore
-		popl %edi
-		popl %esi			#  previous
-		popl %ebx			#  register
-		popl %eax			#  values.
+		popl %edi			# Restore
+		popl %esi			#  registers
 		movb $0x0,0x1d(%ebp)		# set ah = 0 to indicate
 						#  success
 		andb $0xfe,%dl			# clear CF
@@ -689,23 +688,16 @@
 		cmpb $0x19,%al			# is it int 19?
 		je reboot			#  yes, reboot the machine
 		cmpb $0x15,%al			# is it int 15?
-		jne v86intn.3			#  no, skip parse
-		pushl %eax                      # stash EAX
-		movl 0x1c(%ebp),%eax		# user's saved EAX
-		cmpb $0x87,%ah			# is it the memcpy subfunction?
-		jne v86intn.1			#  no, keep checking
-		popl %eax			# get the stack straight
-		jmp int15_87			# it's our cue
-v86intn.1:	cmpw $0x4f53,%ax		# is it the delete key callout?
-		jne v86intn.2			#  no, handle the int normally
-		movb BDA_KEYFLAGS,%al		# get the shift key state
-		andb $0x18,%al			# mask off just Ctrl and Alt
-		cmpb $0x18,%al			# are both Ctrl and Alt down?
-		jne v86intn.2			#  no, handle the int normally
-		popl %eax			# restore EAX
-		jmp reboot			# reboot the machine
-v86intn.2:	popl %eax			# restore EAX
-v86intn.3:	subl %edi,%esi			# From
+		jne v86intn.1			#  no, skip parse
+		cmpb $0x87,0x1d(%ebp)		# is it the memcpy subfunction?
+		je int15_87			#  yes
+		cmpw $0x4f53,0x1c(%ebp)		# is it the delete key callout?
+		jne v86intn.1			#  no, handle the int normally
+		movb BDA_KEYFLAGS,%ch		# get the shift key state
+		andb $0x18,%ch			# mask off just Ctrl and Alt
+		cmpb $0x18,%ch			# are both Ctrl and Alt down?
+		je reboot			# yes, reboot the machine
+v86intn.1:	subl %edi,%esi			# From
 		shrl $0x4,%edi			#  linear
 		movw %dx,-0x2(%ebx)		# Save flags
 		movw %di,-0x4(%ebx)		# Save CS
Index: pc98/cdboot/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/cdboot/Makefile,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 Makefile
--- pc98/cdboot/Makefile	16 Jun 2006 13:40:50 -0000	1.1.2.1
+++ pc98/cdboot/Makefile	14 May 2006 07:26:02 -0000
@@ -1,4 +1,4 @@
-# $FreeBSD: src/sys/boot/pc98/cdboot/Makefile,v 1.1.2.1 2006/06/16 13:40:50 nyan Exp $
+# $FreeBSD: src/sys/boot/pc98/cdboot/Makefile,v 1.1 2006/05/14 07:26:02 nyan Exp $
 
 PROG=	cdboot
 STRIP=
Index: pc98/cdboot/cdboot.s
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/cdboot/cdboot.s,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 cdboot.s
--- pc98/cdboot/cdboot.s	16 Jun 2006 13:40:50 -0000	1.1.2.1
+++ pc98/cdboot/cdboot.s	4 Mar 2007 04:53:17 -0000
@@ -28,7 +28,7 @@
 # SUCH DAMAGE.
 #
 
-# $FreeBSD: src/sys/boot/pc98/cdboot/cdboot.s,v 1.1.2.1 2006/06/16 13:40:50 nyan Exp $
+# $FreeBSD: src/sys/boot/pc98/cdboot/cdboot.s,v 1.2 2007/03/04 04:53:17 nyan Exp $
 
 #
 # Basically, we first create a set of boot arguments to pass to the loaded
@@ -705,7 +705,7 @@
 twiddle:	push %ax			# Save
 		push %bx			# Save
 		mov twiddle_index,%al		# Load index
-		mov twiddle_chars,%bx		# Address table
+		mov $twiddle_chars,%bx		# Address table
 		inc %al				# Next
 		and $3,%al			#  char
 		mov %al,twiddle_index		# Save index for next call
Index: pc98/libpc98/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/libpc98/Makefile,v
retrieving revision 1.22.2.1
diff -u -r1.22.2.1 Makefile
--- pc98/libpc98/Makefile	1 Oct 2006 12:07:07 -0000	1.22.2.1
+++ pc98/libpc98/Makefile	11 Apr 2006 20:11:30 -0000
@@ -1,4 +1,4 @@
-# $FreeBSD: src/sys/boot/pc98/libpc98/Makefile,v 1.22.2.1 2006/10/01 12:07:07 ru Exp $
+# $FreeBSD: src/sys/boot/pc98/libpc98/Makefile,v 1.24 2006/04/11 20:11:30 jhb Exp $
 #
 LIB=			pc98
 INTERNALLIB=
Index: pc98/libpc98/bioscd.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/libpc98/bioscd.c,v
retrieving revision 1.1.2.1
diff -u -r1.1.2.1 bioscd.c
--- pc98/libpc98/bioscd.c	16 Jun 2006 13:14:15 -0000	1.1.2.1
+++ pc98/libpc98/bioscd.c	2 Nov 2006 01:23:18 -0000
@@ -26,7 +26,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/bioscd.c,v 1.1.2.1 2006/06/16 13:14:15 nyan Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/bioscd.c,v 1.2 2006/11/02 01:23:18 marcel Exp $");
 
 /*
  * BIOS CD device handling for CD's that have been booted off of via no
@@ -192,7 +192,7 @@
 	va_start(ap, f);
 	dev = va_arg(ap, struct i386_devdesc *);
 	va_end(ap);
-	if (dev->d_kind.bioscd.unit >= nbcinfo) {
+	if (dev->d_unit >= nbcinfo) {
 		DEBUG("attempt to open nonexistent disk");
 		return(ENXIO);
 	}
@@ -227,7 +227,7 @@
 	if (rw != F_READ)
 		return(EROFS);
 	dev = (struct i386_devdesc *)devdata;
-	unit = dev->d_kind.bioscd.unit;
+	unit = dev->d_unit;
 	blks = size / BIOSCD_SECSIZE;
 	if (dblk % (BIOSCD_SECSIZE / DEV_BSIZE) != 0)
 		return (EINVAL);
@@ -321,7 +321,7 @@
     int major;
     int rootdev;
 
-    unit = dev->d_kind.bioscd.unit;
+    unit = dev->d_unit;
     biosdev = bc_unit2bios(unit);
     DEBUG("unit %d BIOS device %d", unit, biosdev);
     if (biosdev == -1)				/* not a BIOS device */
Index: pc98/libpc98/biosdisk.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/libpc98/biosdisk.c,v
retrieving revision 1.32.2.1
diff -u -r1.32.2.1 biosdisk.c
--- pc98/libpc98/biosdisk.c	1 Oct 2006 12:07:07 -0000	1.32.2.1
+++ pc98/libpc98/biosdisk.c	2 Nov 2006 01:23:18 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/biosdisk.c,v 1.32.2.1 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/biosdisk.c,v 1.34 2006/11/02 01:23:18 marcel Exp $");
 
 /*
  * BIOS disk device handling.
@@ -256,7 +256,7 @@
 	pager_output(line);
 
 	/* try to open the whole disk */
-	dev.d_kind.biosdisk.unit = i;
+	dev.d_unit = i;
 	dev.d_kind.biosdisk.slice = -1;
 	dev.d_kind.biosdisk.partition = -1;
 	
@@ -385,7 +385,7 @@
     int				error;
     char			buf[BUFSIZE];
 
-    if (dev->d_kind.biosdisk.unit >= nbdinfo) {
+    if (dev->d_unit >= nbdinfo) {
 	DEBUG("attempt to open nonexistent disk");
 	return(ENXIO);
     }
@@ -397,14 +397,14 @@
     }
 
     /* Look up BIOS unit number, intialise open_disk structure */
-    od->od_dkunit = dev->d_kind.biosdisk.unit;
+    od->od_dkunit = dev->d_unit;
     od->od_unit = bdinfo[od->od_dkunit].bd_unit;
     od->od_flags = bdinfo[od->od_dkunit].bd_flags;
     od->od_boff = 0;
     od->od_nslices = 0;
     error = 0;
     DEBUG("open '%s', unit 0x%x slice %d partition %c",
-	     i386_fmtdev(dev), dev->d_kind.biosdisk.unit, 
+	     i386_fmtdev(dev), dev->d_unit, 
 	     dev->d_kind.biosdisk.slice, dev->d_kind.biosdisk.partition + 'a');
 
     /* Get geometry for this open (removable device may have changed) */
@@ -1058,8 +1058,8 @@
     char			*nip, *cp;
     int				unitofs = 0, i, unit;
 
-    biosdev = bd_unit2bios(dev->d_kind.biosdisk.unit);
-    DEBUG("unit %d BIOS device %d", dev->d_kind.biosdisk.unit, biosdev);
+    biosdev = bd_unit2bios(dev->d_unit);
+    DEBUG("unit %d BIOS device %d", dev->d_unit, biosdev);
     if (biosdev == -1)				/* not a BIOS device */
 	return(-1);
     if (bd_opendisk(&od, dev) != 0)		/* oops, not a viable device */
@@ -1067,7 +1067,7 @@
 
     if ((biosdev & 0xf0) == 0x90 || (biosdev & 0xf0) == 0x30) {
 	/* floppy (or emulated floppy) or ATAPI device */
-	if (bdinfo[dev->d_kind.biosdisk.unit].bd_type == DT_ATAPI) {
+	if (bdinfo[dev->d_unit].bd_type == DT_ATAPI) {
 	    /* is an ATAPI disk */
 	    major = WFDMAJOR;
 	} else {
@@ -1093,7 +1093,7 @@
     }
     /* default root disk unit number */
     if ((biosdev & 0xf0) == 0xa0)
-	unit = bdinfo[dev->d_kind.biosdisk.unit].bd_da_unit;
+	unit = bdinfo[dev->d_unit].bd_da_unit;
     else
 	unit = biosdev & 0xf;
 
Index: pc98/libpc98/biosmem.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/libpc98/biosmem.c,v
retrieving revision 1.7.2.1
diff -u -r1.7.2.1 biosmem.c
--- pc98/libpc98/biosmem.c	1 Oct 2006 12:07:07 -0000	1.7.2.1
+++ pc98/libpc98/biosmem.c	21 Dec 2005 06:09:47 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/biosmem.c,v 1.7.2.1 2006/10/01 12:07:07 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/biosmem.c,v 1.8 2005/12/21 06:09:47 nyan Exp $");
 
 /*
  * Obtain memory configuration information from the BIOS
Index: pc98/libpc98/comconsole.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/libpc98/comconsole.c,v
retrieving revision 1.6.2.1
diff -u -r1.6.2.1 comconsole.c
--- pc98/libpc98/comconsole.c	28 Jan 2006 07:55:19 -0000	1.6.2.1
+++ pc98/libpc98/comconsole.c	13 Sep 2005 08:29:03 -0000
@@ -24,7 +24,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/comconsole.c,v 1.6.2.1 2006/01/28 07:55:19 nyan Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/pc98/libpc98/comconsole.c,v 1.7 2005/09/13 08:29:03 nyan Exp $");
 
 #include <stand.h>
 #include <bootstrap.h>
Index: pc98/loader/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/loader/Makefile,v
retrieving revision 1.38.2.1
diff -u -r1.38.2.1 Makefile
--- pc98/loader/Makefile	30 Oct 2005 16:34:37 -0000	1.38.2.1
+++ pc98/loader/Makefile	2 Nov 2006 00:26:45 -0000
@@ -1,4 +1,6 @@
-# $FreeBSD: src/sys/boot/pc98/loader/Makefile,v 1.38.2.1 2005/10/30 16:34:37 nyan Exp $
+# $FreeBSD: src/sys/boot/pc98/loader/Makefile,v 1.41 2006/11/02 00:26:45 marcel Exp $
+
+.include <bsd.own.mk>
 
 PROG=		loader.sym
 INTERNALPROG=
@@ -15,11 +17,13 @@
 CFLAGS+=	-DLOADER_NFS_SUPPORT
 .endif
 
+HAVE_BCACHE=	yes
+
 # Enable PnP and ISA-PnP code.
 HAVE_PNP=	yes
 HAVE_ISABUS=	yes
 
-.if !defined(NO_FORTH)
+.if ${MK_FORTH} != "no"
 # Enable BootForth
 BOOT_FORTH=	yes
 CFLAGS+=	-DBOOT_FORTH -I${.CURDIR}/../../ficl -I${.CURDIR}/../../ficl/i386
Index: pc98/loader/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/pc98/loader/main.c,v
retrieving revision 1.20.2.2
diff -u -r1.20.2.2 main.c
--- pc98/loader/main.c	1 Oct 2006 12:07:08 -0000	1.20.2.2
+++ pc98/loader/main.c	2 Nov 2006 01:23:18 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/pc98/loader/main.c,v 1.20.2.2 2006/10/01 12:07:08 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/pc98/loader/main.c,v 1.24 2006/11/02 01:23:18 marcel Exp $");
 
 /*
  * MD bootstrap main() and assorted miscellaneous
@@ -193,11 +193,11 @@
         if ((kargs->bootflags & KARGS_FLAGS_CD) != 0) {
 	    /* we are booting from a CD with cdboot */
 	    new_currdev.d_dev = &bioscd;
-	    new_currdev.d_kind.bioscd.unit = bc_bios2unit(initial_bootdev);
+	    new_currdev.d_unit = bc_bios2unit(initial_bootdev);
 	} else if ((kargs->bootflags & KARGS_FLAGS_PXE) != 0) {
 	    /* we are booting from pxeldr */
 	    new_currdev.d_dev = &pxedisk;
-	    new_currdev.d_kind.netif.unit = 0;
+	    new_currdev.d_unit = 0;
 	} else {
 	    /* we don't know what our boot device is */
 	    new_currdev.d_kind.biosdisk.slice = -1;
@@ -236,10 +236,10 @@
      * which one we booted off of, just use disk0: as a reasonable default.
      */
     if ((new_currdev.d_type == biosdisk.dv_type) &&
-	((new_currdev.d_kind.biosdisk.unit = bd_bios2unit(biosdev)) == -1)) {
+	((new_currdev.d_unit = bd_bios2unit(biosdev)) == -1)) {
 	printf("Can't work out which disk we are booting from.\n"
 	       "Guessed BIOS device 0x%x not found by probes, defaulting to disk0:\n", biosdev);
-	new_currdev.d_kind.biosdisk.unit = 0;
+	new_currdev.d_unit = 0;
     }
     env_setenv("currdev", EV_VOLATILE, i386_fmtdev(&new_currdev),
 	       i386_setcurrdev, env_nounset);
Index: powerpc/loader/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/powerpc/loader/Makefile,v
retrieving revision 1.18
diff -u -r1.18 Makefile
--- powerpc/loader/Makefile	21 Dec 2004 12:32:15 -0000	1.18
+++ powerpc/loader/Makefile	17 Mar 2006 18:54:36 -0000
@@ -1,4 +1,6 @@
-# $FreeBSD: src/sys/boot/powerpc/loader/Makefile,v 1.18 2004/12/21 12:32:15 ru Exp $
+# $FreeBSD: src/sys/boot/powerpc/loader/Makefile,v 1.19 2006/03/17 18:54:36 ru Exp $
+
+.include <bsd.own.mk>
 
 PROG=		loader
 NEWVERSWHAT=	"bootstrap loader" "Open Firmware/PowerPC"
@@ -46,7 +48,7 @@
 CFLAGS+=	-DLOADER_TFTP_SUPPORT
 .endif
 
-.if !defined(NO_FORTH)
+.if ${MK_FORTH} != "no"
 # Enable BootForth
 BOOT_FORTH=	yes
 CFLAGS+=	-DBOOT_FORTH -I${.CURDIR}/../../ficl -I${.CURDIR}/../../ficl/powerpc
Index: powerpc/loader/conf.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/powerpc/loader/conf.c,v
retrieving revision 1.10
diff -u -r1.10 conf.c
--- powerpc/loader/conf.c	4 Jan 2004 23:21:18 -0000	1.10
+++ powerpc/loader/conf.c	12 May 2006 04:09:53 -0000
@@ -25,7 +25,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/powerpc/loader/conf.c,v 1.10 2004/01/04 23:21:18 obrien Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/powerpc/loader/conf.c,v 1.11 2006/05/12 04:09:53 jhb Exp $");
 
 #include <stand.h>
 #include "bootstrap.h"
@@ -102,7 +102,7 @@
 /* 
  * Consoles 
  *
- * We don't prototype these in libalpha.h because they require
+ * We don't prototype these in libofw.h because they require
  * data structures from bootstrap.h as well.
  */
 extern struct console ofwconsole;
Index: powerpc/loader/metadata.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/powerpc/loader/metadata.c,v
retrieving revision 1.5.2.1
diff -u -r1.5.2.1 metadata.c
--- powerpc/loader/metadata.c	14 Feb 2006 06:20:16 -0000	1.5.2.1
+++ powerpc/loader/metadata.c	22 Sep 2005 15:06:58 -0000
@@ -27,7 +27,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/powerpc/loader/metadata.c,v 1.5.2.1 2006/02/14 06:20:16 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/powerpc/loader/metadata.c,v 1.6 2005/09/22 15:06:58 ru Exp $");
 
 #include <stand.h>
 #include <sys/param.h>
Index: sparc64/loader/Makefile
===================================================================
RCS file: /home/ncvs/src/sys/boot/sparc64/loader/Makefile,v
retrieving revision 1.19
diff -u -r1.19 Makefile
--- sparc64/loader/Makefile	21 Dec 2004 12:32:15 -0000	1.19
+++ sparc64/loader/Makefile	17 Mar 2006 18:54:36 -0000
@@ -1,4 +1,6 @@
-# $FreeBSD: src/sys/boot/sparc64/loader/Makefile,v 1.19 2004/12/21 12:32:15 ru Exp $
+# $FreeBSD: src/sys/boot/sparc64/loader/Makefile,v 1.20 2006/03/17 18:54:36 ru Exp $
+
+.include <bsd.own.mk>
 
 PROG=		loader
 NEWVERSWHAT=	"bootstrap loader" sparc64
@@ -41,7 +43,7 @@
 CFLAGS+=	-DLOADER_TFTP_SUPPORT
 .endif
 
-.if !defined(NO_FORTH)
+.if ${MK_FORTH} != "no"
 # Enable BootForth
 BOOT_FORTH=	yes
 CFLAGS+=	-DBOOT_FORTH -I${.CURDIR}/../../ficl -I${.CURDIR}/../../ficl/sparc64
Index: sparc64/loader/main.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/sparc64/loader/main.c,v
retrieving revision 1.26
diff -u -r1.26 main.c
--- sparc64/loader/main.c	5 Jan 2005 22:16:58 -0000	1.26
+++ sparc64/loader/main.c	18 Dec 2006 07:35:14 -0000
@@ -8,8 +8,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/sparc64/loader/main.c,v 1.26 2005/01/05 22:16:58 imp Exp $");
-
+__FBSDID("$FreeBSD: src/sys/boot/sparc64/loader/main.c,v 1.30 2006/12/18 07:35:14 kmacy Exp $");
 /*
  * FreeBSD/sparc64 kernel loader - machine dependent part
  *
@@ -25,7 +24,9 @@
 #include <sys/param.h>
 #include <sys/queue.h>
 #include <sys/linker.h>
+#include <sys/types.h>
 
+#include <vm/vm.h>
 #include <machine/asi.h>
 #include <machine/atomic.h>
 #include <machine/cpufunc.h>
@@ -50,6 +51,12 @@
 	vm_offset_t size;
 };
 
+struct mmu_ops {
+	void (*tlb_init)(void);
+	int (*mmu_mapin)(vm_offset_t va, vm_size_t len);
+} *mmu_ops;
+
+
 typedef void kernel_entry_t(vm_offset_t mdp, u_long o1, u_long o2, u_long o3,
 			    void *openfirmware);
 
@@ -60,7 +67,34 @@
 extern vm_offset_t md_load(char *, vm_offset_t *);
 static int __elfN(exec)(struct preloaded_file *);
 static int sparc64_autoload(void);
-static int mmu_mapin(vm_offset_t, vm_size_t);
+static int mmu_mapin_sun4u(vm_offset_t, vm_size_t);
+static int mmu_mapin_sun4v(vm_offset_t, vm_size_t);
+static void tlb_init_sun4u(void);
+static void tlb_init_sun4v(void);
+
+struct mmu_ops mmu_ops_sun4u = 	{ tlb_init_sun4u, mmu_mapin_sun4u };
+struct mmu_ops mmu_ops_sun4v = 	{ tlb_init_sun4v, mmu_mapin_sun4v };
+
+extern char bootprog_name[], bootprog_rev[], bootprog_date[], bootprog_maker[];
+
+/* sun4u */
+struct tlb_entry *dtlb_store;
+struct tlb_entry *itlb_store;
+int dtlb_slot;
+int itlb_slot;
+int dtlb_slot_max;
+int itlb_slot_max;
+
+/* sun4v */
+struct tlb_entry *tlb_store;
+int is_sun4v = 0;
+/* 
+ * no direct TLB access on sun4v
+ * we somewhat arbitrarily declare enough 
+ * slots to cover a 4GB AS with 4MB pages
+ */
+#define SUN4V_TLB_SLOT_MAX (1 << 10)
+
 
 extern char bootprog_name[], bootprog_rev[], bootprog_date[], bootprog_maker[];
 
@@ -204,18 +238,64 @@
 static ssize_t
 sparc64_readin(const int fd, vm_offset_t va, const size_t len)
 {
-	mmu_mapin(va, len);
+	mmu_ops->mmu_mapin(va, len);
 	return read(fd, (void *)va, len);
 }
 
 static ssize_t
 sparc64_copyin(const void *src, vm_offset_t dest, size_t len)
 {
-	mmu_mapin(dest, len);
+	mmu_ops->mmu_mapin(dest, len);
 	memcpy((void *)dest, src, len);
 	return len;
 }
 
+static void
+sparc64_maphint(vm_offset_t va, size_t len)
+{
+	vm_paddr_t pa;
+	vm_offset_t mva;
+	size_t size;
+	int i, ret, free_excess = 0;
+
+	if (!is_sun4v)
+		return;
+
+	if (tlb_store[va >> 22].te_pa != -1)
+		return;
+
+	/* round up to nearest 4MB page */
+	size = (len + PAGE_MASK_4M) & ~PAGE_MASK_4M;
+#if 0	
+	pa = (vm_offset_t)OF_alloc_phys(PAGE_SIZE_256M,	PAGE_SIZE_256M);
+
+	if (pa != -1)
+		free_excess = 1;
+	else
+#endif
+		pa = (vm_offset_t)OF_alloc_phys(size, PAGE_SIZE_256M);
+	if (pa == -1)
+		pa = (vm_offset_t)OF_alloc_phys(size, PAGE_SIZE_4M);
+	if (pa == -1)
+		panic("out of memory");
+
+	for (i = 0; i < size; i += PAGE_SIZE_4M) {
+		mva = (vm_offset_t)OF_claim_virt(va + i, PAGE_SIZE_4M, 0);
+		if (mva != (va + i)) {
+			panic("can't claim virtual page "
+			      "(wanted %#lx, got %#lx)",
+			      va, mva);
+		}
+
+		tlb_store[mva >> 22].te_pa = pa + i;
+		if ((ret = OF_map_phys(-1, PAGE_SIZE_4M, mva, pa + i)) != 0)
+			printf("OF_map_phys failed: %d\n", ret);
+	}
+	if (free_excess)
+		OF_release_phys((vm_offset_t)pa, PAGE_SIZE_256M);
+}
+
+
 /*
  * other MD functions
  */
@@ -244,7 +324,7 @@
 
 	entry = e->e_entry;
 
-	OF_release(heapva, HEAPSZ);
+	OF_release((void *)heapva, HEAPSZ);
 
 	((kernel_entry_t *)entry)(mdp, 0, 0, 0, openfirmware);
 
@@ -252,7 +332,7 @@
 }
 
 static int
-mmu_mapin(vm_offset_t va, vm_size_t len)
+mmu_mapin_sun4u(vm_offset_t va, vm_size_t len)
 {
 	vm_offset_t pa, mva;
 	u_long data;
@@ -307,6 +387,53 @@
 	}
 	if (pa != (vm_offset_t)-1)
 		OF_release_phys(pa, PAGE_SIZE_4M);
+
+	return 0;
+}
+
+static int
+mmu_mapin_sun4v(vm_offset_t va, vm_size_t len)
+{
+
+	vm_offset_t pa, mva;
+	u_long data;
+	int ret;
+
+	if (va + len > curkva)
+		curkva = va + len;
+
+	pa = (vm_offset_t)-1;
+	len += va & PAGE_MASK_4M;
+	va &= ~PAGE_MASK_4M;
+	while (len) {
+		if ((va >> 22) > SUN4V_TLB_SLOT_MAX)
+			panic("trying to map more than 4GB");
+		if (tlb_store[va >> 22].te_pa == -1) {
+			/* Allocate a physical page, claim the virtual area */
+			if (pa == (vm_offset_t)-1) {
+				pa = (vm_offset_t)OF_alloc_phys(PAGE_SIZE_4M,
+				    PAGE_SIZE_4M);
+				if (pa == (vm_offset_t)-1)
+					panic("out of memory");
+				mva = (vm_offset_t)OF_claim_virt(va,
+				    PAGE_SIZE_4M, 0);
+				if (mva != va) {
+					panic("can't claim virtual page "
+					    "(wanted %#lx, got %#lx)",
+					    va, mva);
+				}
+			}
+
+			tlb_store[va >> 22].te_pa = pa;
+			if ((ret = OF_map_phys(-1, PAGE_SIZE_4M, va, pa)) != 0)
+				printf("OF_map_phys failed: %d\n", ret);
+			pa = (vm_offset_t)-1;
+		}
+		len -= len > PAGE_SIZE_4M ? PAGE_SIZE_4M : len;
+		va += PAGE_SIZE_4M;
+	}
+	if (pa != (vm_offset_t)-1)
+		OF_release_phys(pa, PAGE_SIZE_4M);
 	return 0;
 }
 
@@ -324,7 +451,7 @@
 }
 
 static void
-tlb_init(void)
+tlb_init_sun4u(void)
 {
 	phandle_t child;
 	phandle_t root;
@@ -361,11 +488,20 @@
 		panic("init_tlb: malloc");
 }
 
+static void
+tlb_init_sun4v(void)
+{
+	tlb_store = malloc(SUN4V_TLB_SLOT_MAX * sizeof(*tlb_store));
+	memset(tlb_store, 0xFF, SUN4V_TLB_SLOT_MAX * sizeof(*tlb_store));
+}
+
 int
 main(int (*openfirm)(void *))
 {
 	char bootpath[64];
+	char compatible[32];
 	struct devsw **dp;
+	phandle_t rooth;
 	phandle_t chosenh;
 
 	/*
@@ -378,18 +514,27 @@
 	archsw.arch_copyout = ofw_copyout;
 	archsw.arch_readin = sparc64_readin;
 	archsw.arch_autoload = sparc64_autoload;
+	archsw.arch_maphint = sparc64_maphint;
 
 	init_heap();
 	setheap((void *)heapva, (void *)(heapva + HEAPSZ));
-
 	/*
 	 * Probe for a console.
 	 */
 	cons_probe();
 
-	tlb_init();
+	rooth = OF_peer(0);
+	OF_getprop(rooth, "compatible", compatible, sizeof(compatible));
+	if (!strcmp(compatible, "sun4v")) {
+		printf("\nBooting with sun4v support.\n");
+		mmu_ops = &mmu_ops_sun4v;
+		is_sun4v = 1;
+	} else {
+		printf("\nBooting with sun4u support.\n");
+		mmu_ops = &mmu_ops_sun4u;
+	}
 
-	bcache_init(32, 512);
+	mmu_ops->tlb_init();
 
 	/*
 	 * Initialize devices.
Index: sparc64/loader/metadata.c
===================================================================
RCS file: /home/ncvs/src/sys/boot/sparc64/loader/metadata.c,v
retrieving revision 1.13.2.2
diff -u -r1.13.2.2 metadata.c
--- sparc64/loader/metadata.c	14 Feb 2006 06:20:16 -0000	1.13.2.2
+++ sparc64/loader/metadata.c	22 Sep 2005 15:06:58 -0000
@@ -27,7 +27,7 @@
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/sys/boot/sparc64/loader/metadata.c,v 1.13.2.2 2006/02/14 06:20:16 ru Exp $");
+__FBSDID("$FreeBSD: src/sys/boot/sparc64/loader/metadata.c,v 1.15 2005/09/22 15:06:58 ru Exp $");
 
 #include <stand.h>
 #include <sys/param.h>
