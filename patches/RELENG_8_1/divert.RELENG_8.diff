Index: contrib/pf/pfctl/parse.y
===================================================================
RCS file: /root/freebsd/test/repoold/src/contrib/pf/pfctl/parse.y,v
retrieving revision 1.3
diff -u -r1.3 parse.y
--- contrib/pf/pfctl/parse.y	15 Apr 2010 23:00:42 -0000	1.3
+++ contrib/pf/pfctl/parse.y	15 Apr 2010 23:00:47 -0000
@@ -129,6 +129,7 @@
 enum	{ PF_STATE_OPT_MAX, PF_STATE_OPT_NOSYNC, PF_STATE_OPT_SRCTRACK,
 	    PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_CONN,
 	    PF_STATE_OPT_MAX_SRC_CONN_RATE, PF_STATE_OPT_MAX_SRC_NODES,
+	    PF_STATE_OPT_MAX_PACKETS, 
 	    PF_STATE_OPT_OVERLOAD, PF_STATE_OPT_STATELOCK,
 	    PF_STATE_OPT_TIMEOUT, PF_STATE_OPT_SLOPPY };
 
@@ -140,6 +141,7 @@
 		u_int32_t	 max_states;
 		u_int32_t	 max_src_states;
 		u_int32_t	 max_src_conn;
+		u_int32_t	 max_packets;
 		struct {
 			u_int32_t	limit;
 			u_int32_t	seconds;
@@ -207,6 +209,7 @@
 	int			 allowopts;
 	char			*label;
 	struct node_qassign	 queues;
+	u_int16_t		 divert;
 	char			*tag;
 	char			*match_tag;
 	u_int8_t		 match_tag_not;
@@ -434,7 +437,7 @@
 %token	LOAD RULESET_OPTIMIZATION
 %token	STICKYADDRESS MAXSRCSTATES MAXSRCNODES SOURCETRACK GLOBAL RULE
 %token	MAXSRCCONN MAXSRCCONNRATE OVERLOAD FLUSH SLOPPY
-%token	TAGGED TAG IFBOUND FLOATING STATEPOLICY ROUTE
+%token	TAGGED TAG IFBOUND FLOATING DIVERT STATEPOLICY ROUTE
 %token	<v.string>		STRING
 %token	<v.i>			PORTBINARY
 %type	<v.interface>		interface if_list if_item_not if_item
@@ -462,6 +465,7 @@
 %type	<v.route>		route
 %type	<v.redirection>		redirection redirpool
 %type	<v.string>		label string tag anchorname
+%type	<v.number>		divert
 %type	<v.keep_state>		keep
 %type	<v.state_opt>		state_opt_spec state_opt_list state_opt_item
 %type	<v.logquick>		logquick quick log logopts logopt
@@ -1784,6 +1788,8 @@
 			r.rtableid = $9.rtableid;
 
 			r.af = $6;
+			if ($9.divert)
+				r.divert = $9.divert;
 			if ($9.tag)
 				if (strlcpy(r.tagname, $9.tag,
 				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
@@ -1869,6 +1875,14 @@
 					}
 					r.rule_flag |= PFRULE_NOSYNC;
 					break;
+				case PF_STATE_OPT_MAX_PACKETS:
+					if (o->data.max_packets == 0) {
+						yyerror("max_packets must be"
+							"greater than 0");
+						YYERROR;
+					}
+					r.spare1 = o->data.max_packets;
+					break;
 				case PF_STATE_OPT_SRCTRACK:
 					if (srctrack) {
 						yyerror("state option "
@@ -2258,6 +2272,9 @@
 			filter_opts.dnpipe = $3;
 			filter_opts.free_flags |= PFRULE_DN_IS_QUEUE;
 		}
+		| DIVERT number				{
+			filter_opts.divert = $2;
+		}
 		| TAG string				{
 			filter_opts.tag = $2;
 		}
@@ -3333,6 +3350,15 @@
 			$$->next = NULL;
 			$$->tail = $$;
 		}
+		| MAXPCKT number                    	{
+                        $$ = calloc(1, sizeof(struct node_state_opt));
+                        if ($$ == NULL)
+                                err(1, "state_opt_item: calloc");
+                        $$->type = PF_STATE_OPT_MAX_PACKETS;
+                        $$->data.max_src_states = $2;
+                        $$->next = NULL;
+                        $$->tail = $$;
+                }
 		| MAXSRCCONN number			{
 			$$ = calloc(1, sizeof(struct node_state_opt));
 			if ($$ == NULL)
@@ -4005,6 +4031,10 @@
 		}
 		;
 
+divert		: /* empty */		{ $$ = 0; }
+		| DIVERT number		{ $$ = $2;   }
+		;
+
 tag		: /* empty */		{ $$ = NULL; }
 		| TAG STRING		{ $$ = $2; }
 		;
@@ -5102,6 +5132,7 @@
 		{ "code",		CODE},
 		{ "crop",		FRAGCROP},
 		{ "debug",		DEBUG},
+		{ "divert",             DIVERT},
 		{ "dnpipe",             DNPIPE},
                 { "dnqueue",            DNQUEUE},
 		{ "drop",		DROP},
@@ -5138,6 +5169,7 @@
 		{ "loginterface",	LOGINTERFACE},
 		{ "max",		MAXIMUM},
 		{ "max-mss",		MAXMSS},
+		{ "max-packets",	MAXPCKT},
 		{ "max-src-conn",	MAXSRCCONN},
 		{ "max-src-conn-rate",	MAXSRCCONNRATE},
 		{ "max-src-nodes",	MAXSRCNODES},
Index: contrib/pf/pfctl/pfctl_parser.c
===================================================================
RCS file: /root/freebsd/test/repoold/src/contrib/pf/pfctl/pfctl_parser.c,v
retrieving revision 1.3
diff -u -r1.3 pfctl_parser.c
--- contrib/pf/pfctl/pfctl_parser.c	15 Apr 2010 23:00:42 -0000	1.3
+++ contrib/pf/pfctl/pfctl_parser.c	15 Apr 2010 23:00:47 -0000
@@ -914,6 +914,12 @@
 			printf("max-src-conn %u", r->max_src_conn);
 			opts = 0;
 		}
+		if (r->spare1) {
+                        if (!opts)
+                                printf(", ");
+                        printf("max-packets %u", r->spare1);
+                        opts = 0;
+		}
 		if (r->max_src_conn_rate.limit) {
 			if (!opts)
 				printf(", ");
@@ -1003,6 +1009,8 @@
 		printf(" queue(%s, %s)", r->qname, r->pqname);
 	else if (r->qname[0])
 		printf(" queue %s", r->qname);
+	if (r->divert)
+		printf(" divert %u", r->divert);
 	if (r->tagname[0])
 		printf(" tag %s", r->tagname);
 	if (r->match_tagname[0]) {
Index: sys/contrib/pf/net/pf.c
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/contrib/pf/net/pf.c,v
retrieving revision 1.3
diff -u -r1.3 pf.c
--- sys/contrib/pf/net/pf.c	15 Apr 2010 23:00:42 -0000	1.3
+++ sys/contrib/pf/net/pf.c	15 Apr 2010 23:28:47 -0000
@@ -138,6 +138,7 @@
 #include <netinet/ip_fw.h>
 #include <netinet/ipfw/ip_fw_private.h>
 #include <netinet/ip_dummynet.h>
+#include <netinet/ip_divert.h>
 
 #include <netinet6/ip6_var.h>
 #include <netinet6/in6_pcb.h>
@@ -388,10 +389,23 @@
 #define PF_STATE_LOOP_BYPASS()							\
 	do {									\
 		r = (*state)->rule.ptr;						\
-        	if (r->dnpipe && (pd->pf_mtag->flags & PF_DN_TAG_PRESENT))	\
+		if ((r->dnpipe ||						\
+		    ((*state)->local_flags & PFSTATE_DIVERT_DNCOOKIE)) &&	\
+		    (pd->pf_mtag->flags & PF_DN_TAG_PRESENT))			\
+			return (PF_PASS);					\
+		else if (r->divert &&						\
+		    (pd->pf_mtag->flags & PF_DIVERT_TAG_PRESENT))		\
 			return (PF_PASS);					\
 	} while (0)
 
+#define PF_DIVERT_MAXPACKETS_REACHED()						\
+	do {
+		if (r->spare1 &&						\
+		    (*state)->packets[direction == PF_OUT] > r->spare1)		\
+			/* fake that divert already happened */			\
+			pd->pf_mtag->flags |= PF_DIVERT_TAG_PRESENT;		\
+	} while(0)
+
 struct pf_src_tree tree_src_tracking;
 
 struct pf_state_tree_id tree_id;
@@ -3717,7 +3731,7 @@
 	}
 
 #ifdef __FreeBSD__
-	if (r->dnpipe && rewrite) {
+	if ((r->divert || r->dnpipe) && rewrite) {
 		if (nr != NULL) {
                         if (direction == PF_OUT) {
                                 pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
@@ -4048,7 +4062,7 @@
 	}
 
 #ifdef __FreeBSD__
-        if (r->dnpipe && rewrite) {
+        if ((r->divert || r->dnpipe) && rewrite) {
 		/* undo NAT changes, if they have taken place */
                 if (nr != NULL) {
                         if (direction == PF_OUT) {
@@ -4667,7 +4681,7 @@
 
 #ifdef __FreeBSD__
 	/* Undo NAT changes if the packet will loop back. */
-	if (r->dnpipe && nr != NULL) {
+	if ((r->divert || r->dnpipe) && nr != NULL) {
 		if (direction == PF_OUT)
 			a = saddr;
 		else
@@ -5235,7 +5249,8 @@
          */
         if ((th->th_flags & TH_SYN) && src->state == TCPS_SYN_SENT &&
 		dst->state == TCPS_CLOSED) {
-		if (pd->pf_mtag->flags & PF_DN_TAG_PRESENT)
+		if ((pd->pf_mtag->flags & PF_DN_TAG_PRESENT) ||
+		    (pd->pf_mtag->flags & PF_DIVERT_TAG_PRESENT))
                 	goto tcpnatpas;
 	}
 
@@ -5398,6 +5413,8 @@
 		m_copyback(m, off, sizeof(*th), (caddr_t)th);
 	}
 
+	PF_DIVERT_MAXPACKETS_REACHED();
+
 	return (PF_PASS);
 }
 
@@ -5462,6 +5479,8 @@
 		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
 	}
 
+	PF_DIVERT_MAXPACKETS_REACHED();
+
 	return (PF_PASS);
 }
 
@@ -5595,6 +5614,8 @@
 			}
 		}
 
+		PF_DIVERT_MAXPACKETS_REACHED();
+
 		return (PF_PASS);
 
 	} else {
@@ -6139,6 +6160,8 @@
 			}
 	}
 
+	PF_DIVERT_MAXPACKETS_REACHED();
+
 	return (PF_PASS);
 }
 
@@ -7044,6 +7067,8 @@
 
 #ifdef __FreeBSD__
 	struct m_tag *dn_tag;
+	u_int16_t divertcookie = 0;
+        u_int8_t divflags = 0;
 	struct ip_fw_args	 dnflow;
 
 	PF_LOCK();
@@ -7116,14 +7141,17 @@
 		goto done;
 	}
 
-	if (ip_dn_io_ptr != NULL &&
-		((dn_tag = m_tag_find(m, MTAG_IPFW_RULE, NULL)) != NULL) &&
-		((struct ipfw_rule_ref *)(dn_tag+1))->rule_id == 0) {
+	if (((ip_dn_io_ptr != NULL) || (ip_divert_ptr != NULL)) &&
+		((dn_tag = m_tag_find(m, MTAG_IPFW_RULE, NULL)) != NULL)) {
+		struct ipfw_rule_ref *rr = (struct ipfw_rule_ref *)(dn_tag+1);
+		if (rr->info & IPFW_IS_DUMMYNET && rr->rule_id == 0)
+			pd.pf_mtag->flags |= PF_DN_TAG_PRESENT;
+		else if (rr->info & IPFW_IS_DIVERT)
+			pd.pf_mtag->flags |= PF_DN_TAG_PRESENT;
 		if (pd.pf_mtag->flags & PF_FASTFWD_OURS_PRESENT) {
-                        m->m_flags |= M_FASTFWD_OURS;
-                        pd.pf_mtag->flags &= ~PF_FASTFWD_OURS_PRESENT;
-                }
-		pd.pf_mtag->flags |= PF_DN_TAG_PRESENT;
+			m->m_flags |= M_FASTFWD_OURS;
+			pd.pf_mtag->flags &= ~PF_FASTFWD_OURS_PRESENT;
+		}
                 m_tag_delete(m, dn_tag);
         }
 
@@ -7318,6 +7346,18 @@
 		    ("pf: dropping packet with ip options\n"));
 	}
 
+#ifdef __FreeBSD__
+        if (s) {
+                if (divertcookie) {
+                        s->divert_cookie = divertcookie;
+                        s->local_flags |= divflags;
+                } else if (s->divert_cookie) {
+                        divertcookie = s->divert_cookie;
+                        divflags = s->local_flags;
+                }
+        }
+#endif
+
 	if ((s && s->tag) || r->rtableid)
 		pf_tag_packet(m, pd.pf_mtag, s ? s->tag : 0, r->rtableid);
 
@@ -7337,15 +7377,55 @@
 #endif /* ALTQ */
 
 #ifdef __FreeBSD__
-       	if (r->dnpipe && ip_dn_io_ptr != NULL &&
+        if (divflags & PFSTATE_DIVERT_TAG)
+                pd.pf_mtag->tag = divertcookie;
+        else if (divflags & PFSTATE_DIVERT_ALTQ)
+                pd.pf_mtag->qid = divertcookie;
+        else if (divflags & PFSTATE_DIVERT_ACTION) {
+                struct pf_rule *dlr;
+                action = PF_DROP;
+                REASON_SET(&reason, PFRES_DIVERT);
+                log = 1;
+                DPFPRINTF(PF_DEBUG_MISC,
+                        ("pf: changing action to with overload from divert.\n"));
+                dlr = r;
+                PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, dlr, a,
+                        ruleset, &pd);
+                PF_UNLOCK();
+                return (action);
+        }
+
+        if (r->divert && ip_divert_ptr != NULL &&
+	    (!(pd.pf_mtag->flags & PF_DIVERT_TAG_PRESENT) &&
+	    !(pd.pf_mtag->flags & PF_DN_TAG_PRESENT))) {
+                if (!r->spare1 ||
+                        (s && s->packets[dir == PF_OUT] <= r->spare1)) {
+
+                        dn_tag = m_tag_get(MTAG_IPFW_RULE,
+                                sizeof(struct ipfw_rule_ref), M_NOWAIT);
+                        if (dn_tag != NULL) {
+                                ((struct ipfw_rule_ref *)(dn_tag+1))->info = r->divert;
+                                ((struct ipfw_rule_ref *)(dn_tag+1))->rulenum = dir;
+                                
+                                m_tag_prepend(m, dn_tag);
+
+                                PF_UNLOCK();
+
+                                ip_divert_ptr(*m0,
+                                        dir ==  PF_IN ? DIR_IN : DIR_OUT);
+                                *m0 = NULL;
+                                return (action);
+                        }
+                }
+        } else if ((r->dnpipe || (divflags & PFSTATE_DIVERT_DNCOOKIE)) && ip_dn_io_ptr != NULL &&
                 !(pd.pf_mtag->flags & PF_DN_TAG_PRESENT)) {
 
-                        if (dir != r->direction && r->pdnpipe) {
-                                dnflow.rule.info = r->pdnpipe;
-                        } else if (dir == r->direction) {
-                                dnflow.rule.info = r->dnpipe;
-                        } else
-                                goto continueprocessing;
+			if (divflags & PFSTATE_DIVERT_DNCOOKIE) {
+				dnflow.rule.info = divertcookie;
+			} else if (r->pdnpipe && dir != r->direction)
+                               	dnflow.rule.info = r->pdnpipe;
+                        else
+                               	dnflow.rule.info = r->dnpipe;
 
 			if (r->free_flags & PFRULE_DN_IS_PIPE)
 				dnflow.rule.info |= IPFW_IS_PIPE;
@@ -7371,8 +7451,7 @@
                         *m0 = NULL;
                         return (action);
         } else
-		pd.pf_mtag->flags &= ~PF_DN_TAG_PRESENT;
-continueprocessing:
+		pd.pf_mtag->flags &= ~(PF_DN_TAG_PRESENT|PF_DIVERT_TAG_PRESENT);
 #endif
 
 	/*
@@ -7857,7 +7936,7 @@
 #endif /* ALTQ */
 
 #ifdef __FreeBSD__
-        if (r->dnpipe && ip_dn_io_ptr != NULL &&
+	if (r->dnpipe && ip_dn_io_ptr != NULL &&
                 !(pd.pf_mtag->flags & PF_DN_TAG_PRESENT)) {
 
 			if (dir != r->direction && r->pdnpipe) {
Index: sys/contrib/pf/net/pf_mtag.h
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/contrib/pf/net/pf_mtag.h,v
retrieving revision 1.3
diff -u -r1.3 pf_mtag.h
--- sys/contrib/pf/net/pf_mtag.h	15 Apr 2010 23:00:42 -0000	1.3
+++ sys/contrib/pf/net/pf_mtag.h	15 Apr 2010 23:00:47 -0000
@@ -39,6 +39,7 @@
 #define	PF_TAG_TRANSLATE_LOCALHOST	0x04
 #define PF_DN_TAG_PRESENT	        0x08
 #define PF_FASTFWD_OURS_PRESENT         0x10
+#define PF_DIVERT_TAG_PRESENT           0x20
 
 struct pf_mtag {
 	void		*hdr;		/* saved hdr pos in mbuf, for ECN */
Index: sys/contrib/pf/net/pfvar.h
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/contrib/pf/net/pfvar.h,v
retrieving revision 1.3
diff -u -r1.3 pfvar.h
--- sys/contrib/pf/net/pfvar.h	15 Apr 2010 23:00:42 -0000	1.3
+++ sys/contrib/pf/net/pfvar.h	15 Apr 2010 23:00:47 -0000
@@ -649,6 +649,7 @@
 	u_int16_t		 tag;
 	u_int16_t		 match_tag;
 	u_int16_t		 spare2;		/* netgraph */
+	u_int16_t		 divert;		/* divert */
 
 	struct pf_rule_uid	 uid;
 	struct pf_rule_gid	 gid;
@@ -830,7 +831,12 @@
 	u_int8_t	 direction;
 #ifdef __FreeBSD__
 	u_int8_t	 local_flags;
-#define	PFSTATE_EXPIRING 0x01
+#define	PFSTATE_EXPIRING 	0x01
+#define PFSTATE_DIVERT_ALTQ     0x10
+#define PFSTATE_DIVERT_DNCOOKIE 0x20
+#define PFSTATE_DIVERT_ACTION   0x40
+#define PFSTATE_DIVERT_TAG      0x80
+#define PFSTATE_DIVERT_MASK	0xFF00
 #else
 	u_int8_t	 pad;
 #endif
@@ -868,6 +874,7 @@
 	u_int32_t	 expire;
 	u_int32_t	 pfsync_time;
 	u_int16_t	 tag;
+	u_int16_t	 divert_cookie;
 };
 
 TAILQ_HEAD(pf_rulequeue, pf_rule);
@@ -1123,7 +1130,8 @@
 #define PFRES_MAXSTATES	12		/* State limit */
 #define PFRES_SRCLIMIT	13		/* Source node/conn limit */
 #define PFRES_SYNPROXY	14		/* SYN proxy */
-#define PFRES_MAX	15		/* total+1 */
+#define	PFRES_DIVERT	15		/* Divert override */
+#define PFRES_MAX	16		/* total+1 */
 
 #define PFRES_NAMES { \
 	"match", \
@@ -1141,6 +1149,7 @@
 	"state-limit", \
 	"src-limit", \
 	"synproxy", \
+	"divert", \
 	NULL \
 }
 
Index: sys/netinet/ip_divert.c
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/netinet/ip_divert.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 ip_divert.c
--- sys/netinet/ip_divert.c	15 Apr 2010 18:51:54 -0000	1.1.1.1
+++ sys/netinet/ip_divert.c	15 Apr 2010 23:00:47 -0000
@@ -815,5 +815,4 @@
 };
 
 DECLARE_MODULE(ipdivert, ipdivertmod, SI_SUB_PROTO_IFATTACHDOMAIN, SI_ORDER_ANY);
-MODULE_DEPEND(ipdivert, ipfw, 2, 2, 2);
 MODULE_VERSION(ipdivert, 1);
Index: sys/netinet/ipfw/ip_dummynet.c
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/netinet/ipfw/ip_dummynet.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 ip_dummynet.c
--- sys/netinet/ipfw/ip_dummynet.c	15 Apr 2010 18:51:55 -0000	1.1.1.1
+++ sys/netinet/ipfw/ip_dummynet.c	15 Apr 2010 23:00:47 -0000
@@ -2290,6 +2290,5 @@
 
 DECLARE_MODULE(dummynet, dummynet_mod,
 	SI_SUB_PROTO_IFATTACHDOMAIN, SI_ORDER_ANY-1);
-MODULE_DEPEND(dummynet, ipfw, 2, 2, 2);
 MODULE_VERSION(dummynet, 1);
 /* end of file */
