Index: sys/netinet/ip_carp.c
===================================================================
RCS file: /root/freebsd/repo/src/sys/netinet/ip_carp.c,v
retrieving revision 1.3
diff -u -r1.3 ip_carp.c
--- sys/netinet/ip_carp.c	28 Jan 2011 12:07:35 -0000	1.3
+++ sys/netinet/ip_carp.c	28 Jan 2011 12:43:14 -0000
@@ -156,23 +156,25 @@
 	int vhif_nvrs;
 
 	struct ifnet 	*vhif_ifp;
-	struct mtx	 vhif_mtx;
+	struct rwlock	 vhif_mtx;
 };
 
 /* Get carp_if from softc. Valid after carp_set_addr{,6}. */
 #define	SC2CIF(sc)		((struct carp_if *)(sc)->sc_carpdev->if_carp)
 
 /* lock per carp_if queue */
-#define	CARP_LOCK_INIT(cif)	mtx_init(&(cif)->vhif_mtx, "carp_if", 	\
-	NULL, MTX_DEF)
-#define	CARP_LOCK_DESTROY(cif)	mtx_destroy(&(cif)->vhif_mtx)
-#define	CARP_LOCK_ASSERT(cif)	mtx_assert(&(cif)->vhif_mtx, MA_OWNED)
-#define	CARP_LOCK(cif)		mtx_lock(&(cif)->vhif_mtx)
-#define	CARP_UNLOCK(cif)	mtx_unlock(&(cif)->vhif_mtx)
-
-#define	CARP_SCLOCK(sc)		mtx_lock(&SC2CIF(sc)->vhif_mtx)
-#define	CARP_SCUNLOCK(sc)	mtx_unlock(&SC2CIF(sc)->vhif_mtx)
-#define	CARP_SCLOCK_ASSERT(sc)	mtx_assert(&SC2CIF(sc)->vhif_mtx, MA_OWNED)
+#define	CARP_LOCK_INIT(cif)	rw_init_flags(&(cif)->vhif_mtx, "carp_if", 	\
+	MTX_DEF)
+#define	CARP_LOCK_DESTROY(cif)	rw_destroy(&(cif)->vhif_mtx)
+#define	CARP_LOCK_ASSERT(cif)	rw_assert(&(cif)->vhif_mtx, MA_OWNED)
+#define	CARP_RLOCK(cif)		rw_rlock(&(cif)->vhif_mtx)
+#define	CARP_RUNLOCK(cif)	rw_runlock(&(cif)->vhif_mtx)
+#define	CARP_WLOCK(cif)		rw_wlock(&(cif)->vhif_mtx)
+#define	CARP_WUNLOCK(cif)	rw_wunlock(&(cif)->vhif_mtx)
+
+#define	CARP_SCLOCK(sc)		rw_wlock(&SC2CIF(sc)->vhif_mtx)
+#define	CARP_SCUNLOCK(sc)	rw_wunlock(&SC2CIF(sc)->vhif_mtx)
+#define	CARP_SCLOCK_ASSERT(sc)	rw_assert(&SC2CIF(sc)->vhif_mtx, MA_OWNED)
 
 #define	CARP_LOG(...)	do {				\
 	if (carp_opts[CARPCTL_LOG] > 0)			\
@@ -499,10 +501,11 @@
 		if (!--cif->vhif_nvrs) {
 			ifpromisc(sc->sc_carpdev, 0);
 			sc->sc_carpdev->if_carp = NULL;
+			CARP_WUNLOCK(cif);
 			CARP_LOCK_DESTROY(cif);
 			//free(cif, M_CARP);
 		} else if (unlock)
-			CARP_UNLOCK(cif);
+			CARP_WUNLOCK(cif);
 		sc->sc_carpdev = NULL;
 	}
 }
@@ -520,7 +523,7 @@
 	/*
 	 * XXX: At the end of for() cycle the lock will be destroyed.
 	 */
-	CARP_LOCK(cif);
+	CARP_WLOCK(cif);
 	for (sc = TAILQ_FIRST(&cif->vhif_vrs); sc; sc = nextsc) {
 		nextsc = TAILQ_NEXT(sc, sc_list);
 		carpdetach(sc, 0);
@@ -693,7 +696,7 @@
 	struct timeval sc_tv, ch_tv;
 
 	/* verify that the VHID is valid on the receiving interface */
-	CARP_LOCK(ifp->if_carp);
+	CARP_WLOCK(ifp->if_carp);
 	TAILQ_FOREACH(sc, &((struct carp_if *)ifp->if_carp)->vhif_vrs, sc_list)
 		if (sc->sc_vhid == ch->carp_vhid)
 			break;
@@ -701,7 +704,7 @@
 	if (!sc || !((SC2IFP(sc)->if_flags & IFF_UP) &&
 	    (SC2IFP(sc)->if_drv_flags & IFF_DRV_RUNNING))) {
 		CARPSTATS_INC(carps_badvhid);
-		CARP_UNLOCK(ifp->if_carp);
+		CARP_WUNLOCK(ifp->if_carp);
 		m_freem(m);
 		return;
 	}
@@ -724,7 +727,7 @@
 	if (ch->carp_version != CARP_VERSION) {
 		CARPSTATS_INC(carps_badver);
 		SC2IFP(sc)->if_ierrors++;
-		CARP_UNLOCK(ifp->if_carp);
+		CARP_WUNLOCK(ifp->if_carp);
 		CARP_DEBUG("%s; invalid version %d\n",
 		    SC2IFP(sc)->if_xname,
 		    ch->carp_version);
@@ -736,7 +739,7 @@
 	if (carp_hmac_verify(sc, ch->carp_counter, ch->carp_md)) {
 		CARPSTATS_INC(carps_badauth);
 		SC2IFP(sc)->if_ierrors++;
-		CARP_UNLOCK(ifp->if_carp);
+		CARP_WUNLOCK(ifp->if_carp);
 		CARP_DEBUG("%s: incorrect hash\n", SC2IFP(sc)->if_xname);
 		m_freem(m);
 		return;
@@ -748,11 +751,11 @@
                 if (sc->sc_carpdev->if_flags & IFF_SIMPLEX) {
                         CARPSTATS_INC(carps_badauth);
                         SC2IFP(sc)->if_ierrors++;
-                        CARP_UNLOCK(ifp->if_carp);
+                        CARP_WUNLOCK(ifp->if_carp);
                         CARP_LOG("%s, replay or network loop detected.\n",
 				SC2IFP(sc)->if_xname);
                 } else
-                        CARP_UNLOCK(ifp->if_carp);
+                        CARP_WUNLOCK(ifp->if_carp);
                 m_freem(m);
                 return;
         }
@@ -820,7 +823,7 @@
 		break;
 	}
 
-	CARP_UNLOCK(ifp->if_carp);
+	CARP_WUNLOCK(ifp->if_carp);
 
 	m_freem(m);
 	return;
@@ -968,7 +971,9 @@
 		SC2IFP(sc)->if_obytes += len;
 		CARPSTATS_INC(carps_opackets);
 
+		CARP_SCUNLOCK(sc);
 		if (ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL)) {
+			CARP_SCLOCK(sc);
 			SC2IFP(sc)->if_oerrors++;
 			if (sc->sc_sendad_errors < INT_MAX)
 				sc->sc_sendad_errors++;
@@ -982,6 +987,7 @@
 			}
 			sc->sc_sendad_success = 0;
 		} else {
+			CARP_SCLOCK(sc);
 			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS) {
 				if (++sc->sc_sendad_success >=
 				    CARP_SENDAD_MIN_SUCCESS) {
@@ -1045,7 +1051,9 @@
 		SC2IFP(sc)->if_obytes += len;
 		CARPSTATS_INC(carps_opackets6);
 
+		CARP_SCUNLOCK(sc);
 		if (ip6_output(m, NULL, NULL, 0, &sc->sc_im6o, NULL, NULL)) {
+			CARP_SCLOCK(sc);
 			SC2IFP(sc)->if_oerrors++;
 			if (sc->sc_sendad_errors < INT_MAX)
 				sc->sc_sendad_errors++;
@@ -1059,6 +1067,7 @@
 			}
 			sc->sc_sendad_success = 0;
 		} else {
+			CARP_SCLOCK(sc);
 			if (sc->sc_sendad_errors >= CARP_SENDAD_MAX_ERRORS) {
 				if (++sc->sc_sendad_success >=
 				    CARP_SENDAD_MIN_SUCCESS) {
@@ -1157,7 +1166,7 @@
 	int index, count = 0;
 	struct ifaddr *ifa;
 
-	CARP_LOCK(cif);
+	CARP_RLOCK(cif);
 
 	if (carp_opts[CARPCTL_ARPBALANCE]) {
 		/*
@@ -1170,7 +1179,7 @@
 		count = carp_addrcount(cif, ia, CARP_COUNT_RUNNING);
 		if (count == 0) {
 			/* should never reach this */
-			CARP_UNLOCK(cif);
+			CARP_RUNLOCK(cif);
 			return (0);
 		}
 
@@ -1193,11 +1202,11 @@
 							    MASTER) {
 								*enaddr = IF_LLADDR(vh->sc_ifp);
 								IF_ADDR_UNLOCK(SC2IFP(vh));
-								CARP_UNLOCK(cif);
+								CARP_RUNLOCK(cif);
 								return (1);
 							} else {
 								IF_ADDR_UNLOCK(SC2IFP(vh));
-								CARP_UNLOCK(cif);
+								CARP_RUNLOCK(cif);
 								return (0);
 							}
 						}
@@ -1214,12 +1223,12 @@
 			    ia->ia_ifp == SC2IFP(vh) &&
 			    vh->sc_state == MASTER) {
 				*enaddr = IF_LLADDR(vh->sc_ifp);
-				CARP_UNLOCK(cif);
+				CARP_RUNLOCK(cif);
 				return (1);
 			}
 		}
 	}
-	CARP_UNLOCK(cif);
+	CARP_RUNLOCK(cif);
 	return (0);
 }
 
@@ -1231,7 +1240,7 @@
 	struct carp_softc *vh;
 	struct ifaddr *ifa;
 
-	CARP_LOCK(cif);
+	CARP_RLOCK(cif);
 	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list) {
 		IF_ADDR_LOCK(SC2IFP(vh));
 		TAILQ_FOREACH(ifa, &SC2IFP(vh)->if_addrlist, ifa_list) {
@@ -1242,13 +1251,13 @@
 			    vh->sc_state == MASTER) {
 				ifa_ref(ifa);
 				IF_ADDR_UNLOCK(SC2IFP(vh));
-			    	CARP_UNLOCK(cif);
+			    	CARP_RUNLOCK(cif);
 				return (ifa);
 			}
 		}
 		IF_ADDR_UNLOCK(SC2IFP(vh));
 	}
-	CARP_UNLOCK(cif);
+	CARP_RUNLOCK(cif);
 	
 	return (NULL);
 }
@@ -1261,7 +1270,7 @@
 	struct carp_softc *sc;
 	struct ifaddr *ifa;
 
-	CARP_LOCK(cif);
+	CARP_RLOCK(cif);
 	TAILQ_FOREACH(sc, &cif->vhif_vrs, sc_list) {
 		IF_ADDR_LOCK(SC2IFP(sc));
 		TAILQ_FOREACH(ifa, &SC2IFP(sc)->if_addrlist, ifa_list) {
@@ -1275,7 +1284,7 @@
 				if (mtag == NULL) {
 					/* better a bit than nothing */
 					IF_ADDR_UNLOCK(SC2IFP(sc));
-					CARP_UNLOCK(cif);
+					CARP_RUNLOCK(cif);
 					return (IF_LLADDR(sc->sc_ifp));
 				}
 				bcopy(&ifp, (caddr_t)(mtag + 1),
@@ -1283,13 +1292,13 @@
 				m_tag_prepend(m, mtag);
 
 				IF_ADDR_UNLOCK(SC2IFP(sc));
-				CARP_UNLOCK(cif);
+				CARP_RUNLOCK(cif);
 				return (IF_LLADDR(sc->sc_ifp));
 			}
 		}
 		IF_ADDR_UNLOCK(SC2IFP(sc));
 	}
-	CARP_UNLOCK(cif);
+	CARP_RUNLOCK(cif);
 
 	return (NULL);
 }
@@ -1305,17 +1314,17 @@
 	if (ena[0] || ena[1] || ena[2] != 0x5e || ena[3] || ena[4] != 1)
 		return (NULL);
 
-	CARP_LOCK(cif);
+	CARP_RLOCK(cif);
 	TAILQ_FOREACH(vh, &cif->vhif_vrs, sc_list)
 		if ((SC2IFP(vh)->if_flags & IFF_UP) &&
 		    (SC2IFP(vh)->if_drv_flags & IFF_DRV_RUNNING) &&
 		    vh->sc_state == MASTER &&
 		    !bcmp(dhost, IF_LLADDR(vh->sc_ifp), ETHER_ADDR_LEN)) {
-		    	CARP_UNLOCK(cif);
+		    	CARP_RUNLOCK(cif);
 			return (SC2IFP(vh));
 		}
 
-    	CARP_UNLOCK(cif);
+    	CARP_RUNLOCK(cif);
 	return (NULL);
 }
 
@@ -1558,7 +1567,7 @@
 		}
 		
 		CARP_LOCK_INIT(cif);
-		CARP_LOCK(cif);
+		CARP_WLOCK(cif);
 		cif->vhif_ifp = ifp;
 		TAILQ_INIT(&cif->vhif_vrs);
 		ifp->if_carp = cif;
@@ -1567,10 +1576,10 @@
 		struct carp_softc *vr;
 
 		cif = (struct carp_if *)ifp->if_carp;
-		CARP_LOCK(cif);
+		CARP_WLOCK(cif);
 		TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list)
 			if (vr != sc && vr->sc_vhid == sc->sc_vhid) {
-				CARP_UNLOCK(cif);
+				CARP_WUNLOCK(cif);
 				error = EEXIST;
 				goto cleanup;
 			}
@@ -1611,7 +1620,7 @@
 	carp_sc_state_locked(sc);
 	carp_setrun(sc, 0);
 
-	CARP_UNLOCK(cif);
+	CARP_WUNLOCK(cif);
 	ifa_free(&ia->ia_ifa);	/* XXXRW: should hold reference for softc. */
 
 	return (0);
@@ -1631,7 +1640,7 @@
 		struct carp_if *cif = (struct carp_if *)sc->sc_carpdev->if_carp;
 		struct ip_moptions *imo = &sc->sc_imo;
 
-		CARP_LOCK(cif);
+		CARP_WLOCK(cif);
 		callout_stop(&sc->sc_ad_tmo);
 		SC2IFP(sc)->if_flags &= ~IFF_UP;
 		SC2IFP(sc)->if_drv_flags &= ~IFF_DRV_RUNNING;
@@ -1641,10 +1650,11 @@
 		TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
 		if (!--cif->vhif_nvrs) {
 			sc->sc_carpdev->if_carp = NULL;
+			CARP_WUNLOCK(cif);
 			CARP_LOCK_DESTROY(cif);
 			free(cif, M_CARP);
 		} else {
-			CARP_UNLOCK(cif);
+			CARP_WUNLOCK(cif);
 		}
 	}
 
@@ -1765,7 +1775,7 @@
 		}
 
 		CARP_LOCK_INIT(cif);
-		CARP_LOCK(cif);
+		CARP_WLOCK(cif);
 		cif->vhif_ifp = ifp;
 		TAILQ_INIT(&cif->vhif_vrs);
 		ifp->if_carp = cif;
@@ -1774,10 +1784,10 @@
 		struct carp_softc *vr;
 
 		cif = (struct carp_if *)ifp->if_carp;
-		CARP_LOCK(cif);
+		CARP_WLOCK(cif);
 		TAILQ_FOREACH(vr, &cif->vhif_vrs, sc_list)
 			if (vr != sc && vr->sc_vhid == sc->sc_vhid) {
-				CARP_UNLOCK(cif);
+				CARP_WUNLOCK(cif);
 				error = EINVAL;
 				goto cleanup;
 			}
@@ -1816,7 +1826,7 @@
 	carp_sc_state_locked(sc);
 	carp_setrun(sc, 0);
 
-	CARP_UNLOCK(cif);
+	CARP_WUNLOCK(cif);
 	ifa_free(&ia->ia_ifa);	/* XXXRW: should hold reference for softc. */
 
 	return (0);
@@ -1836,7 +1846,7 @@
 	if (!--sc->sc_naddrs6) {
 		struct carp_if *cif = (struct carp_if *)sc->sc_carpdev->if_carp;
 
-		CARP_LOCK(cif);
+		CARP_WLOCK(cif);
 		callout_stop(&sc->sc_ad_tmo);
 		SC2IFP(sc)->if_flags &= ~IFF_UP;
 		SC2IFP(sc)->if_drv_flags &= ~IFF_DRV_RUNNING;
@@ -1844,11 +1854,12 @@
 		carp_multicast6_cleanup(sc);
 		TAILQ_REMOVE(&cif->vhif_vrs, sc, sc_list);
 		if (!--cif->vhif_nvrs) {
+			CARP_WUNLOCK(cif);
 			CARP_LOCK_DESTROY(cif);
 			sc->sc_carpdev->if_carp = NULL;
 			free(cif, M_CARP);
 		} else
-			CARP_UNLOCK(cif);
+			CARP_WUNLOCK(cif);
 	}
 
 	return (error);
@@ -2043,7 +2054,7 @@
 		error = EINVAL;
 	}
 
-	if (locked)
+	if (locked && sc->sc_carpdev)
 		CARP_SCUNLOCK(sc);
 
 	carp_hmac_prepare(sc);
@@ -2216,9 +2227,9 @@
 {
 	struct carp_if *cif = v;
 
-	CARP_LOCK(cif);
+	CARP_WLOCK(cif);
 	carp_carpdev_state_locked(cif);
-	CARP_UNLOCK(cif);
+	CARP_WUNLOCK(cif);
 }
 
 static void
