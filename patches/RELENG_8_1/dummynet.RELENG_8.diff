Index: contrib/pf/pfctl/parse.y
===================================================================
RCS file: /root/freebsd/test/repoold/src/contrib/pf/pfctl/parse.y,v
retrieving revision 1.2
diff -u -r1.2 parse.y
--- contrib/pf/pfctl/parse.y	15 Apr 2010 18:53:16 -0000	1.2
+++ contrib/pf/pfctl/parse.y	15 Apr 2010 21:41:16 -0000
@@ -32,6 +32,7 @@
 
 #include <sys/types.h>
 #include <sys/socket.h>
+#include <sys/sysctl.h>
 #include <net/if.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
@@ -209,6 +210,9 @@
 	char			*tag;
 	char			*match_tag;
 	u_int8_t		 match_tag_not;
+	u_int32_t		 dnpipe;
+	u_int32_t		 pdnpipe;
+	u_int32_t		 free_flags;
 	int			 rtableid;
 } filter_opts;
 
@@ -426,6 +430,7 @@
 %token	BITMASK RANDOM SOURCEHASH ROUNDROBIN STATICPORT PROBABILITY
 %token	ALTQ CBQ PRIQ HFSC FAIRQ BANDWIDTH TBRSIZE LINKSHARE REALTIME UPPERLIMIT
 %token	QUEUE PRIORITY QLIMIT HOGS BUCKETS RTABLE
+%token  DNPIPE DNQUEUE 
 %token	LOAD RULESET_OPTIMIZATION
 %token	STICKYADDRESS MAXSRCSTATES MAXSRCNODES SOURCETRACK GLOBAL RULE
 %token	MAXSRCCONN MAXSRCCONNRATE OVERLOAD FLUSH SLOPPY
@@ -1447,14 +1452,22 @@
 
 			bps = strtod($1, &cp);
 			if (cp != NULL) {
-				if (!strcmp(cp, "b"))
+				if (!strcmp(cp, "b") || !strcmp(cp, "bit"))
 					; /* nothing */
-				else if (!strcmp(cp, "Kb"))
+				else if (!strcmp(cp, "Kb") || !strcmp(cp, "Kbit"))
 					bps *= 1000;
-				else if (!strcmp(cp, "Mb"))
+				else if (!strcmp(cp, "Mb") || !strcmp(cp, "Mbit"))
 					bps *= 1000 * 1000;
-				else if (!strcmp(cp, "Gb"))
+				else if (!strcmp(cp, "Gb") || !strcmp(cp, "Gbit"))
 					bps *= 1000 * 1000 * 1000;
+				else if (!strcmp(cp, "B") || !strcmp(cp, "Byte"))
+					; /* nothing */
+				else if (!strcmp(cp, "KB") || !strcmp(cp, "Kbyte"))
+					bps *= 1024;
+				else if (!strcmp(cp, "MB") || !strcmp(cp, "Mbyte"))
+					bps *= 1024 * 1024;
+				else if (!strcmp(cp, "GB") || !strcmp(cp, "Gbyte"))
+					bps *= 1024 * 1024 * 1024;
 				else if (!strcmp(cp, "%")) {
 					if (bps < 0 || bps > 100) {
 						yyerror("bandwidth spec "
@@ -2113,6 +2126,15 @@
 				free($9.queues.pqname);
 			}
 
+			if ($9.dnpipe) {
+                                r.dnpipe = $9.dnpipe;
+				if ($9.free_flags & PFRULE_DN_IS_PIPE)
+					r.free_flags |= PFRULE_DN_IS_PIPE;
+				else
+					r.free_flags |= PFRULE_DN_IS_QUEUE;
+				r.pdnpipe = $9.pdnpipe;
+			}
+
 			expand_rule(&r, $4, $5.host, $7, $8.src_os,
 			    $8.src.host, $8.src.port, $8.dst.host, $8.dst.port,
 			    $9.uid, $9.gid, $9.icmpspec, "");
@@ -2210,6 +2232,32 @@
 			}
 			filter_opts.queues = $1;
 		}
+		| DNPIPE number			        {
+			filter_opts.dnpipe = $2;
+			filter_opts.free_flags |= PFRULE_DN_IS_PIPE;
+		}
+		| DNPIPE '(' number ')'			{
+			filter_opts.dnpipe = $3;
+			filter_opts.free_flags |= PFRULE_DN_IS_PIPE;
+		}
+		| DNPIPE '(' number comma number ')' {
+			filter_opts.pdnpipe = $5;
+			filter_opts.dnpipe = $3;
+			filter_opts.free_flags |= PFRULE_DN_IS_PIPE;
+		}
+		| DNQUEUE number			{
+			filter_opts.dnpipe = $2;
+			filter_opts.free_flags |= PFRULE_DN_IS_QUEUE;
+		}
+		| DNQUEUE '(' number comma number ')'	{
+			filter_opts.pdnpipe = $5;
+			filter_opts.dnpipe = $3;
+			filter_opts.free_flags |= PFRULE_DN_IS_QUEUE;
+		}
+		| DNQUEUE '(' number ')'		{
+			filter_opts.dnpipe = $3;
+			filter_opts.free_flags |= PFRULE_DN_IS_QUEUE;
+		}
 		| TAG string				{
 			filter_opts.tag = $2;
 		}
@@ -4253,6 +4301,15 @@
 		yyerror("tos and dscp cannot be used together");
 		problems++;
 	}
+	if (r->dnpipe && r->pdnpipe && !r->direction) {
+		yyerror("dummynet cannot be specified without direction");
+		problems++;
+	}
+	if (r->dnpipe && !r->keep_state) {
+		yyerror("dummynet cannot be specified withtout keep state");
+		problems++;
+	}
+
 	return (-problems);
 }
 
@@ -5045,6 +5102,8 @@
 		{ "code",		CODE},
 		{ "crop",		FRAGCROP},
 		{ "debug",		DEBUG},
+		{ "dnpipe",             DNPIPE},
+                { "dnqueue",            DNQUEUE},
 		{ "drop",		DROP},
 		{ "drop-ovl",		FRAGDROP},
 		{ "dscp",		DSCP},
Index: contrib/pf/pfctl/pfctl_parser.c
===================================================================
RCS file: /root/freebsd/test/repoold/src/contrib/pf/pfctl/pfctl_parser.c,v
retrieving revision 1.2
diff -u -r1.2 pfctl_parser.c
--- contrib/pf/pfctl/pfctl_parser.c	15 Apr 2010 18:53:16 -0000	1.2
+++ contrib/pf/pfctl/pfctl_parser.c	15 Apr 2010 21:41:16 -0000
@@ -991,6 +991,14 @@
 	}
 	if (r->label[0])
 		printf(" label \"%s\"", r->label);
+	if (r->dnpipe && r->pdnpipe)
+	       printf(" %s(%d, %d)", 
+			r->free_flags & PFRULE_DN_IS_PIPE ? "dnpipe" : "dnqueue",
+			r->dnpipe, r->pdnpipe);
+	else if (r->dnpipe)	
+		printf(" %s %d", 
+			r->free_flags & PFRULE_DN_IS_PIPE ? "dnpipe" : "dnqueue",
+			r->dnpipe);
 	if (r->qname[0] && r->pqname[0])
 		printf(" queue(%s, %s)", r->qname, r->pqname);
 	else if (r->qname[0])
Index: sys/contrib/pf/net/pf.c
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/contrib/pf/net/pf.c,v
retrieving revision 1.2
diff -u -r1.2 pf.c
--- sys/contrib/pf/net/pf.c	15 Apr 2010 18:53:16 -0000	1.2
+++ sys/contrib/pf/net/pf.c	15 Apr 2010 22:58:32 -0000
@@ -135,6 +135,10 @@
 #include <netinet/icmp6.h>
 #include <netinet6/nd6.h>
 #ifdef __FreeBSD__
+#include <netinet/ip_fw.h>
+#include <netinet/ipfw/ip_fw_private.h>
+#include <netinet/ip_dummynet.h>
+
 #include <netinet6/ip6_var.h>
 #include <netinet6/in6_pcb.h>
 #endif
@@ -381,6 +385,13 @@
 		s->rule.ptr->states--;			\
 	} while (0)
 
+#define PF_STATE_LOOP_BYPASS()							\
+	do {									\
+		r = (*state)->rule.ptr;						\
+        	if (r->dnpipe && (pd->pf_mtag->flags & PF_DN_TAG_PRESENT))	\
+			return (PF_PASS);					\
+	} while (0)
+
 struct pf_src_tree tree_src_tracking;
 
 struct pf_state_tree_id tree_id;
@@ -3705,6 +3716,21 @@
 		}
 	}
 
+#ifdef __FreeBSD__
+	if (r->dnpipe && rewrite) {
+		if (nr != NULL) {
+                        if (direction == PF_OUT) {
+                                pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
+                                    &th->th_sum, &pd->baddr, bport, 0, af);
+                                rewrite++;
+                        } else {
+                                pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
+                                    &th->th_sum, &pd->baddr, bport, 0, af);
+                                rewrite++;
+                        }
+                }
+	}
+#endif
 	/* copy back packet headers if we performed NAT operations */
 	if (rewrite)
 		m_copyback(m, off, sizeof(*th), (caddr_t)th);
@@ -4021,6 +4047,22 @@
 		}
 	}
 
+#ifdef __FreeBSD__
+        if (r->dnpipe && rewrite) {
+		/* undo NAT changes, if they have taken place */
+                if (nr != NULL) {
+                        if (direction == PF_OUT) {
+                                pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
+                                    &uh->uh_sum, &pd->baddr, bport, 1, af);
+                                rewrite++;
+                        } else {
+                                pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
+                                    &uh->uh_sum, &pd->baddr, bport, 1, af);
+                                rewrite++;
+                        }
+                }
+	}
+#endif
 	/* copy back packet headers if we performed NAT operations */
 	if (rewrite)
 		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
@@ -4623,6 +4665,30 @@
 		}
 	}
 
+#ifdef __FreeBSD__
+	/* Undo NAT changes if the packet will loop back. */
+	if (r->dnpipe && nr != NULL) {
+		if (direction == PF_OUT)
+			a = saddr;
+		else
+			a = daddr;
+		if (a != NULL) {
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&a->v4.s_addr, pd->ip_sum,
+				    pd->baddr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				PF_ACPY(a, &pd->baddr, af);
+				break;
+#endif /* INET6 */
+			}
+		}
+	}
+#endif
 	return (PF_PASS);
 }
 
@@ -5142,6 +5208,7 @@
     u_short *reason)
 {
 	struct pf_state_cmp	 key;
+	struct pf_rule          *r = NULL;
 	struct tcphdr		*th = pd->hdr.tcp;
 	int			 copyback = 0;
 	struct pf_state_peer	*src, *dst;
@@ -5162,6 +5229,18 @@
 
 	STATE_LOOKUP();
 
+	/*
+         * First state is created by the rules checking code and if we reloop
+         * the first packet that hit the rule pf will not like it.
+         */
+        if ((th->th_flags & TH_SYN) && src->state == TCPS_SYN_SENT &&
+		dst->state == TCPS_CLOSED) {
+		if (pd->pf_mtag->flags & PF_DN_TAG_PRESENT)
+                	goto tcpnatpas;
+	}
+
+	PF_STATE_LOOP_BYPASS();
+
 	if (direction == (*state)->direction) {
 		src = &(*state)->src;
 		dst = &(*state)->dst;
@@ -5169,7 +5248,7 @@
 		src = &(*state)->dst;
 		dst = &(*state)->src;
 	}
-
+	
 	if ((*state)->src.state == PF_TCPS_PROXY_SRC) {
 		if (direction != (*state)->direction) {
 			REASON_SET(reason, PFRES_SYNPROXY);
@@ -5302,6 +5381,7 @@
 			return (PF_DROP);
 	}
 
+tcpnatpas:
 	/* translate source/destination address, if necessary */
 	if (STATE_TRANSLATE(*state)) {
 		if (direction == PF_OUT)
@@ -5327,6 +5407,7 @@
 {
 	struct pf_state_peer	*src, *dst;
 	struct pf_state_cmp	 key;
+	struct pf_rule		*r;
 	struct udphdr		*uh = pd->hdr.udp;
 
 	key.af = pd->af;
@@ -5345,6 +5426,8 @@
 
 	STATE_LOOKUP();
 
+	PF_STATE_LOOP_BYPASS();
+
 	if (direction == (*state)->direction) {
 		src = &(*state)->src;
 		dst = &(*state)->dst;
@@ -5387,6 +5470,7 @@
     struct mbuf *m, int off, void *h, struct pf_pdesc *pd, u_short *reason)
 {
 	struct pf_addr	*saddr = pd->src, *daddr = pd->dst;
+	struct pf_rule          *r;
 	u_int16_t	 icmpid = 0;		/* make the compiler happy */
 	u_int16_t	*icmpsum = NULL;	/* make the compiler happy */
 	u_int8_t	 icmptype = 0;		/* make the compiler happy */
@@ -5445,6 +5529,8 @@
 
 		STATE_LOOKUP();
 
+		PF_STATE_LOOP_BYPASS();
+
 		(*state)->expire = time_second;
 		(*state)->timeout = PFTM_ICMP_ERROR_REPLY;
 
@@ -5978,6 +6064,7 @@
 {
 	struct pf_state_peer	*src, *dst;
 	struct pf_state_cmp	 key;
+	struct pf_rule          *r;
 
 	key.af = pd->af;
 	key.proto = pd->proto;
@@ -5995,6 +6082,8 @@
 
 	STATE_LOOKUP();
 
+	PF_STATE_LOOP_BYPASS();
+
 	if (direction == (*state)->direction) {
 		src = &(*state)->src;
 		dst = &(*state)->dst;
@@ -6954,6 +7043,9 @@
 	int			 off, dirndx, pqid = 0;
 
 #ifdef __FreeBSD__
+	struct m_tag *dn_tag;
+	struct ip_fw_args	 dnflow;
+
 	PF_LOCK();
 #endif
 	if (!pf_status.running)
@@ -7024,8 +7116,19 @@
 		goto done;
 	}
 
+	if (ip_dn_io_ptr != NULL &&
+		((dn_tag = m_tag_find(m, MTAG_IPFW_RULE, NULL)) != NULL) &&
+		((struct ipfw_rule_ref *)(dn_tag+1))->rule_id == 0) {
+		if (pd.pf_mtag->flags & PF_FASTFWD_OURS_PRESENT) {
+                        m->m_flags |= M_FASTFWD_OURS;
+                        pd.pf_mtag->flags &= ~PF_FASTFWD_OURS_PRESENT;
+                }
+		pd.pf_mtag->flags |= PF_DN_TAG_PRESENT;
+                m_tag_delete(m, dn_tag);
+        }
+
 	/* We do IP header normalization and packet reassembly here */
-	if (pf_normalize_ip(m0, dir, kif, &reason, &pd) != PF_PASS) {
+	else if (pf_normalize_ip(m0, dir, kif, &reason, &pd) != PF_PASS) {
 		action = PF_DROP;
 		goto done;
 	}
@@ -7063,6 +7166,11 @@
 		struct tcphdr	th;
 
 		pd.hdr.tcp = &th;
+#ifdef __FreeBSD__
+                dnflow.f_id._flags = th.th_flags;
+                dnflow.f_id.dst_port = ntohs(th.th_dport);
+                dnflow.f_id.src_port = ntohs(th.th_sport);
+#endif
 		if (!pf_pull_hdr(m, off, &th, sizeof(th),
 		    &action, &reason, AF_INET)) {
 			log = action != PF_PASS;
@@ -7104,6 +7212,10 @@
 		struct udphdr	uh;
 
 		pd.hdr.udp = &uh;
+#ifdef __FreeBSD__
+                dnflow.f_id.dst_port = ntohs(uh.uh_dport);
+                dnflow.f_id.src_port = ntohs(uh.uh_sport);
+#endif
 		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
 		    &action, &reason, AF_INET)) {
 			log = action != PF_PASS;
@@ -7224,6 +7336,45 @@
 	}
 #endif /* ALTQ */
 
+#ifdef __FreeBSD__
+       	if (r->dnpipe && ip_dn_io_ptr != NULL &&
+                !(pd.pf_mtag->flags & PF_DN_TAG_PRESENT)) {
+
+                        if (dir != r->direction && r->pdnpipe) {
+                                dnflow.rule.info = r->pdnpipe;
+                        } else if (dir == r->direction) {
+                                dnflow.rule.info = r->dnpipe;
+                        } else
+                                goto continueprocessing;
+
+			if (r->free_flags & PFRULE_DN_IS_PIPE)
+				dnflow.rule.info |= IPFW_IS_PIPE;
+                        dnflow.f_id.addr_type = 4; /* IPv4 type */
+                        dnflow.f_id.proto = pd.proto;
+			dnflow.f_id.src_ip = ntohl(h->ip_src.s_addr);
+			dnflow.f_id.dst_ip = ntohl(h->ip_dst.s_addr);
+			dnflow.f_id.extra = dnflow.rule.info;
+
+			if (m->m_flags & M_FASTFWD_OURS) {
+                                pd.pf_mtag->flags |= PF_FASTFWD_OURS_PRESENT;
+                                m->m_flags &= ~M_FASTFWD_OURS;
+                        }
+
+                        PF_UNLOCK();
+
+                        h = mtod(*m0, struct ip *);
+                        NTOHS(h->ip_len);
+                        NTOHS(h->ip_off);
+                        ip_dn_io_ptr(m0,
+				(dir == PF_IN) ? DIR_IN : DIR_OUT,
+                                &dnflow);
+                        *m0 = NULL;
+                        return (action);
+        } else
+		pd.pf_mtag->flags &= ~PF_DN_TAG_PRESENT;
+continueprocessing:
+#endif
+
 	/*
 	 * connections redirected to loopback should not match sockets
 	 * bound specifically to loopback due to security implications,
@@ -7312,7 +7463,6 @@
 			    tr->dst.neg);
 	}
 
-
 	if (action == PF_SYNPROXY_DROP) {
 		m_freem(*m0);
 		*m0 = NULL;
@@ -7350,6 +7500,9 @@
 	int			 off, terminal = 0, dirndx, rh_cnt = 0;
 
 #ifdef __FreeBSD__
+	struct m_tag *dn_tag;
+	struct ip_fw_args	 dnflow;
+
 	PF_LOCK();
 #endif
 
@@ -7417,9 +7570,16 @@
 		log = 1;
 		goto done;
 	}
+	
+	if (ip_dn_io_ptr != NULL &&
+                ((dn_tag = m_tag_find(m, MTAG_IPFW_RULE, NULL)) != NULL) &&
+                ((struct ipfw_rule_ref *)(dn_tag+1))->rule_id == 0) {
+                pd.pf_mtag->flags |= PF_DN_TAG_PRESENT;
+                m_tag_delete(m, dn_tag);
+        }
 
 	/* We do IP header normalization and packet reassembly here */
-	if (pf_normalize_ip6(m0, dir, kif, &reason, &pd) != PF_PASS) {
+	else if (pf_normalize_ip6(m0, dir, kif, &reason, &pd) != PF_PASS) {
 		action = PF_DROP;
 		goto done;
 	}
@@ -7525,6 +7685,11 @@
 		struct tcphdr	th;
 
 		pd.hdr.tcp = &th;
+#ifdef __FreeBSD__
+                dnflow.f_id._flags = th.th_flags;
+                dnflow.f_id.dst_port = th.th_dport;
+                dnflow.f_id.src_port = th.th_sport;
+#endif
 		if (!pf_pull_hdr(m, off, &th, sizeof(th),
 		    &action, &reason, AF_INET6)) {
 			log = action != PF_PASS;
@@ -7565,6 +7730,10 @@
 		struct udphdr	uh;
 
 		pd.hdr.udp = &uh;
+#ifdef __FreeBSD__
+                dnflow.f_id.dst_port = uh.uh_dport;
+                dnflow.f_id.src_port = uh.uh_sport;
+#endif
 		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
 		    &action, &reason, AF_INET6)) {
 			log = action != PF_PASS;
@@ -7687,6 +7856,39 @@
 	}
 #endif /* ALTQ */
 
+#ifdef __FreeBSD__
+        if (r->dnpipe && ip_dn_io_ptr != NULL &&
+                !(pd.pf_mtag->flags & PF_DN_TAG_PRESENT)) {
+
+			if (dir != r->direction && r->pdnpipe) {
+                                dnflow.rule.info = r->pdnpipe;
+                        } else if (dir == r->direction) {
+                                dnflow.rule.info = r->dnpipe;
+                        } else
+                                goto continueprocessing;
+
+                        if (r->free_flags & PFRULE_DN_IS_PIPE)
+                                dnflow.rule.info |= IPFW_IS_PIPE;
+                        dnflow.f_id.addr_type = 6; /* IPv4 type */
+                        dnflow.f_id.proto = pd.proto;
+			dnflow.f_id.src_ip6 = h->ip6_src;
+                        dnflow.f_id.dst_ip6 = h->ip6_dst;
+			dnflow.f_id.src_ip = 0;
+			dnflow.f_id.dst_ip = 0;
+			dnflow.f_id.flow_id6 = ntohl(h->ip6_flow);
+			dnflow.f_id.extra = dnflow.rule.info;
+
+                        PF_UNLOCK();
+
+                        ip_dn_io_ptr(m0,
+                                dir == PF_IN ? DIR_IN : DIR_OUT,
+                                &dnflow);
+                        *m0 = NULL;
+                        return (action);
+        }
+continueprocessing:
+#endif
+
 	if (dir == PF_IN && action == PF_PASS && (pd.proto == IPPROTO_TCP ||
 	    pd.proto == IPPROTO_UDP) && s != NULL && s->nat_rule.ptr != NULL &&
 	    (s->nat_rule.ptr->action == PF_RDR ||
@@ -7770,7 +7972,6 @@
 			    tr->dst.neg);
 	}
 
-
 	if (action == PF_SYNPROXY_DROP) {
 		m_freem(*m0);
 		*m0 = NULL;
Index: sys/contrib/pf/net/pf_mtag.h
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/contrib/pf/net/pf_mtag.h,v
retrieving revision 1.2
diff -u -r1.2 pf_mtag.h
--- sys/contrib/pf/net/pf_mtag.h	15 Apr 2010 18:53:16 -0000	1.2
+++ sys/contrib/pf/net/pf_mtag.h	15 Apr 2010 21:41:16 -0000
@@ -37,6 +37,8 @@
 #define	PF_TAG_GENERATED		0x01
 #define	PF_TAG_FRAGCACHE		0x02
 #define	PF_TAG_TRANSLATE_LOCALHOST	0x04
+#define PF_DN_TAG_PRESENT	        0x08
+#define PF_FASTFWD_OURS_PRESENT         0x10
 
 struct pf_mtag {
 	void		*hdr;		/* saved hdr pos in mbuf, for ECN */
Index: sys/contrib/pf/net/pfvar.h
===================================================================
RCS file: /root/freebsd/test/repoold/src/sys/contrib/pf/net/pfvar.h,v
retrieving revision 1.2
diff -u -r1.2 pfvar.h
--- sys/contrib/pf/net/pfvar.h	15 Apr 2010 18:53:16 -0000	1.2
+++ sys/contrib/pf/net/pfvar.h	15 Apr 2010 21:41:16 -0000
@@ -632,6 +632,11 @@
 	}			 max_src_conn_rate;
 	u_int32_t		 qid;
 	u_int32_t		 pqid;
+	u_int32_t                dnpipe;
+        u_int32_t                pdnpipe;
+#define	PFRULE_DN_IS_PIPE	0x00000010
+#define	PFRULE_DN_IS_QUEUE	0x00000020	
+	u_int32_t                free_flags;
 	u_int32_t		 rt_listid;
 	u_int32_t		 nr;
 	u_int32_t		 prob;
