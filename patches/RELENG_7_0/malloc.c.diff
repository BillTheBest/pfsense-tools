Index: malloc.c
===================================================================
RCS file: /home/ncvs/src/lib/libc/stdlib/malloc.c,v
retrieving revision 1.147.2.1
diff -u -r1.147.2.1 malloc.c
--- malloc.c	11 Oct 2007 06:35:46 -0000	1.147.2.1
+++ malloc.c	1 Dec 2008 19:28:43 -0000
@@ -1,5 +1,5 @@
 /*-
- * Copyright (C) 2006,2007 Jason Evans <jasone@FreeBSD.org>.
+ * Copyright (C) 2006-2008 Jason Evans <jasone@FreeBSD.org>.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -35,6 +35,9 @@
  *   + Multiple arenas are used if there are multiple CPUs, which reduces lock
  *     contention and cache sloshing.
  *
+ *   + Thread-specific caching is used if there are multiple threads, which
+ *     reduces the amount of locking.
+ *
  *   + Cache line sharing between arenas is avoided for internal data
  *     structures.
  *
@@ -45,39 +48,52 @@
  * Allocation requests are rounded up to the nearest size class, and no record
  * of the original request size is maintained.  Allocations are broken into
  * categories according to size class.  Assuming runtime defaults, 4 kB pages
- * and a 16 byte quantum, the size classes in each category are as follows:
+ * and a 16 byte quantum on a 32-bit system, the size classes in each category
+ * are as follows:
  *
- *   |=====================================|
- *   | Category | Subcategory    |    Size |
- *   |=====================================|
- *   | Small    | Tiny           |       2 |
- *   |          |                |       4 |
- *   |          |                |       8 |
- *   |          |----------------+---------|
- *   |          | Quantum-spaced |      16 |
- *   |          |                |      32 |
- *   |          |                |      48 |
- *   |          |                |     ... |
- *   |          |                |     480 |
- *   |          |                |     496 |
- *   |          |                |     512 |
- *   |          |----------------+---------|
- *   |          | Sub-page       |    1 kB |
- *   |          |                |    2 kB |
- *   |=====================================|
- *   | Large                     |    4 kB |
- *   |                           |    8 kB |
- *   |                           |   12 kB |
- *   |                           |     ... |
- *   |                           | 1012 kB |
- *   |                           | 1016 kB |
- *   |                           | 1020 kB |
- *   |=====================================|
- *   | Huge                      |    1 MB |
- *   |                           |    2 MB |
- *   |                           |    3 MB |
- *   |                           |     ... |
- *   |=====================================|
+ *   |=======================================|
+ *   | Category | Subcategory      |    Size |
+ *   |=======================================|
+ *   | Small    | Tiny             |       2 |
+ *   |          |                  |       4 |
+ *   |          |                  |       8 |
+ *   |          |------------------+---------|
+ *   |          | Quantum-spaced   |      16 |
+ *   |          |                  |      32 |
+ *   |          |                  |      48 |
+ *   |          |                  |     ... |
+ *   |          |                  |      96 |
+ *   |          |                  |     112 |
+ *   |          |                  |     128 |
+ *   |          |------------------+---------|
+ *   |          | Cacheline-spaced |     192 |
+ *   |          |                  |     256 |
+ *   |          |                  |     320 |
+ *   |          |                  |     384 |
+ *   |          |                  |     448 |
+ *   |          |                  |     512 |
+ *   |          |------------------+---------|
+ *   |          | Sub-page         |     760 |
+ *   |          |                  |    1024 |
+ *   |          |                  |    1280 |
+ *   |          |                  |     ... |
+ *   |          |                  |    3328 |
+ *   |          |                  |    3584 |
+ *   |          |                  |    3840 |
+ *   |=======================================|
+ *   | Large                       |    4 kB |
+ *   |                             |    8 kB |
+ *   |                             |   12 kB |
+ *   |                             |     ... |
+ *   |                             | 1012 kB |
+ *   |                             | 1016 kB |
+ *   |                             | 1020 kB |
+ *   |=======================================|
+ *   | Huge                        |    1 MB |
+ *   |                             |    2 MB |
+ *   |                             |    3 MB |
+ *   |                             |     ... |
+ *   |=======================================|
  *
  * A different mechanism is used for each category:
  *
@@ -98,14 +114,49 @@
  * defaults the A and J runtime options to off.  These settings are appropriate
  * for production systems.
  */
-#define MALLOC_PRODUCTION
+/* #define	MALLOC_PRODUCTION */
 
 #ifndef MALLOC_PRODUCTION
+   /*
+    * MALLOC_DEBUG enables assertions and other sanity checks, and disables
+    * inline functions.
+    */
 #  define MALLOC_DEBUG
+
+   /* MALLOC_STATS enables statistics calculation. */
+#  define MALLOC_STATS
 #endif
 
+/*
+ * MALLOC_TINY enables support for tiny objects, which are smaller than one
+ * quantum.
+ */
+#define	MALLOC_TINY
+
+/*
+ * MALLOC_MAG enables a magazine-based thread-specific caching layer for small
+ * objects.  This makes it possible to allocate/deallocate objects without any
+ * locking when the cache is in the steady state.
+ */
+#define	MALLOC_MAG
+
+/*
+ * MALLOC_BALANCE enables monitoring of arena lock contention and dynamically
+ * re-balances arena load if exponentially averaged contention exceeds a
+ * certain threshold.
+ */
+#define	MALLOC_BALANCE
+
+/*
+ * MALLOC_DSS enables use of sbrk(2) to allocate chunks from the data storage
+ * segment (DSS).  In an ideal world, this functionality would be completely
+ * unnecessary, but we are burdened by history and the lack of resource limits
+ * for anonymous mapped memory.
+ */
+#define	MALLOC_DSS
+
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/lib/libc/stdlib/malloc.c,v 1.147.2.1 2007/10/11 06:35:46 kensmith Exp $");
+__FBSDID("$FreeBSD: src/lib/libc/stdlib/malloc.c,v 1.183 2008/12/01 10:20:59 jasone Exp $");
 
 #include "libc_private.h"
 #ifdef MALLOC_DEBUG
@@ -119,12 +170,11 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/sysctl.h>
-#include <sys/tree.h>
 #include <sys/uio.h>
 #include <sys/ktrace.h> /* Must come after several other sys/ includes. */
 
-#include <machine/atomic.h>
 #include <machine/cpufunc.h>
+#include <machine/param.h>
 #include <machine/vmparam.h>
 
 #include <errno.h>
@@ -142,11 +192,6 @@
 
 #include "un-namespace.h"
 
-/* MALLOC_STATS enables statistics calculation. */
-#ifndef MALLOC_PRODUCTION
-#  define MALLOC_STATS
-#endif
-
 #ifdef MALLOC_DEBUG
 #  ifdef NDEBUG
 #    undef NDEBUG
@@ -158,6 +203,8 @@
 #endif
 #include <assert.h>
 
+#include "rb.h"
+
 #ifdef MALLOC_DEBUG
    /* Disable inlining to make debugging easier. */
 #  define inline
@@ -166,45 +213,54 @@
 /* Size of stack-allocated buffer passed to strerror_r(). */
 #define	STRERROR_BUF		64
 
-/* Minimum alignment of allocations is 2^QUANTUM_2POW_MIN bytes. */
+/*
+ * Minimum alignment of allocations is 2^QUANTUM_2POW bytes.
+ */
 #ifdef __i386__
-#  define QUANTUM_2POW_MIN	4
+#  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	2
-#  define USE_BRK
+#  define CPU_SPINWAIT		__asm__ volatile("pause")
 #endif
 #ifdef __ia64__
-#  define QUANTUM_2POW_MIN	4
+#  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	3
 #endif
 #ifdef __alpha__
-#  define QUANTUM_2POW_MIN	4
+#  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	3
 #  define NO_TLS
 #endif
 #ifdef __sparc64__
-#  define QUANTUM_2POW_MIN	4
+#  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	3
 #  define NO_TLS
 #endif
 #ifdef __amd64__
-#  define QUANTUM_2POW_MIN	4
+#  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	3
+#  define CPU_SPINWAIT		__asm__ volatile("pause")
 #endif
 #ifdef __arm__
-#  define QUANTUM_2POW_MIN	3
+#  define QUANTUM_2POW		3
+#  define SIZEOF_PTR_2POW	2
+#  define NO_TLS
+#endif
+#ifdef __mips__
+#  define QUANTUM_2POW		3
 #  define SIZEOF_PTR_2POW	2
-#  define USE_BRK
 #  define NO_TLS
 #endif
 #ifdef __powerpc__
-#  define QUANTUM_2POW_MIN	4
+#  define QUANTUM_2POW		4
 #  define SIZEOF_PTR_2POW	2
-#  define USE_BRK
 #endif
 
-#define	SIZEOF_PTR		(1 << SIZEOF_PTR_2POW)
+#define	QUANTUM			((size_t)(1U << QUANTUM_2POW))
+#define	QUANTUM_MASK		(QUANTUM - 1)
+
+#define	SIZEOF_PTR		(1U << SIZEOF_PTR_2POW)
 
-/* sizeof(int) == (1 << SIZEOF_INT_2POW). */
+/* sizeof(int) == (1U << SIZEOF_INT_2POW). */
 #ifndef SIZEOF_INT_2POW
 #  define SIZEOF_INT_2POW	2
 #endif
@@ -214,56 +270,144 @@
 #  define NO_TLS
 #endif
 
+#ifdef NO_TLS
+   /* MALLOC_MAG requires TLS. */
+#  ifdef MALLOC_MAG
+#    undef MALLOC_MAG
+#  endif
+   /* MALLOC_BALANCE requires TLS. */
+#  ifdef MALLOC_BALANCE
+#    undef MALLOC_BALANCE
+#  endif
+#endif
+
 /*
  * Size and alignment of memory chunks that are allocated by the OS's virtual
  * memory system.
  */
 #define	CHUNK_2POW_DEFAULT	20
 
+/* Maximum number of dirty pages per arena. */
+#define	DIRTY_MAX_DEFAULT	(1U << 9)
+
 /*
- * Maximum size of L1 cache line.  This is used to avoid cache line aliasing,
- * so over-estimates are okay (up to a point), but under-estimates will
- * negatively affect performance.
+ * Maximum size of L1 cache line.  This is used to avoid cache line aliasing.
+ * In addition, this controls the spacing of cacheline-spaced size classes.
  */
 #define	CACHELINE_2POW		6
-#define	CACHELINE		((size_t)(1 << CACHELINE_2POW))
+#define	CACHELINE		((size_t)(1U << CACHELINE_2POW))
+#define	CACHELINE_MASK		(CACHELINE - 1)
 
-/* Smallest size class to support. */
-#define	TINY_MIN_2POW		1
+/*
+ * Subpages are an artificially designated partitioning of pages.  Their only
+ * purpose is to support subpage-spaced size classes.
+ *
+ * There must be at least 4 subpages per page, due to the way size classes are
+ * handled.
+ */
+#define	SUBPAGE_2POW		8
+#define	SUBPAGE			((size_t)(1U << SUBPAGE_2POW))
+#define	SUBPAGE_MASK		(SUBPAGE - 1)
+
+#ifdef MALLOC_TINY
+   /* Smallest size class to support. */
+#  define TINY_MIN_2POW		1
+#endif
 
 /*
  * Maximum size class that is a multiple of the quantum, but not (necessarily)
  * a power of 2.  Above this size, allocations are rounded up to the nearest
  * power of 2.
  */
-#define	SMALL_MAX_2POW_DEFAULT	9
-#define	SMALL_MAX_DEFAULT	(1 << SMALL_MAX_2POW_DEFAULT)
+#define	QSPACE_MAX_2POW_DEFAULT	7
+
+/*
+ * Maximum size class that is a multiple of the cacheline, but not (necessarily)
+ * a power of 2.  Above this size, allocations are rounded up to the nearest
+ * power of 2.
+ */
+#define	CSPACE_MAX_2POW_DEFAULT	9
 
 /*
- * Maximum desired run header overhead.  Runs are sized as small as possible
- * such that this setting is still honored, without violating other constraints.
- * The goal is to make runs as small as possible without exceeding a per run
- * external fragmentation threshold.
+ * RUN_MAX_OVRHD indicates maximum desired run header overhead.  Runs are sized
+ * as small as possible such that this setting is still honored, without
+ * violating other constraints.  The goal is to make runs as small as possible
+ * without exceeding a per run external fragmentation threshold.
+ *
+ * We use binary fixed point math for overhead computations, where the binary
+ * point is implicitly RUN_BFP bits to the left.
  *
- * Note that it is possible to set this low enough that it cannot be honored
- * for some/all object sizes, since there is one bit of header overhead per
- * object (plus a constant).  In such cases, this constraint is relaxed.
+ * Note that it is possible to set RUN_MAX_OVRHD low enough that it cannot be
+ * honored for some/all object sizes, since there is one bit of header overhead
+ * per object (plus a constant).  This constraint is relaxed (ignored) for runs
+ * that are so small that the per-region overhead is greater than:
  *
- * RUN_MAX_OVRHD_RELAX specifies the maximum number of bits per region of
- * overhead for which RUN_MAX_OVRHD is relaxed.
+ *   (RUN_MAX_OVRHD / (reg_size << (3+RUN_BFP))
  */
-#define RUN_MAX_OVRHD		0.015
-#define RUN_MAX_OVRHD_RELAX	1.5
+#define	RUN_BFP			12
+/*                                    \/   Implicit binary fixed point. */
+#define	RUN_MAX_OVRHD		0x0000003dU
+#define	RUN_MAX_OVRHD_RELAX	0x00001800U
 
 /* Put a cap on small object run size.  This overrides RUN_MAX_OVRHD. */
-#define RUN_MAX_SMALL_2POW	15
-#define RUN_MAX_SMALL		(1 << RUN_MAX_SMALL_2POW)
+#define	RUN_MAX_SMALL	(12 * PAGE_SIZE)
+
+/*
+ * Hyper-threaded CPUs may need a special instruction inside spin loops in
+ * order to yield to another virtual CPU.  If no such instruction is defined
+ * above, make CPU_SPINWAIT a no-op.
+ */
+#ifndef CPU_SPINWAIT
+#  define CPU_SPINWAIT
+#endif
+
+/*
+ * Adaptive spinning must eventually switch to blocking, in order to avoid the
+ * potential for priority inversion deadlock.  Backing off past a certain point
+ * can actually waste time.
+ */
+#define	SPIN_LIMIT_2POW		11
+
+/*
+ * Conversion from spinning to blocking is expensive; we use (1U <<
+ * BLOCK_COST_2POW) to estimate how many more times costly blocking is than
+ * worst-case spinning.
+ */
+#define	BLOCK_COST_2POW		4
+
+#ifdef MALLOC_MAG
+   /*
+    * Default magazine size, in bytes.  max_rounds is calculated to make
+    * optimal use of the space, leaving just enough room for the magazine
+    * header.
+    */
+#  define MAG_SIZE_2POW_DEFAULT	9
+#endif
+
+#ifdef MALLOC_BALANCE
+   /*
+    * We use an exponential moving average to track recent lock contention,
+    * where the size of the history window is N, and alpha=2/(N+1).
+    *
+    * Due to integer math rounding, very small values here can cause
+    * substantial degradation in accuracy, thus making the moving average decay
+    * faster than it would with precise calculation.
+    */
+#  define BALANCE_ALPHA_INV_2POW	9
+
+   /*
+    * Threshold value for the exponential moving contention average at which to
+    * re-assign a thread.
+    */
+#  define BALANCE_THRESHOLD_DEFAULT	(1U << (SPIN_LIMIT_2POW-4))
+#endif
 
 /******************************************************************************/
 
 /*
- * Mutexes based on spinlocks.  We can't use normal pthread mutexes, because
- * they require malloc()ed memory.
+ * Mutexes based on spinlocks.  We can't use normal pthread spinlocks in all
+ * places, because they require malloc()ed memory, which causes bootstrapping
+ * issues in some cases.
  */
 typedef struct {
 	spinlock_t	lock;
@@ -290,6 +434,11 @@
 	 */
 	uint64_t	nrequests;
 
+#ifdef MALLOC_MAG
+	/* Number of magazine reloads from this bin. */
+	uint64_t	nmags;
+#endif
+
 	/* Total number of runs created for this bin's size class. */
 	uint64_t	nruns;
 
@@ -311,6 +460,15 @@
 	/* Number of bytes currently mapped. */
 	size_t		mapped;
 
+	/*
+	 * Total number of purge sweeps, total number of madvise calls made,
+	 * and total pages purged in order to keep dirty unused memory under
+	 * control.
+	 */
+	uint64_t	npurge;
+	uint64_t	nmadvise;
+	uint64_t	purged;
+
 	/* Per-size-category statistics. */
 	size_t		allocated_small;
 	uint64_t	nmalloc_small;
@@ -319,6 +477,11 @@
 	size_t		allocated_large;
 	uint64_t	nmalloc_large;
 	uint64_t	ndalloc_large;
+
+#ifdef MALLOC_BALANCE
+	/* Number of times this arena reassigned a thread due to contention. */
+	uint64_t	nbalance;
+#endif
 };
 
 typedef struct chunk_stats_s chunk_stats_t;
@@ -341,28 +504,27 @@
 
 /******************************************************************************/
 /*
- * Chunk data structures.
+ * Extent data structures.
  */
 
-/* Tree of chunks. */
-typedef struct chunk_node_s chunk_node_t;
-struct chunk_node_s {
-	/* Linkage for the chunk tree. */
-	RB_ENTRY(chunk_node_s) link;
+/* Tree of extents. */
+typedef struct extent_node_s extent_node_t;
+struct extent_node_s {
+#ifdef MALLOC_DSS
+	/* Linkage for the size/address-ordered tree. */
+	rb_node(extent_node_t) link_szad;
+#endif
 
-	/*
-	 * Pointer to the chunk that this tree node is responsible for.  In some
-	 * (but certainly not all) cases, this data structure is placed at the
-	 * beginning of the corresponding chunk, so this field may point to this
-	 * node.
-	 */
-	void	*chunk;
+	/* Linkage for the address-ordered tree. */
+	rb_node(extent_node_t) link_ad;
+
+	/* Pointer to the extent that this tree node is responsible for. */
+	void	*addr;
 
-	/* Total chunk size. */
+	/* Total region size. */
 	size_t	size;
 };
-typedef struct chunk_tree_s chunk_tree_t;
-RB_HEAD(chunk_tree_s, chunk_node_s);
+typedef rb_tree(extent_node_t) extent_tree_t;
 
 /******************************************************************************/
 /*
@@ -372,67 +534,87 @@
 typedef struct arena_s arena_t;
 typedef struct arena_bin_s arena_bin_t;
 
+/* Each element of the chunk map corresponds to one page within the chunk. */
 typedef struct arena_chunk_map_s arena_chunk_map_t;
 struct arena_chunk_map_s {
-	/* Number of pages in run. */
-	uint32_t	npages;
 	/*
-	 * Position within run.  For a free run, this is POS_FREE for the first
-	 * and last pages.  The POS_FREE special value makes it possible to
-	 * quickly coalesce free runs.
+	 * Linkage for run trees.  There are two disjoint uses:
+	 *
+	 * 1) arena_t's runs_avail tree.
+	 * 2) arena_run_t conceptually uses this linkage for in-use non-full
+	 *    runs, rather than directly embedding linkage.
+	 */
+	rb_node(arena_chunk_map_t)	link;
+
+	/*
+	 * Run address (or size) and various flags are stored together.  The bit
+	 * layout looks like (assuming 32-bit system):
 	 *
-	 * This is the limiting factor for chunksize; there can be at most 2^31
-	 * pages in a run.
+	 *   ???????? ???????? ????---- ---kdzla
+	 *
+	 * ? : Unallocated: Run address for first/last pages, unset for internal
+	 *                  pages.
+	 *     Small: Run address.
+	 *     Large: Run size for first page, unset for trailing pages.
+	 * - : Unused.
+	 * k : key?
+	 * d : dirty?
+	 * z : zeroed?
+	 * l : large?
+	 * a : allocated?
+	 *
+	 * Following are example bit patterns for the three types of runs.
+	 *
+	 * r : run address
+	 * s : run size
+	 * x : don't care
+	 * - : 0
+	 * [dzla] : bit set
+	 *
+	 *   Unallocated:
+	 *     ssssssss ssssssss ssss---- --------
+	 *     xxxxxxxx xxxxxxxx xxxx---- ----d---
+	 *     ssssssss ssssssss ssss---- -----z--
+	 *
+	 *   Small:
+	 *     rrrrrrrr rrrrrrrr rrrr---- -------a
+	 *     rrrrrrrr rrrrrrrr rrrr---- -------a
+	 *     rrrrrrrr rrrrrrrr rrrr---- -------a
+	 *
+	 *   Large:
+	 *     ssssssss ssssssss ssss---- ------la
+	 *     -------- -------- -------- ------la
+	 *     -------- -------- -------- ------la
 	 */
-#define POS_FREE ((uint32_t)0xffffffffU)
-	uint32_t	pos;
+	size_t				bits;
+#define	CHUNK_MAP_KEY		((size_t)0x10U)
+#define	CHUNK_MAP_DIRTY		((size_t)0x08U)
+#define	CHUNK_MAP_ZEROED	((size_t)0x04U)
+#define	CHUNK_MAP_LARGE		((size_t)0x02U)
+#define	CHUNK_MAP_ALLOCATED	((size_t)0x01U)
 };
+typedef rb_tree(arena_chunk_map_t) arena_avail_tree_t;
+typedef rb_tree(arena_chunk_map_t) arena_run_tree_t;
 
 /* Arena chunk header. */
 typedef struct arena_chunk_s arena_chunk_t;
 struct arena_chunk_s {
 	/* Arena that owns the chunk. */
-	arena_t *arena;
-
-	/* Linkage for the arena's chunk tree. */
-	RB_ENTRY(arena_chunk_s) link;
+	arena_t		*arena;
 
-	/*
-	 * Number of pages in use.  This is maintained in order to make
-	 * detection of empty chunks fast.
-	 */
-	uint32_t pages_used;
-
-	/*
-	 * Every time a free run larger than this value is created/coalesced,
-	 * this value is increased.  The only way that the value decreases is if
-	 * arena_run_alloc() fails to find a free run as large as advertised by
-	 * this value.
-	 */
-	uint32_t max_frun_npages;
+	/* Linkage for the arena's chunks_dirty tree. */
+	rb_node(arena_chunk_t) link_dirty;
 
-	/*
-	 * Every time a free run that starts at an earlier page than this value
-	 * is created/coalesced, this value is decreased.  It is reset in a
-	 * similar fashion to max_frun_npages.
-	 */
-	uint32_t min_frun_ind;
+	/* Number of dirty pages. */
+	size_t		ndirty;
 
-	/*
-	 * Map of pages within chunk that keeps track of free/large/small.  For
-	 * free runs, only the map entries for the first and last pages are
-	 * kept up to date, so that free runs can be quickly coalesced.
-	 */
+	/* Map of pages within chunk that keeps track of free/large/small. */
 	arena_chunk_map_t map[1]; /* Dynamically sized. */
 };
-typedef struct arena_chunk_tree_s arena_chunk_tree_t;
-RB_HEAD(arena_chunk_tree_s, arena_chunk_s);
+typedef rb_tree(arena_chunk_t) arena_chunk_tree_t;
 
 typedef struct arena_run_s arena_run_t;
 struct arena_run_s {
-	/* Linkage for run trees. */
-	RB_ENTRY(arena_run_s) link;
-
 #ifdef MALLOC_DEBUG
 	uint32_t	magic;
 #  define ARENA_RUN_MAGIC 0x384adf93
@@ -450,8 +632,6 @@
 	/* Bitmask of in-use regions (0: in use, 1: free). */
 	unsigned	regs_mask[1]; /* Dynamically sized. */
 };
-typedef struct arena_run_tree_s arena_run_tree_t;
-RB_HEAD(arena_run_tree_s, arena_run_s);
 
 struct arena_bin_s {
 	/*
@@ -496,32 +676,54 @@
 #  define ARENA_MAGIC 0x947d3d24
 #endif
 
-	/* All operations on this arena require that mtx be locked. */
-	malloc_mutex_t		mtx;
+	/* All operations on this arena require that lock be locked. */
+	pthread_mutex_t		lock;
 
 #ifdef MALLOC_STATS
 	arena_stats_t		stats;
 #endif
 
-	/*
-	 * Tree of chunks this arena manages.
-	 */
-	arena_chunk_tree_t	chunks;
+	/* Tree of dirty-page-containing chunks this arena manages. */
+	arena_chunk_tree_t	chunks_dirty;
 
 	/*
 	 * In order to avoid rapid chunk allocation/deallocation when an arena
 	 * oscillates right on the cusp of needing a new chunk, cache the most
-	 * recently freed chunk.  This caching is disabled by opt_hint.
+	 * recently freed chunk.  The spare is left in the arena's chunk trees
+	 * until it is deleted.
 	 *
 	 * There is one spare chunk per arena, rather than one spare total, in
 	 * order to avoid interactions between multiple threads that could make
 	 * a single spare inadequate.
 	 */
-	arena_chunk_t *spare;
+	arena_chunk_t		*spare;
+
+	/*
+	 * Current count of pages within unused runs that are potentially
+	 * dirty, and for which madvise(... MADV_FREE) has not been called.  By
+	 * tracking this, we can institute a limit on how much dirty unused
+	 * memory is mapped for each arena.
+	 */
+	size_t			ndirty;
+
+	/*
+	 * Size/address-ordered tree of this arena's available runs.  This tree
+	 * is used for first-best-fit run allocation.
+	 */
+	arena_avail_tree_t	runs_avail;
+
+#ifdef MALLOC_BALANCE
+	/*
+	 * The arena load balancing machinery needs to keep track of how much
+	 * lock contention there is.  This value is exponentially averaged.
+	 */
+	uint32_t		contention;
+#endif
 
 	/*
 	 * bins is used to store rings of free regions of the following sizes,
-	 * assuming a 16-byte quantum, 4kB pagesize, and default MALLOC_OPTIONS.
+	 * assuming a 16-byte quantum, 4kB page size, and default
+	 * MALLOC_OPTIONS.
 	 *
 	 *   bins[i] | size |
 	 *   --------+------+
@@ -547,34 +749,189 @@
 
 /******************************************************************************/
 /*
+ * Magazine data structures.
+ */
+
+#ifdef MALLOC_MAG
+typedef struct mag_s mag_t;
+struct mag_s {
+	size_t		binind; /* Index of associated bin. */
+	size_t		nrounds;
+	void		*rounds[1]; /* Dynamically sized. */
+};
+
+/*
+ * Magazines are lazily allocated, but once created, they remain until the
+ * associated mag_rack is destroyed.
+ */
+typedef struct bin_mags_s bin_mags_t;
+struct bin_mags_s {
+	mag_t	*curmag;
+	mag_t	*sparemag;
+};
+
+typedef struct mag_rack_s mag_rack_t;
+struct mag_rack_s {
+	bin_mags_t	bin_mags[1]; /* Dynamically sized. */
+};
+#endif
+
+/******************************************************************************/
+/*
  * Data.
  */
 
 /* Number of CPUs. */
 static unsigned		ncpus;
 
-/* VM page size. */
-static size_t		pagesize;
-static size_t		pagesize_mask;
-static size_t		pagesize_2pow;
-
 /* Various bin-related settings. */
-static size_t		bin_maxclass; /* Max size class for bins. */
-static unsigned		ntbins; /* Number of (2^n)-spaced tiny bins. */
+#ifdef MALLOC_TINY		/* Number of (2^n)-spaced tiny bins. */
+#  define		ntbins	((unsigned)(QUANTUM_2POW - TINY_MIN_2POW))
+#else
+#  define		ntbins	0
+#endif
 static unsigned		nqbins; /* Number of quantum-spaced bins. */
-static unsigned		nsbins; /* Number of (2^n)-spaced sub-page bins. */
-static size_t		small_min;
-static size_t		small_max;
-
-/* Various quantum-related settings. */
-static size_t		quantum;
-static size_t		quantum_mask; /* (quantum - 1). */
+static unsigned		ncbins; /* Number of cacheline-spaced bins. */
+static unsigned		nsbins; /* Number of subpage-spaced bins. */
+static unsigned		nbins;
+#ifdef MALLOC_TINY
+#  define		tspace_max	((size_t)(QUANTUM >> 1))
+#endif
+#define			qspace_min	QUANTUM
+static size_t		qspace_max;
+static size_t		cspace_min;
+static size_t		cspace_max;
+static size_t		sspace_min;
+static size_t		sspace_max;
+#define			bin_maxclass	sspace_max
+
+static uint8_t const	*size2bin;
+/*
+ * const_size2bin is a static constant lookup table that in the common case can
+ * be used as-is for size2bin.  For dynamically linked programs, this avoids
+ * a page of memory overhead per process.
+ */
+#define	S2B_1(i)	i,
+#define	S2B_2(i)	S2B_1(i) S2B_1(i)
+#define	S2B_4(i)	S2B_2(i) S2B_2(i)
+#define	S2B_8(i)	S2B_4(i) S2B_4(i)
+#define	S2B_16(i)	S2B_8(i) S2B_8(i)
+#define	S2B_32(i)	S2B_16(i) S2B_16(i)
+#define	S2B_64(i)	S2B_32(i) S2B_32(i)
+#define	S2B_128(i)	S2B_64(i) S2B_64(i)
+#define	S2B_256(i)	S2B_128(i) S2B_128(i)
+static const uint8_t	const_size2bin[PAGE_SIZE - 255] = {
+	S2B_1(0xffU)		/*    0 */
+#if (QUANTUM_2POW == 4)
+/* 64-bit system ************************/
+#  ifdef MALLOC_TINY
+	S2B_2(0)		/*    2 */
+	S2B_2(1)		/*    4 */
+	S2B_4(2)		/*    8 */
+	S2B_8(3)		/*   16 */
+#    define S2B_QMIN 3
+#  else
+	S2B_16(0)		/*   16 */
+#    define S2B_QMIN 0
+#  endif
+	S2B_16(S2B_QMIN + 1)	/*   32 */
+	S2B_16(S2B_QMIN + 2)	/*   48 */
+	S2B_16(S2B_QMIN + 3)	/*   64 */
+	S2B_16(S2B_QMIN + 4)	/*   80 */
+	S2B_16(S2B_QMIN + 5)	/*   96 */
+	S2B_16(S2B_QMIN + 6)	/*  112 */
+	S2B_16(S2B_QMIN + 7)	/*  128 */
+#  define S2B_CMIN (S2B_QMIN + 8)
+#else
+/* 32-bit system ************************/
+#  ifdef MALLOC_TINY
+	S2B_2(0)		/*    2 */
+	S2B_2(1)		/*    4 */
+	S2B_4(2)		/*    8 */
+#    define S2B_QMIN 2
+#  else
+	S2B_8(0)		/*    8 */
+#    define S2B_QMIN 0
+#  endif
+	S2B_8(S2B_QMIN + 1)	/*   16 */
+	S2B_8(S2B_QMIN + 2)	/*   24 */
+	S2B_8(S2B_QMIN + 3)	/*   32 */
+	S2B_8(S2B_QMIN + 4)	/*   40 */
+	S2B_8(S2B_QMIN + 5)	/*   48 */
+	S2B_8(S2B_QMIN + 6)	/*   56 */
+	S2B_8(S2B_QMIN + 7)	/*   64 */
+	S2B_8(S2B_QMIN + 8)	/*   72 */
+	S2B_8(S2B_QMIN + 9)	/*   80 */
+	S2B_8(S2B_QMIN + 10)	/*   88 */
+	S2B_8(S2B_QMIN + 11)	/*   96 */
+	S2B_8(S2B_QMIN + 12)	/*  104 */
+	S2B_8(S2B_QMIN + 13)	/*  112 */
+	S2B_8(S2B_QMIN + 14)	/*  120 */
+	S2B_8(S2B_QMIN + 15)	/*  128 */
+#  define S2B_CMIN (S2B_QMIN + 16)
+#endif
+/****************************************/
+	S2B_64(S2B_CMIN + 0)	/*  192 */
+	S2B_64(S2B_CMIN + 1)	/*  256 */
+	S2B_64(S2B_CMIN + 2)	/*  320 */
+	S2B_64(S2B_CMIN + 3)	/*  384 */
+	S2B_64(S2B_CMIN + 4)	/*  448 */
+	S2B_64(S2B_CMIN + 5)	/*  512 */
+#  define S2B_SMIN (S2B_CMIN + 6)
+	S2B_256(S2B_SMIN + 0)	/*  768 */
+	S2B_256(S2B_SMIN + 1)	/* 1024 */
+	S2B_256(S2B_SMIN + 2)	/* 1280 */
+	S2B_256(S2B_SMIN + 3)	/* 1536 */
+	S2B_256(S2B_SMIN + 4)	/* 1792 */
+	S2B_256(S2B_SMIN + 5)	/* 2048 */
+	S2B_256(S2B_SMIN + 6)	/* 2304 */
+	S2B_256(S2B_SMIN + 7)	/* 2560 */
+	S2B_256(S2B_SMIN + 8)	/* 2816 */
+	S2B_256(S2B_SMIN + 9)	/* 3072 */
+	S2B_256(S2B_SMIN + 10)	/* 3328 */
+	S2B_256(S2B_SMIN + 11)	/* 3584 */
+	S2B_256(S2B_SMIN + 12)	/* 3840 */
+#if (PAGE_SHIFT == 13)
+	S2B_256(S2B_SMIN + 13)	/* 4096 */
+	S2B_256(S2B_SMIN + 14)	/* 4352 */
+	S2B_256(S2B_SMIN + 15)	/* 4608 */
+	S2B_256(S2B_SMIN + 16)	/* 4864 */
+	S2B_256(S2B_SMIN + 17)	/* 5120 */
+	S2B_256(S2B_SMIN + 18)	/* 5376 */
+	S2B_256(S2B_SMIN + 19)	/* 5632 */
+	S2B_256(S2B_SMIN + 20)	/* 5888 */
+	S2B_256(S2B_SMIN + 21)	/* 6144 */
+	S2B_256(S2B_SMIN + 22)	/* 6400 */
+	S2B_256(S2B_SMIN + 23)	/* 6656 */
+	S2B_256(S2B_SMIN + 24)	/* 6912 */
+	S2B_256(S2B_SMIN + 25)	/* 7168 */
+	S2B_256(S2B_SMIN + 26)	/* 7424 */
+	S2B_256(S2B_SMIN + 27)	/* 7680 */
+	S2B_256(S2B_SMIN + 28)	/* 7936 */
+#endif
+};
+#undef S2B_1
+#undef S2B_2
+#undef S2B_4
+#undef S2B_8
+#undef S2B_16
+#undef S2B_32
+#undef S2B_64
+#undef S2B_128
+#undef S2B_256
+#undef S2B_QMIN
+#undef S2B_CMIN
+#undef S2B_SMIN
+
+#ifdef MALLOC_MAG
+static size_t		max_rounds;
+#endif
 
 /* Various chunk-related settings. */
 static size_t		chunksize;
 static size_t		chunksize_mask; /* (chunksize - 1). */
-static unsigned		chunk_npages;
-static unsigned		arena_chunk_header_npages;
+static size_t		chunk_npages;
+static size_t		arena_chunk_header_npages;
 static size_t		arena_maxclass; /* Max size class for arenas. */
 
 /********/
@@ -583,27 +940,32 @@
  */
 
 /* Protects chunk-related data structures. */
-static malloc_mutex_t	chunks_mtx;
+static malloc_mutex_t	huge_mtx;
 
 /* Tree of chunks that are stand-alone huge allocations. */
-static chunk_tree_t	huge;
+static extent_tree_t	huge;
 
-#ifdef USE_BRK
+#ifdef MALLOC_DSS
 /*
- * Try to use brk for chunk-size allocations, due to address space constraints.
+ * Protects sbrk() calls.  This avoids malloc races among threads, though it
+ * does not protect against races with threads that call sbrk() directly.
  */
+static malloc_mutex_t	dss_mtx;
+/* Base address of the DSS. */
+static void		*dss_base;
+/* Current end of the DSS, or ((void *)-1) if the DSS is exhausted. */
+static void		*dss_prev;
+/* Current upper limit on DSS addresses. */
+static void		*dss_max;
+
 /*
- * Protects sbrk() calls.  This must be separate from chunks_mtx, since
- * base_pages_alloc() also uses sbrk(), but cannot lock chunks_mtx (doing so
- * could cause recursive lock acquisition).
+ * Trees of chunks that were previously allocated (trees differ only in node
+ * ordering).  These are used when allocating chunks, in an attempt to re-use
+ * address space.  Depending on function, different tree orderings are needed,
+ * which is why there are two trees with the same contents.
  */
-static malloc_mutex_t	brk_mtx;
-/* Result of first sbrk(0) call. */
-static void		*brk_base;
-/* Current end of brk, or ((void *)-1) if brk is exhausted. */
-static void		*brk_prev;
-/* Current upper limit on brk addresses. */
-static void		*brk_max;
+static extent_tree_t	dss_chunks_szad;
+static extent_tree_t	dss_chunks_ad;
 #endif
 
 #ifdef MALLOC_STATS
@@ -613,12 +975,6 @@
 static size_t		huge_allocated;
 #endif
 
-/*
- * Tree of chunks that were previously allocated.  This is used when allocating
- * chunks, in an attempt to re-use address space.
- */
-static chunk_tree_t	old_chunks;
-
 /****************************/
 /*
  * base (internal allocation).
@@ -632,7 +988,7 @@
 static void		*base_pages;
 static void		*base_next_addr;
 static void		*base_past_addr; /* Addr immediately past base_pages. */
-static chunk_node_t	*base_chunk_nodes; /* LIFO cache of chunk nodes. */
+static extent_node_t	*base_nodes;
 static malloc_mutex_t	base_mtx;
 #ifdef MALLOC_STATS
 static size_t		base_mapped;
@@ -650,9 +1006,13 @@
 static arena_t		**arenas;
 static unsigned		narenas;
 #ifndef NO_TLS
+#  ifdef MALLOC_BALANCE
+static unsigned		narenas_2pow;
+#  else
 static unsigned		next_arena;
+#  endif
 #endif
-static malloc_mutex_t	arenas_mtx; /* Protects arenas initialization. */
+static pthread_mutex_t	arenas_lock; /* Protects arenas initialization. */
 
 #ifndef NO_TLS
 /*
@@ -662,6 +1022,14 @@
 static __thread arena_t	*arenas_map;
 #endif
 
+#ifdef MALLOC_MAG
+/*
+ * Map of thread-specific magazine racks, used for thread-specific object
+ * caching.
+ */
+static __thread mag_rack_t	*mag_rack;
+#endif
+
 #ifdef MALLOC_STATS
 /* Chunk statistics. */
 static chunk_stats_t	stats_chunks;
@@ -680,16 +1048,27 @@
 static bool	opt_abort = false;
 static bool	opt_junk = false;
 #endif
-static bool	opt_hint = false;
+#ifdef MALLOC_DSS
+static bool	opt_dss = true;
+static bool	opt_mmap = true;
+#endif
+#ifdef MALLOC_MAG
+static bool	opt_mag = true;
+static size_t	opt_mag_size_2pow = MAG_SIZE_2POW_DEFAULT;
+#endif
+static size_t	opt_dirty_max = DIRTY_MAX_DEFAULT;
+#ifdef MALLOC_BALANCE
+static uint64_t	opt_balance_threshold = BALANCE_THRESHOLD_DEFAULT;
+#endif
 static bool	opt_print_stats = false;
-static size_t	opt_quantum_2pow = QUANTUM_2POW_MIN;
-static size_t	opt_small_max_2pow = SMALL_MAX_2POW_DEFAULT;
+static size_t	opt_qspace_max_2pow = QSPACE_MAX_2POW_DEFAULT;
+static size_t	opt_cspace_max_2pow = CSPACE_MAX_2POW_DEFAULT;
 static size_t	opt_chunk_2pow = CHUNK_2POW_DEFAULT;
 static bool	opt_utrace = false;
 static bool	opt_sysv = false;
 static bool	opt_xmalloc = false;
 static bool	opt_zero = false;
-static int32_t	opt_narenas_lshift = 0;
+static int	opt_narenas_lshift = 0;
 
 typedef struct {
 	void	*p;
@@ -699,7 +1078,10 @@
 
 #define	UTRACE(a, b, c)							\
 	if (opt_utrace) {						\
-		malloc_utrace_t ut = {a, b, c};				\
+		malloc_utrace_t ut;					\
+		ut.p = (a);						\
+		ut.s = (b);						\
+		ut.r = (c);						\
 		utrace(&ut, sizeof(ut));				\
 	}
 
@@ -708,54 +1090,97 @@
  * Begin function prototypes for non-inline static functions.
  */
 
-static void	malloc_mutex_init(malloc_mutex_t *a_mutex);
+static void	malloc_mutex_init(malloc_mutex_t *mutex);
+static bool	malloc_spin_init(pthread_mutex_t *lock);
 static void	wrtmessage(const char *p1, const char *p2, const char *p3,
 		const char *p4);
 #ifdef MALLOC_STATS
 static void	malloc_printf(const char *format, ...);
 #endif
 static char	*umax2s(uintmax_t x, char *s);
+#ifdef MALLOC_DSS
+static bool	base_pages_alloc_dss(size_t minsize);
+#endif
+static bool	base_pages_alloc_mmap(size_t minsize);
 static bool	base_pages_alloc(size_t minsize);
 static void	*base_alloc(size_t size);
-static chunk_node_t *base_chunk_node_alloc(void);
-static void	base_chunk_node_dealloc(chunk_node_t *node);
+static void	*base_calloc(size_t number, size_t size);
+static extent_node_t *base_node_alloc(void);
+static void	base_node_dealloc(extent_node_t *node);
 #ifdef MALLOC_STATS
 static void	stats_print(arena_t *arena);
 #endif
 static void	*pages_map(void *addr, size_t size);
 static void	pages_unmap(void *addr, size_t size);
-static void	*chunk_alloc(size_t size);
+#ifdef MALLOC_DSS
+static void	*chunk_alloc_dss(size_t size);
+static void	*chunk_recycle_dss(size_t size, bool zero);
+#endif
+static void	*chunk_alloc_mmap(size_t size);
+static void	*chunk_alloc(size_t size, bool zero);
+#ifdef MALLOC_DSS
+static extent_node_t *chunk_dealloc_dss_record(void *chunk, size_t size);
+static bool	chunk_dealloc_dss(void *chunk, size_t size);
+#endif
+static void	chunk_dealloc_mmap(void *chunk, size_t size);
 static void	chunk_dealloc(void *chunk, size_t size);
 #ifndef NO_TLS
 static arena_t	*choose_arena_hard(void);
 #endif
-static void	arena_run_split(arena_t *arena, arena_run_t *run, size_t size);
+static void	arena_run_split(arena_t *arena, arena_run_t *run, size_t size,
+    bool large, bool zero);
 static arena_chunk_t *arena_chunk_alloc(arena_t *arena);
 static void	arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk);
-static arena_run_t *arena_run_alloc(arena_t *arena, size_t size);
-static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, size_t size);
+static arena_run_t *arena_run_alloc(arena_t *arena, size_t size, bool large,
+    bool zero);
+static void	arena_purge(arena_t *arena);
+static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty);
+static void	arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk,
+    arena_run_t *run, size_t oldsize, size_t newsize);
+static void	arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk,
+    arena_run_t *run, size_t oldsize, size_t newsize, bool dirty);
 static arena_run_t *arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin);
-static void *arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin);
-static size_t arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size);
-static void	*arena_malloc(arena_t *arena, size_t size);
+static void	*arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin);
+static size_t	arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size);
+#ifdef MALLOC_BALANCE
+static void	arena_lock_balance_hard(arena_t *arena);
+#endif
+#ifdef MALLOC_MAG
+static void	mag_load(mag_t *mag);
+#endif
+static void	*arena_malloc_large(arena_t *arena, size_t size, bool zero);
 static void	*arena_palloc(arena_t *arena, size_t alignment, size_t size,
     size_t alloc_size);
 static size_t	arena_salloc(const void *ptr);
+#ifdef MALLOC_MAG
+static void	mag_unload(mag_t *mag);
+#endif
+static void	arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk,
+    void *ptr);
+static void	arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, size_t size, size_t oldsize);
+static bool	arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, size_t size, size_t oldsize);
+static bool	arena_ralloc_large(void *ptr, size_t size, size_t oldsize);
 static void	*arena_ralloc(void *ptr, size_t size, size_t oldsize);
-static void	arena_dalloc(arena_t *arena, arena_chunk_t *chunk, void *ptr);
 static bool	arena_new(arena_t *arena);
 static arena_t	*arenas_extend(unsigned ind);
-static void	*huge_malloc(size_t size);
+#ifdef MALLOC_MAG
+static mag_t	*mag_create(arena_t *arena, size_t binind);
+static void	mag_destroy(mag_t *mag);
+static mag_rack_t *mag_rack_create(arena_t *arena);
+static void	mag_rack_destroy(mag_rack_t *rack);
+#endif
+static void	*huge_malloc(size_t size, bool zero);
 static void	*huge_palloc(size_t alignment, size_t size);
 static void	*huge_ralloc(void *ptr, size_t size, size_t oldsize);
 static void	huge_dalloc(void *ptr);
-static void	*imalloc(size_t size);
-static void	*ipalloc(size_t alignment, size_t size);
-static void	*icalloc(size_t size);
-static size_t	isalloc(const void *ptr);
-static void	*iralloc(void *ptr, size_t size);
-static void	idalloc(void *ptr);
 static void	malloc_print_stats(void);
+#ifdef MALLOC_DEBUG
+static void	size2bin_validate(void);
+#endif
+static bool	size2bin_init(void);
+static bool	size2bin_init_hard(void);
 static bool	malloc_init_hard(void);
 
 /*
@@ -763,31 +1188,33 @@
  */
 /******************************************************************************/
 /*
- * Begin mutex.
+ * Begin mutex.  We can't use normal pthread mutexes in all places, because
+ * they require malloc()ed memory, which causes bootstrapping issues in some
+ * cases.
  */
 
 static void
-malloc_mutex_init(malloc_mutex_t *a_mutex)
+malloc_mutex_init(malloc_mutex_t *mutex)
 {
 	static const spinlock_t lock = _SPINLOCK_INITIALIZER;
 
-	a_mutex->lock = lock;
+	mutex->lock = lock;
 }
 
 static inline void
-malloc_mutex_lock(malloc_mutex_t *a_mutex)
+malloc_mutex_lock(malloc_mutex_t *mutex)
 {
 
 	if (__isthreaded)
-		_SPINLOCK(&a_mutex->lock);
+		_SPINLOCK(&mutex->lock);
 }
 
 static inline void
-malloc_mutex_unlock(malloc_mutex_t *a_mutex)
+malloc_mutex_unlock(malloc_mutex_t *mutex)
 {
 
 	if (__isthreaded)
-		_SPINUNLOCK(&a_mutex->lock);
+		_SPINUNLOCK(&mutex->lock);
 }
 
 /*
@@ -795,6 +1222,89 @@
  */
 /******************************************************************************/
 /*
+ * Begin spin lock.  Spin locks here are actually adaptive mutexes that block
+ * after a period of spinning, because unbounded spinning would allow for
+ * priority inversion.
+ */
+
+/*
+ * We use an unpublished interface to initialize pthread mutexes with an
+ * allocation callback, in order to avoid infinite recursion.
+ */
+int	_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,
+    void *(calloc_cb)(size_t, size_t));
+
+__weak_reference(_pthread_mutex_init_calloc_cb_stub,
+    _pthread_mutex_init_calloc_cb);
+
+int
+_pthread_mutex_init_calloc_cb_stub(pthread_mutex_t *mutex,
+    void *(calloc_cb)(size_t, size_t))
+{
+
+	return (0);
+}
+
+static bool
+malloc_spin_init(pthread_mutex_t *lock)
+{
+
+	if (_pthread_mutex_init_calloc_cb(lock, base_calloc) != 0)
+		return (true);
+
+	return (false);
+}
+
+static inline unsigned
+malloc_spin_lock(pthread_mutex_t *lock)
+{
+	unsigned ret = 0;
+
+	if (__isthreaded) {
+		if (_pthread_mutex_trylock(lock) != 0) {
+			/* Exponentially back off if there are multiple CPUs. */
+			if (ncpus > 1) {
+				unsigned i;
+				volatile unsigned j;
+
+				for (i = 1; i <= SPIN_LIMIT_2POW; i++) {
+					for (j = 0; j < (1U << i); j++) {
+						ret++;
+						CPU_SPINWAIT;
+					}
+
+					if (_pthread_mutex_trylock(lock) == 0)
+						return (ret);
+				}
+			}
+
+			/*
+			 * Spinning failed.  Block until the lock becomes
+			 * available, in order to avoid indefinite priority
+			 * inversion.
+			 */
+			_pthread_mutex_lock(lock);
+			assert((ret << BLOCK_COST_2POW) != 0 || ncpus == 1);
+			return (ret << BLOCK_COST_2POW);
+		}
+	}
+
+	return (ret);
+}
+
+static inline void
+malloc_spin_unlock(pthread_mutex_t *lock)
+{
+
+	if (__isthreaded)
+		_pthread_mutex_unlock(lock);
+}
+
+/*
+ * End spin lock.
+ */
+/******************************************************************************/
+/*
  * Begin Utility functions/macros.
  */
 
@@ -810,18 +1320,23 @@
 #define	CHUNK_CEILING(s)						\
 	(((s) + chunksize_mask) & ~chunksize_mask)
 
+/* Return the smallest quantum multiple that is >= a. */
+#define	QUANTUM_CEILING(a)						\
+	(((a) + QUANTUM_MASK) & ~QUANTUM_MASK)
+
 /* Return the smallest cacheline multiple that is >= s. */
 #define	CACHELINE_CEILING(s)						\
-	(((s) + (CACHELINE - 1)) & ~(CACHELINE - 1))
+	(((s) + CACHELINE_MASK) & ~CACHELINE_MASK)
 
-/* Return the smallest quantum multiple that is >= a. */
-#define	QUANTUM_CEILING(a)						\
-	(((a) + quantum_mask) & ~quantum_mask)
+/* Return the smallest subpage multiple that is >= s. */
+#define	SUBPAGE_CEILING(s)						\
+	(((s) + SUBPAGE_MASK) & ~SUBPAGE_MASK)
 
-/* Return the smallest pagesize multiple that is >= s. */
+/* Return the smallest PAGE_SIZE multiple that is >= s. */
 #define	PAGE_CEILING(s)							\
-	(((s) + pagesize_mask) & ~pagesize_mask)
+	(((s) + PAGE_MASK) & ~PAGE_MASK)
 
+#ifdef MALLOC_TINY
 /* Compute the smallest power of 2 that is >= x. */
 static inline size_t
 pow2_ceil(size_t x)
@@ -839,6 +1354,57 @@
 	x++;
 	return (x);
 }
+#endif
+
+#ifdef MALLOC_BALANCE
+/*
+ * Use a simple linear congruential pseudo-random number generator:
+ *
+ *   prn(y) = (a*x + c) % m
+ *
+ * where the following constants ensure maximal period:
+ *
+ *   a == Odd number (relatively prime to 2^n), and (a-1) is a multiple of 4.
+ *   c == Odd number (relatively prime to 2^n).
+ *   m == 2^32
+ *
+ * See Knuth's TAOCP 3rd Ed., Vol. 2, pg. 17 for details on these constraints.
+ *
+ * This choice of m has the disadvantage that the quality of the bits is
+ * proportional to bit position.  For example. the lowest bit has a cycle of 2,
+ * the next has a cycle of 4, etc.  For this reason, we prefer to use the upper
+ * bits.
+ */
+#  define PRN_DEFINE(suffix, var, a, c)					\
+static inline void							\
+sprn_##suffix(uint32_t seed)						\
+{									\
+	var = seed;							\
+}									\
+									\
+static inline uint32_t							\
+prn_##suffix(uint32_t lg_range)						\
+{									\
+	uint32_t ret, x;						\
+									\
+	assert(lg_range > 0);						\
+	assert(lg_range <= 32);						\
+									\
+	x = (var * (a)) + (c);						\
+	var = x;							\
+	ret = x >> (32 - lg_range);					\
+									\
+	return (ret);							\
+}
+#  define SPRN(suffix, seed)	sprn_##suffix(seed)
+#  define PRN(suffix, lg_range)	prn_##suffix(lg_range)
+#endif
+
+#ifdef MALLOC_BALANCE
+/* Define the PRNG used for arena assignment. */
+static __thread uint32_t balance_x;
+PRN_DEFINE(balance, balance_x, 1297, 1301)
+#endif
 
 static void
 wrtmessage(const char *p1, const char *p2, const char *p3, const char *p4)
@@ -876,7 +1442,7 @@
  * integer printing functionality, so that malloc_printf() use can be limited to
  * MALLOC_STATS code.
  */
-#define UMAX2S_BUFSIZE	21
+#define	UMAX2S_BUFSIZE	21
 static char *
 umax2s(uintmax_t x, char *s)
 {
@@ -898,62 +1464,61 @@
 
 /******************************************************************************/
 
+#ifdef MALLOC_DSS
 static bool
-base_pages_alloc(size_t minsize)
+base_pages_alloc_dss(size_t minsize)
 {
-	size_t csize;
 
-#ifdef USE_BRK
 	/*
-	 * Do special brk allocation here, since base allocations don't need to
+	 * Do special DSS allocation here, since base allocations don't need to
 	 * be chunk-aligned.
 	 */
-	if (brk_prev != (void *)-1) {
-		void *brk_cur;
+	malloc_mutex_lock(&dss_mtx);
+	if (dss_prev != (void *)-1) {
 		intptr_t incr;
+		size_t csize = CHUNK_CEILING(minsize);
 
-		if (minsize != 0)
-			csize = CHUNK_CEILING(minsize);
-
-		malloc_mutex_lock(&brk_mtx);
 		do {
-			/* Get the current end of brk. */
-			brk_cur = sbrk(0);
+			/* Get the current end of the DSS. */
+			dss_max = sbrk(0);
 
 			/*
 			 * Calculate how much padding is necessary to
-			 * chunk-align the end of brk.  Don't worry about
-			 * brk_cur not being chunk-aligned though.
+			 * chunk-align the end of the DSS.  Don't worry about
+			 * dss_max not being chunk-aligned though.
 			 */
 			incr = (intptr_t)chunksize
-			    - (intptr_t)CHUNK_ADDR2OFFSET(brk_cur);
-			if (incr < minsize)
+			    - (intptr_t)CHUNK_ADDR2OFFSET(dss_max);
+			assert(incr >= 0);
+			if ((size_t)incr < minsize)
 				incr += csize;
 
-			brk_prev = sbrk(incr);
-			if (brk_prev == brk_cur) {
+			dss_prev = sbrk(incr);
+			if (dss_prev == dss_max) {
 				/* Success. */
-				malloc_mutex_unlock(&brk_mtx);
-				base_pages = brk_cur;
+				dss_max = (void *)((intptr_t)dss_prev + incr);
+				base_pages = dss_prev;
 				base_next_addr = base_pages;
-				base_past_addr = (void *)((uintptr_t)base_pages
-				    + incr);
+				base_past_addr = dss_max;
 #ifdef MALLOC_STATS
 				base_mapped += incr;
 #endif
+				malloc_mutex_unlock(&dss_mtx);
 				return (false);
 			}
-		} while (brk_prev != (void *)-1);
-		malloc_mutex_unlock(&brk_mtx);
-	}
-	if (minsize == 0) {
-		/*
-		 * Failure during initialization doesn't matter, so avoid
-		 * falling through to the mmap-based page mapping code.
-		 */
-		return (true);
+		} while (dss_prev != (void *)-1);
 	}
+	malloc_mutex_unlock(&dss_mtx);
+
+	return (true);
+}
 #endif
+
+static bool
+base_pages_alloc_mmap(size_t minsize)
+{
+	size_t csize;
+
 	assert(minsize != 0);
 	csize = PAGE_CEILING(minsize);
 	base_pages = pages_map(NULL, csize);
@@ -964,9 +1529,33 @@
 #ifdef MALLOC_STATS
 	base_mapped += csize;
 #endif
+
 	return (false);
 }
 
+static bool
+base_pages_alloc(size_t minsize)
+{
+
+#ifdef MALLOC_DSS
+	if (opt_mmap && minsize != 0)
+#endif
+	{
+		if (base_pages_alloc_mmap(minsize) == false)
+			return (false);
+	}
+
+#ifdef MALLOC_DSS
+	if (opt_dss) {
+		if (base_pages_alloc_dss(minsize) == false)
+			return (false);
+	}
+
+#endif
+
+	return (true);
+}
+
 static void *
 base_alloc(size_t size)
 {
@@ -977,49 +1566,57 @@
 	csize = CACHELINE_CEILING(size);
 
 	malloc_mutex_lock(&base_mtx);
-
 	/* Make sure there's enough space for the allocation. */
 	if ((uintptr_t)base_next_addr + csize > (uintptr_t)base_past_addr) {
 		if (base_pages_alloc(csize)) {
-			ret = NULL;
-			goto RETURN;
+			malloc_mutex_unlock(&base_mtx);
+			return (NULL);
 		}
 	}
-
 	/* Allocate. */
 	ret = base_next_addr;
 	base_next_addr = (void *)((uintptr_t)base_next_addr + csize);
-
-RETURN:
 	malloc_mutex_unlock(&base_mtx);
+
 	return (ret);
 }
 
-static chunk_node_t *
-base_chunk_node_alloc(void)
+static void *
+base_calloc(size_t number, size_t size)
+{
+	void *ret;
+
+	ret = base_alloc(number * size);
+	memset(ret, 0, number * size);
+
+	return (ret);
+}
+
+static extent_node_t *
+base_node_alloc(void)
 {
-	chunk_node_t *ret;
+	extent_node_t *ret;
 
 	malloc_mutex_lock(&base_mtx);
-	if (base_chunk_nodes != NULL) {
-		ret = base_chunk_nodes;
-		base_chunk_nodes = *(chunk_node_t **)ret;
+	if (base_nodes != NULL) {
+		ret = base_nodes;
+		base_nodes = *(extent_node_t **)ret;
 		malloc_mutex_unlock(&base_mtx);
 	} else {
 		malloc_mutex_unlock(&base_mtx);
-		ret = (chunk_node_t *)base_alloc(sizeof(chunk_node_t));
+		ret = (extent_node_t *)base_alloc(sizeof(extent_node_t));
 	}
 
 	return (ret);
 }
 
 static void
-base_chunk_node_dealloc(chunk_node_t *node)
+base_node_dealloc(extent_node_t *node)
 {
 
 	malloc_mutex_lock(&base_mtx);
-	*(chunk_node_t **)node = base_chunk_nodes;
-	base_chunk_nodes = node;
+	*(extent_node_t **)node = base_nodes;
+	base_nodes = node;
 	malloc_mutex_unlock(&base_mtx);
 }
 
@@ -1029,31 +1626,45 @@
 static void
 stats_print(arena_t *arena)
 {
-	unsigned i;
-	int gap_start;
+	unsigned i, gap_start;
 
-	malloc_printf(
-	    "          allocated/mapped            nmalloc      ndalloc\n");
-	malloc_printf("small: %12llu %-12s %12llu %12llu\n",
-	    arena->stats.allocated_small, "", arena->stats.nmalloc_small,
+	malloc_printf("dirty: %zu page%s dirty, %llu sweep%s,"
+	    " %llu madvise%s, %llu page%s purged\n",
+	    arena->ndirty, arena->ndirty == 1 ? "" : "s",
+	    arena->stats.npurge, arena->stats.npurge == 1 ? "" : "s",
+	    arena->stats.nmadvise, arena->stats.nmadvise == 1 ? "" : "s",
+	    arena->stats.purged, arena->stats.purged == 1 ? "" : "s");
+
+	malloc_printf("            allocated      nmalloc      ndalloc\n");
+	malloc_printf("small:   %12zu %12llu %12llu\n",
+	    arena->stats.allocated_small, arena->stats.nmalloc_small,
 	    arena->stats.ndalloc_small);
-	malloc_printf("large: %12llu %-12s %12llu %12llu\n",
-	    arena->stats.allocated_large, "", arena->stats.nmalloc_large,
+	malloc_printf("large:   %12zu %12llu %12llu\n",
+	    arena->stats.allocated_large, arena->stats.nmalloc_large,
 	    arena->stats.ndalloc_large);
-	malloc_printf("total: %12llu/%-12llu %12llu %12llu\n",
+	malloc_printf("total:   %12zu %12llu %12llu\n",
 	    arena->stats.allocated_small + arena->stats.allocated_large,
-	    arena->stats.mapped,
 	    arena->stats.nmalloc_small + arena->stats.nmalloc_large,
 	    arena->stats.ndalloc_small + arena->stats.ndalloc_large);
+	malloc_printf("mapped:  %12zu\n", arena->stats.mapped);
 
-	malloc_printf("bins:     bin   size regs pgs  requests   newruns"
-	    "    reruns maxruns curruns\n");
-	for (i = 0, gap_start = -1; i < ntbins + nqbins + nsbins; i++) {
-		if (arena->bins[i].stats.nrequests == 0) {
-			if (gap_start == -1)
+#ifdef MALLOC_MAG
+	if (__isthreaded && opt_mag) {
+		malloc_printf("bins:     bin   size regs pgs      mags   "
+		    "newruns    reruns maxruns curruns\n");
+	} else {
+#endif
+		malloc_printf("bins:     bin   size regs pgs  requests   "
+		    "newruns    reruns maxruns curruns\n");
+#ifdef MALLOC_MAG
+	}
+#endif
+	for (i = 0, gap_start = UINT_MAX; i < nbins; i++) {
+		if (arena->bins[i].stats.nruns == 0) {
+			if (gap_start == UINT_MAX)
 				gap_start = i;
 		} else {
-			if (gap_start != -1) {
+			if (gap_start != UINT_MAX) {
 				if (i > gap_start + 1) {
 					/* Gap of more than one size class. */
 					malloc_printf("[%u..%u]\n",
@@ -1062,16 +1673,21 @@
 					/* Gap of one size class. */
 					malloc_printf("[%u]\n", gap_start);
 				}
-				gap_start = -1;
+				gap_start = UINT_MAX;
 			}
 			malloc_printf(
 			    "%13u %1s %4u %4u %3u %9llu %9llu"
 			    " %9llu %7lu %7lu\n",
 			    i,
-			    i < ntbins ? "T" : i < ntbins + nqbins ? "Q" : "S",
+			    i < ntbins ? "T" : i < ntbins + nqbins ? "Q" :
+			    i < ntbins + nqbins + ncbins ? "C" : "S",
 			    arena->bins[i].reg_size,
 			    arena->bins[i].nregs,
-			    arena->bins[i].run_size >> pagesize_2pow,
+			    arena->bins[i].run_size >> PAGE_SHIFT,
+#ifdef MALLOC_MAG
+			    (__isthreaded && opt_mag) ?
+			    arena->bins[i].stats.nmags :
+#endif
 			    arena->bins[i].stats.nrequests,
 			    arena->bins[i].stats.nruns,
 			    arena->bins[i].stats.reruns,
@@ -1079,7 +1695,7 @@
 			    arena->bins[i].stats.curruns);
 		}
 	}
-	if (gap_start != -1) {
+	if (gap_start != UINT_MAX) {
 		if (i > gap_start + 1) {
 			/* Gap of more than one size class. */
 			malloc_printf("[%u..%u]\n", gap_start, i - 1);
@@ -1096,26 +1712,53 @@
  */
 /******************************************************************************/
 /*
- * Begin chunk management functions.
+ * Begin extent tree code.
  */
 
+#ifdef MALLOC_DSS
 static inline int
-chunk_comp(chunk_node_t *a, chunk_node_t *b)
+extent_szad_comp(extent_node_t *a, extent_node_t *b)
 {
+	int ret;
+	size_t a_size = a->size;
+	size_t b_size = b->size;
 
-	assert(a != NULL);
-	assert(b != NULL);
+	ret = (a_size > b_size) - (a_size < b_size);
+	if (ret == 0) {
+		uintptr_t a_addr = (uintptr_t)a->addr;
+		uintptr_t b_addr = (uintptr_t)b->addr;
 
-	if ((uintptr_t)a->chunk < (uintptr_t)b->chunk)
-		return (-1);
-	else if (a->chunk == b->chunk)
-		return (0);
-	else
-		return (1);
+		ret = (a_addr > b_addr) - (a_addr < b_addr);
+	}
+
+	return (ret);
+}
+
+/* Wrap red-black tree macros in functions. */
+rb_wrap(__unused static, extent_tree_szad_, extent_tree_t, extent_node_t,
+    link_szad, extent_szad_comp)
+#endif
+
+static inline int
+extent_ad_comp(extent_node_t *a, extent_node_t *b)
+{
+	uintptr_t a_addr = (uintptr_t)a->addr;
+	uintptr_t b_addr = (uintptr_t)b->addr;
+
+	return ((a_addr > b_addr) - (a_addr < b_addr));
 }
 
-/* Generate red-black tree code for chunks. */
-RB_GENERATE_STATIC(chunk_tree_s, chunk_node_s, link, chunk_comp);
+/* Wrap red-black tree macros in functions. */
+rb_wrap(__unused static, extent_tree_ad_, extent_tree_t, extent_node_t, link_ad,
+    extent_ad_comp)
+
+/*
+ * End extent tree code.
+ */
+/******************************************************************************/
+/*
+ * Begin chunk management functions.
+ */
 
 static void *
 pages_map(void *addr, size_t size)
@@ -1168,67 +1811,156 @@
 	}
 }
 
+#ifdef MALLOC_DSS
 static void *
-chunk_alloc(size_t size)
+chunk_alloc_dss(size_t size)
 {
-	void *ret, *chunk;
-	chunk_node_t *tchunk, *delchunk;
 
-	assert(size != 0);
-	assert((size & chunksize_mask) == 0);
+	/*
+	 * sbrk() uses a signed increment argument, so take care not to
+	 * interpret a huge allocation request as a negative increment.
+	 */
+	if ((intptr_t)size < 0)
+		return (NULL);
 
-	malloc_mutex_lock(&chunks_mtx);
+	malloc_mutex_lock(&dss_mtx);
+	if (dss_prev != (void *)-1) {
+		intptr_t incr;
 
-	if (size == chunksize) {
 		/*
-		 * Check for address ranges that were previously chunks and try
-		 * to use them.
+		 * The loop is necessary to recover from races with other
+		 * threads that are using the DSS for something other than
+		 * malloc.
 		 */
+		do {
+			void *ret;
 
-		tchunk = RB_MIN(chunk_tree_s, &old_chunks);
-		while (tchunk != NULL) {
-			/* Found an address range.  Try to recycle it. */
-
-			chunk = tchunk->chunk;
-			delchunk = tchunk;
-			tchunk = RB_NEXT(chunk_tree_s, &old_chunks, delchunk);
-
-			/* Remove delchunk from the tree. */
-			RB_REMOVE(chunk_tree_s, &old_chunks, delchunk);
-			base_chunk_node_dealloc(delchunk);
+			/* Get the current end of the DSS. */
+			dss_max = sbrk(0);
 
-#ifdef USE_BRK
-			if ((uintptr_t)chunk >= (uintptr_t)brk_base
-			    && (uintptr_t)chunk < (uintptr_t)brk_max) {
-				/* Re-use a previously freed brk chunk. */
-				ret = chunk;
-				goto RETURN;
+			/*
+			 * Calculate how much padding is necessary to
+			 * chunk-align the end of the DSS.
+			 */
+			incr = (intptr_t)size
+			    - (intptr_t)CHUNK_ADDR2OFFSET(dss_max);
+			if (incr == (intptr_t)size)
+				ret = dss_max;
+			else {
+				ret = (void *)((intptr_t)dss_max + incr);
+				incr += size;
 			}
-#endif
-			if ((ret = pages_map(chunk, size)) != NULL) {
+
+			dss_prev = sbrk(incr);
+			if (dss_prev == dss_max) {
 				/* Success. */
-				goto RETURN;
+				dss_max = (void *)((intptr_t)dss_prev + incr);
+				malloc_mutex_unlock(&dss_mtx);
+				return (ret);
 			}
+		} while (dss_prev != (void *)-1);
+	}
+	malloc_mutex_unlock(&dss_mtx);
+
+	return (NULL);
+}
+
+static void *
+chunk_recycle_dss(size_t size, bool zero)
+{
+	extent_node_t *node, key;
+
+	key.addr = NULL;
+	key.size = size;
+	malloc_mutex_lock(&dss_mtx);
+	node = extent_tree_szad_nsearch(&dss_chunks_szad, &key);
+	if (node != NULL) {
+		void *ret = node->addr;
+
+		/* Remove node from the tree. */
+		extent_tree_szad_remove(&dss_chunks_szad, node);
+		if (node->size == size) {
+			extent_tree_ad_remove(&dss_chunks_ad, node);
+			base_node_dealloc(node);
+		} else {
+			/*
+			 * Insert the remainder of node's address range as a
+			 * smaller chunk.  Its position within dss_chunks_ad
+			 * does not change.
+			 */
+			assert(node->size > size);
+			node->addr = (void *)((uintptr_t)node->addr + size);
+			node->size -= size;
+			extent_tree_szad_insert(&dss_chunks_szad, node);
 		}
+		malloc_mutex_unlock(&dss_mtx);
+
+		if (zero)
+			memset(ret, 0, size);
+		return (ret);
 	}
+	malloc_mutex_unlock(&dss_mtx);
+
+	return (NULL);
+}
+#endif
+
+static void *
+chunk_alloc_mmap(size_t size)
+{
+	void *ret;
+	size_t offset;
 
 	/*
-	 * Try to over-allocate, but allow the OS to place the allocation
-	 * anywhere.  Beware of size_t wrap-around.
+	 * Ideally, there would be a way to specify alignment to mmap() (like
+	 * NetBSD has), but in the absence of such a feature, we have to work
+	 * hard to efficiently create aligned mappings.  The reliable, but
+	 * expensive method is to create a mapping that is over-sized, then
+	 * trim the excess.  However, that always results in at least one call
+	 * to pages_unmap().
+	 *
+	 * A more optimistic approach is to try mapping precisely the right
+	 * amount, then try to append another mapping if alignment is off.  In
+	 * practice, this works out well as long as the application is not
+	 * interleaving mappings via direct mmap() calls.  If we do run into a
+	 * situation where there is an interleaved mapping and we are unable to
+	 * extend an unaligned mapping, our best option is to momentarily
+	 * revert to the reliable-but-expensive method.  This will tend to
+	 * leave a gap in the memory map that is too small to cause later
+	 * problems for the optimistic method.
 	 */
-	if (size + chunksize > size) {
-		if ((ret = pages_map(NULL, size + chunksize)) != NULL) {
-			size_t offset = CHUNK_ADDR2OFFSET(ret);
 
+	ret = pages_map(NULL, size);
+	if (ret == NULL)
+		return (NULL);
+
+	offset = CHUNK_ADDR2OFFSET(ret);
+	if (offset != 0) {
+		/* Try to extend chunk boundary. */
+		if (pages_map((void *)((uintptr_t)ret + size),
+		    chunksize - offset) == NULL) {
 			/*
-			 * Success.  Clean up unneeded leading/trailing space.
+			 * Extension failed.  Clean up, then revert to the
+			 * reliable-but-expensive method.
 			 */
+			pages_unmap(ret, size);
+
+			/* Beware size_t wrap-around. */
+			if (size + chunksize <= size)
+				return NULL;
+
+			ret = pages_map(NULL, size + chunksize);
+			if (ret == NULL)
+				return (NULL);
+
+			/* Clean up unneeded leading/trailing space. */
+			offset = CHUNK_ADDR2OFFSET(ret);
 			if (offset != 0) {
 				/* Leading space. */
 				pages_unmap(ret, chunksize - offset);
 
-				ret = (void *)((uintptr_t)ret + (chunksize -
-				    offset));
+				ret = (void *)((uintptr_t)ret +
+				    (chunksize - offset));
 
 				/* Trailing space. */
 				pages_unmap((void *)((uintptr_t)ret + size),
@@ -1238,74 +1970,49 @@
 				pages_unmap((void *)((uintptr_t)ret + size),
 				    chunksize);
 			}
-			goto RETURN;
+		} else {
+			/* Clean up unneeded leading space. */
+			pages_unmap(ret, chunksize - offset);
+			ret = (void *)((uintptr_t)ret + (chunksize - offset));
 		}
 	}
 
-#ifdef USE_BRK
-	/*
-	 * Try to create allocations in brk, in order to make full use of
-	 * limited address space.
-	 */
-	if (brk_prev != (void *)-1) {
-		void *brk_cur;
-		intptr_t incr;
+	return (ret);
+}
 
-		/*
-		 * The loop is necessary to recover from races with other
-		 * threads that are using brk for something other than malloc.
-		 */
-		malloc_mutex_lock(&brk_mtx);
-		do {
-			/* Get the current end of brk. */
-			brk_cur = sbrk(0);
+static void *
+chunk_alloc(size_t size, bool zero)
+{
+	void *ret;
 
-			/*
-			 * Calculate how much padding is necessary to
-			 * chunk-align the end of brk.
-			 */
-			incr = (intptr_t)size
-			    - (intptr_t)CHUNK_ADDR2OFFSET(brk_cur);
-			if (incr == size) {
-				ret = brk_cur;
-			} else {
-				ret = (void *)((intptr_t)brk_cur + incr);
-				incr += size;
-			}
+	assert(size != 0);
+	assert((size & chunksize_mask) == 0);
 
-			brk_prev = sbrk(incr);
-			if (brk_prev == brk_cur) {
-				/* Success. */
-				malloc_mutex_unlock(&brk_mtx);
-				brk_max = (void *)((intptr_t)ret + size);
-				goto RETURN;
-			}
-		} while (brk_prev != (void *)-1);
-		malloc_mutex_unlock(&brk_mtx);
+#ifdef MALLOC_DSS
+	if (opt_mmap)
+#endif
+	{
+		ret = chunk_alloc_mmap(size);
+		if (ret != NULL)
+			goto RETURN;
+	}
+
+#ifdef MALLOC_DSS
+	if (opt_dss) {
+		ret = chunk_recycle_dss(size, zero);
+		if (ret != NULL) {
+			goto RETURN;
+		}
+
+		ret = chunk_alloc_dss(size);
+		if (ret != NULL)
+			goto RETURN;
 	}
 #endif
 
 	/* All strategies for allocation failed. */
 	ret = NULL;
 RETURN:
-	if (ret != NULL) {
-		chunk_node_t key;
-		/*
-		 * Clean out any entries in old_chunks that overlap with the
-		 * memory we just allocated.
-		 */
-		key.chunk = ret;
-		tchunk = RB_NFIND(chunk_tree_s, &old_chunks, &key);
-		while (tchunk != NULL
-		    && (uintptr_t)tchunk->chunk >= (uintptr_t)ret
-		    && (uintptr_t)tchunk->chunk < (uintptr_t)ret + size) {
-			delchunk = tchunk;
-			tchunk = RB_NEXT(chunk_tree_s, &old_chunks, delchunk);
-			RB_REMOVE(chunk_tree_s, &old_chunks, delchunk);
-			base_chunk_node_dealloc(delchunk);
-		}
-
-	}
 #ifdef MALLOC_STATS
 	if (ret != NULL) {
 		stats_chunks.nchunks += (size / chunksize);
@@ -1314,100 +2021,149 @@
 	if (stats_chunks.curchunks > stats_chunks.highchunks)
 		stats_chunks.highchunks = stats_chunks.curchunks;
 #endif
-	malloc_mutex_unlock(&chunks_mtx);
 
 	assert(CHUNK_ADDR2BASE(ret) == ret);
 	return (ret);
 }
 
-static void
-chunk_dealloc(void *chunk, size_t size)
-{
-	chunk_node_t *node;
+#ifdef MALLOC_DSS
+static extent_node_t *
+chunk_dealloc_dss_record(void *chunk, size_t size)
+{
+	extent_node_t *node, *prev, key;
+
+	key.addr = (void *)((uintptr_t)chunk + size);
+	node = extent_tree_ad_nsearch(&dss_chunks_ad, &key);
+	/* Try to coalesce forward. */
+	if (node != NULL && node->addr == key.addr) {
+		/*
+		 * Coalesce chunk with the following address range.  This does
+		 * not change the position within dss_chunks_ad, so only
+		 * remove/insert from/into dss_chunks_szad.
+		 */
+		extent_tree_szad_remove(&dss_chunks_szad, node);
+		node->addr = chunk;
+		node->size += size;
+		extent_tree_szad_insert(&dss_chunks_szad, node);
+	} else {
+		/*
+		 * Coalescing forward failed, so insert a new node.  Drop
+		 * dss_mtx during node allocation, since it is possible that a
+		 * new base chunk will be allocated.
+		 */
+		malloc_mutex_unlock(&dss_mtx);
+		node = base_node_alloc();
+		malloc_mutex_lock(&dss_mtx);
+		if (node == NULL)
+			return (NULL);
+		node->addr = chunk;
+		node->size = size;
+		extent_tree_ad_insert(&dss_chunks_ad, node);
+		extent_tree_szad_insert(&dss_chunks_szad, node);
+	}
 
-	assert(chunk != NULL);
-	assert(CHUNK_ADDR2BASE(chunk) == chunk);
-	assert(size != 0);
-	assert((size & chunksize_mask) == 0);
+	/* Try to coalesce backward. */
+	prev = extent_tree_ad_prev(&dss_chunks_ad, node);
+	if (prev != NULL && (void *)((uintptr_t)prev->addr + prev->size) ==
+	    chunk) {
+		/*
+		 * Coalesce chunk with the previous address range.  This does
+		 * not change the position within dss_chunks_ad, so only
+		 * remove/insert node from/into dss_chunks_szad.
+		 */
+		extent_tree_szad_remove(&dss_chunks_szad, prev);
+		extent_tree_ad_remove(&dss_chunks_ad, prev);
 
-	malloc_mutex_lock(&chunks_mtx);
+		extent_tree_szad_remove(&dss_chunks_szad, node);
+		node->addr = prev->addr;
+		node->size += prev->size;
+		extent_tree_szad_insert(&dss_chunks_szad, node);
 
-#ifdef USE_BRK
-	if ((uintptr_t)chunk >= (uintptr_t)brk_base
-	    && (uintptr_t)chunk < (uintptr_t)brk_max) {
-		void *brk_cur;
-
-		malloc_mutex_lock(&brk_mtx);
-		/* Get the current end of brk. */
-		brk_cur = sbrk(0);
-
-		/*
-		 * Try to shrink the data segment if this chunk is at the end
-		 * of the data segment.  The sbrk() call here is subject to a
-		 * race condition with threads that use brk(2) or sbrk(2)
-		 * directly, but the alternative would be to leak memory for
-		 * the sake of poorly designed multi-threaded programs.
-		 */
-		if (brk_cur == brk_max
-		    && (void *)((uintptr_t)chunk + size) == brk_max
-		    && sbrk(-(intptr_t)size) == brk_max) {
-			malloc_mutex_unlock(&brk_mtx);
-			if (brk_prev == brk_max) {
-				/* Success. */
-				brk_prev = (void *)((intptr_t)brk_max
-				    - (intptr_t)size);
-				brk_max = brk_prev;
-			}
-		} else {
-			size_t offset;
+		base_node_dealloc(prev);
+	}
 
-			malloc_mutex_unlock(&brk_mtx);
-			madvise(chunk, size, MADV_FREE);
+	return (node);
+}
 
-			/*
-			 * Iteratively create records of each chunk-sized
-			 * memory region that 'chunk' is comprised of, so that
-			 * the address range can be recycled if memory usage
-			 * increases later on.
-			 */
-			for (offset = 0; offset < size; offset += chunksize) {
-				node = base_chunk_node_alloc();
-				if (node == NULL)
-					break;
+static bool
+chunk_dealloc_dss(void *chunk, size_t size)
+{
 
-				node->chunk = (void *)((uintptr_t)chunk
-				    + (uintptr_t)offset);
-				node->size = chunksize;
-				RB_INSERT(chunk_tree_s, &old_chunks, node);
-			}
+	malloc_mutex_lock(&dss_mtx);
+	if ((uintptr_t)chunk >= (uintptr_t)dss_base
+	    && (uintptr_t)chunk < (uintptr_t)dss_max) {
+		extent_node_t *node;
+
+		/* Try to coalesce with other unused chunks. */
+		node = chunk_dealloc_dss_record(chunk, size);
+		if (node != NULL) {
+			chunk = node->addr;
+			size = node->size;
 		}
-	} else {
-#endif
-		pages_unmap(chunk, size);
+
+		/* Get the current end of the DSS. */
+		dss_max = sbrk(0);
 
 		/*
-		 * Make a record of the chunk's address, so that the address
-		 * range can be recycled if memory usage increases later on.
-		 * Don't bother to create entries if (size > chunksize), since
-		 * doing so could cause scalability issues for truly gargantuan
-		 * objects (many gigabytes or larger).
+		 * Try to shrink the DSS if this chunk is at the end of the
+		 * DSS.  The sbrk() call here is subject to a race condition
+		 * with threads that use brk(2) or sbrk(2) directly, but the
+		 * alternative would be to leak memory for the sake of poorly
+		 * designed multi-threaded programs.
 		 */
-		if (size == chunksize) {
-			node = base_chunk_node_alloc();
+		if ((void *)((uintptr_t)chunk + size) == dss_max
+		    && (dss_prev = sbrk(-(intptr_t)size)) == dss_max) {
+			/* Success. */
+			dss_max = (void *)((intptr_t)dss_prev - (intptr_t)size);
+
 			if (node != NULL) {
-				node->chunk = (void *)(uintptr_t)chunk;
-				node->size = chunksize;
-				RB_INSERT(chunk_tree_s, &old_chunks, node);
+				extent_tree_szad_remove(&dss_chunks_szad, node);
+				extent_tree_ad_remove(&dss_chunks_ad, node);
+				base_node_dealloc(node);
 			}
+			malloc_mutex_unlock(&dss_mtx);
+		} else {
+			malloc_mutex_unlock(&dss_mtx);
+			madvise(chunk, size, MADV_FREE);
 		}
-#ifdef USE_BRK
+
+		return (false);
 	}
+	malloc_mutex_unlock(&dss_mtx);
+
+	return (true);
+}
 #endif
 
+static void
+chunk_dealloc_mmap(void *chunk, size_t size)
+{
+
+	pages_unmap(chunk, size);
+}
+
+static void
+chunk_dealloc(void *chunk, size_t size)
+{
+
+	assert(chunk != NULL);
+	assert(CHUNK_ADDR2BASE(chunk) == chunk);
+	assert(size != 0);
+	assert((size & chunksize_mask) == 0);
+
 #ifdef MALLOC_STATS
 	stats_chunks.curchunks -= (size / chunksize);
 #endif
-	malloc_mutex_unlock(&chunks_mtx);
+
+#ifdef MALLOC_DSS
+	if (opt_dss) {
+		if (chunk_dealloc_dss(chunk, size) == false)
+			return;
+	}
+
+	if (opt_mmap)
+#endif
+		chunk_dealloc_mmap(chunk, size);
 }
 
 /*
@@ -1434,20 +2190,17 @@
 	 */
 #ifndef NO_TLS
 	if (__isthreaded == false) {
-	    /*
-	     * Avoid the overhead of TLS for single-threaded operation.  If the
-	     * app switches to threaded mode, the initial thread may end up
-	     * being assigned to some other arena, but this one-time switch
-	     * shouldn't cause significant issues.
-	     */
+	    /* Avoid the overhead of TLS for single-threaded operation. */
 	    return (arenas[0]);
 	}
 
 	ret = arenas_map;
-	if (ret == NULL)
+	if (ret == NULL) {
 		ret = choose_arena_hard();
+		assert(ret != NULL);
+	}
 #else
-	if (__isthreaded) {
+	if (__isthreaded && narenas > 1) {
 		unsigned long ind;
 
 		/*
@@ -1479,12 +2232,12 @@
 			 * Avoid races with another thread that may have already
 			 * initialized arenas[ind].
 			 */
-			malloc_mutex_lock(&arenas_mtx);
+			malloc_spin_lock(&arenas_lock);
 			if (arenas[ind] == NULL)
 				ret = arenas_extend((unsigned)ind);
 			else
 				ret = arenas[ind];
-			malloc_mutex_unlock(&arenas_mtx);
+			malloc_spin_unlock(&arenas_lock);
 		}
 	} else
 		ret = arenas[0];
@@ -1506,21 +2259,32 @@
 
 	assert(__isthreaded);
 
-	/* Assign one of the arenas to this thread, in a round-robin fashion. */
-	malloc_mutex_lock(&arenas_mtx);
-	ret = arenas[next_arena];
-	if (ret == NULL)
-		ret = arenas_extend(next_arena);
-	if (ret == NULL) {
-		/*
-		 * Make sure that this function never returns NULL, so that
-		 * choose_arena() doesn't have to check for a NULL return
-		 * value.
-		 */
+#ifdef MALLOC_BALANCE
+	/* Seed the PRNG used for arena load balancing. */
+	SPRN(balance, (uint32_t)(uintptr_t)(_pthread_self()));
+#endif
+
+	if (narenas > 1) {
+#ifdef MALLOC_BALANCE
+		unsigned ind;
+
+		ind = PRN(balance, narenas_2pow);
+		if ((ret = arenas[ind]) == NULL) {
+			malloc_spin_lock(&arenas_lock);
+			if ((ret = arenas[ind]) == NULL)
+				ret = arenas_extend(ind);
+			malloc_spin_unlock(&arenas_lock);
+		}
+#else
+		malloc_spin_lock(&arenas_lock);
+		if ((ret = arenas[next_arena]) == NULL)
+			ret = arenas_extend(next_arena);
+		next_arena = (next_arena + 1) % narenas;
+		malloc_spin_unlock(&arenas_lock);
+#endif
+	} else
 		ret = arenas[0];
-	}
-	next_arena = (next_arena + 1) % narenas;
-	malloc_mutex_unlock(&arenas_mtx);
+
 	arenas_map = ret;
 
 	return (ret);
@@ -1530,38 +2294,66 @@
 static inline int
 arena_chunk_comp(arena_chunk_t *a, arena_chunk_t *b)
 {
+	uintptr_t a_chunk = (uintptr_t)a;
+	uintptr_t b_chunk = (uintptr_t)b;
 
 	assert(a != NULL);
 	assert(b != NULL);
 
-	if ((uintptr_t)a < (uintptr_t)b)
-		return (-1);
-	else if (a == b)
-		return (0);
-	else
-		return (1);
+	return ((a_chunk > b_chunk) - (a_chunk < b_chunk));
 }
 
-/* Generate red-black tree code for arena chunks. */
-RB_GENERATE_STATIC(arena_chunk_tree_s, arena_chunk_s, link, arena_chunk_comp);
+/* Wrap red-black tree macros in functions. */
+rb_wrap(__unused static, arena_chunk_tree_dirty_, arena_chunk_tree_t,
+    arena_chunk_t, link_dirty, arena_chunk_comp)
 
 static inline int
-arena_run_comp(arena_run_t *a, arena_run_t *b)
+arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
 {
+	uintptr_t a_mapelm = (uintptr_t)a;
+	uintptr_t b_mapelm = (uintptr_t)b;
 
 	assert(a != NULL);
 	assert(b != NULL);
 
-	if ((uintptr_t)a < (uintptr_t)b)
-		return (-1);
-	else if (a == b)
-		return (0);
-	else
-		return (1);
+	return ((a_mapelm > b_mapelm) - (a_mapelm < b_mapelm));
+}
+
+/* Wrap red-black tree macros in functions. */
+rb_wrap(__unused static, arena_run_tree_, arena_run_tree_t, arena_chunk_map_t,
+    link, arena_run_comp)
+
+static inline int
+arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
+{
+	int ret;
+	size_t a_size = a->bits & ~PAGE_MASK;
+	size_t b_size = b->bits & ~PAGE_MASK;
+
+	ret = (a_size > b_size) - (a_size < b_size);
+	if (ret == 0) {
+		uintptr_t a_mapelm, b_mapelm;
+
+		if ((a->bits & CHUNK_MAP_KEY) == 0)
+			a_mapelm = (uintptr_t)a;
+		else {
+			/*
+			 * Treat keys as though they are lower than anything
+			 * else.
+			 */
+			a_mapelm = 0;
+		}
+		b_mapelm = (uintptr_t)b;
+
+		ret = (a_mapelm > b_mapelm) - (a_mapelm < b_mapelm);
+	}
+
+	return (ret);
 }
 
-/* Generate red-black tree code for arena runs. */
-RB_GENERATE_STATIC(arena_run_tree_s, arena_run_s, link, arena_run_comp);
+/* Wrap red-black tree macros in functions. */
+rb_wrap(__unused static, arena_avail_tree_, arena_avail_tree_t,
+    arena_chunk_map_t, link, arena_avail_comp)
 
 static inline void *
 arena_run_reg_alloc(arena_run_t *run, arena_bin_t *bin)
@@ -1584,11 +2376,12 @@
 		bit = ffs((int)mask) - 1;
 
 		regind = ((i << (SIZEOF_INT_2POW + 3)) + bit);
+		assert(regind < bin->nregs);
 		ret = (void *)(((uintptr_t)run) + bin->reg0_offset
 		    + (bin->reg_size * regind));
 
 		/* Clear bit. */
-		mask ^= (1 << bit);
+		mask ^= (1U << bit);
 		run->regs_mask[i] = mask;
 
 		return (ret);
@@ -1601,11 +2394,12 @@
 			bit = ffs((int)mask) - 1;
 
 			regind = ((i << (SIZEOF_INT_2POW + 3)) + bit);
+			assert(regind < bin->nregs);
 			ret = (void *)(((uintptr_t)run) + bin->reg0_offset
 			    + (bin->reg_size * regind));
 
 			/* Clear bit. */
-			mask ^= (1 << bit);
+			mask ^= (1U << bit);
 			run->regs_mask[i] = mask;
 
 			/*
@@ -1625,44 +2419,9 @@
 static inline void
 arena_run_reg_dalloc(arena_run_t *run, arena_bin_t *bin, void *ptr, size_t size)
 {
-	/*
-	 * To divide by a number D that is not a power of two we multiply
-	 * by (2^21 / D) and then right shift by 21 positions.
-	 *
-	 *   X / D
-	 *
-	 * becomes
-	 *
-	 *   (X * size_invs[(D >> QUANTUM_2POW_MIN) - 3]) >> SIZE_INV_SHIFT
-	 */
-#define SIZE_INV_SHIFT 21
-#define SIZE_INV(s) (((1 << SIZE_INV_SHIFT) / (s << QUANTUM_2POW_MIN)) + 1)
-	static const unsigned size_invs[] = {
-	    SIZE_INV(3),
-	    SIZE_INV(4), SIZE_INV(5), SIZE_INV(6), SIZE_INV(7),
-	    SIZE_INV(8), SIZE_INV(9), SIZE_INV(10), SIZE_INV(11),
-	    SIZE_INV(12),SIZE_INV(13), SIZE_INV(14), SIZE_INV(15),
-	    SIZE_INV(16),SIZE_INV(17), SIZE_INV(18), SIZE_INV(19),
-	    SIZE_INV(20),SIZE_INV(21), SIZE_INV(22), SIZE_INV(23),
-	    SIZE_INV(24),SIZE_INV(25), SIZE_INV(26), SIZE_INV(27),
-	    SIZE_INV(28),SIZE_INV(29), SIZE_INV(30), SIZE_INV(31)
-#if (QUANTUM_2POW_MIN < 4)
-	    ,
-	    SIZE_INV(32), SIZE_INV(33), SIZE_INV(34), SIZE_INV(35),
-	    SIZE_INV(36), SIZE_INV(37), SIZE_INV(38), SIZE_INV(39),
-	    SIZE_INV(40), SIZE_INV(41), SIZE_INV(42), SIZE_INV(43),
-	    SIZE_INV(44), SIZE_INV(45), SIZE_INV(46), SIZE_INV(47),
-	    SIZE_INV(48), SIZE_INV(49), SIZE_INV(50), SIZE_INV(51),
-	    SIZE_INV(52), SIZE_INV(53), SIZE_INV(54), SIZE_INV(55),
-	    SIZE_INV(56), SIZE_INV(57), SIZE_INV(58), SIZE_INV(59),
-	    SIZE_INV(60), SIZE_INV(61), SIZE_INV(62), SIZE_INV(63)
-#endif
-	};
 	unsigned diff, regind, elm, bit;
 
 	assert(run->magic == ARENA_RUN_MAGIC);
-	assert(((sizeof(size_invs)) / sizeof(unsigned)) + 3
-	    >= (SMALL_MAX_DEFAULT >> QUANTUM_2POW_MIN));
 
 	/*
 	 * Avoid doing division with a variable divisor if possible.  Using
@@ -1691,26 +2450,89 @@
 			regind = (diff >> log2_table[size - 1]);
 		else if (size <= 32768)
 			regind = diff >> (8 + log2_table[(size >> 8) - 1]);
-		else {
-			/*
-			 * The page size is too large for us to use the lookup
-			 * table.  Use real division.
-			 */
+		else
 			regind = diff / size;
-		}
-	} else if (size <= ((sizeof(size_invs) / sizeof(unsigned))
-	    << QUANTUM_2POW_MIN) + 2) {
-		regind = size_invs[(size >> QUANTUM_2POW_MIN) - 3] * diff;
-		regind >>= SIZE_INV_SHIFT;
-	} else {
+	} else if (size < qspace_max) {
 		/*
-		 * size_invs isn't large enough to handle this size class, so
-		 * calculate regind using actual division.  This only happens
-		 * if the user increases small_max via the 'S' runtime
-		 * configuration option.
+		 * To divide by a number D that is not a power of two we
+		 * multiply by (2^21 / D) and then right shift by 21 positions.
+		 *
+		 *   X / D
+		 *
+		 * becomes
+		 *
+		 *   (X * qsize_invs[(D >> QUANTUM_2POW) - 3])
+		 *       >> SIZE_INV_SHIFT
+		 *
+		 * We can omit the first three elements, because we never
+		 * divide by 0, and QUANTUM and 2*QUANTUM are both powers of
+		 * two, which are handled above.
 		 */
-		regind = diff / size;
-	};
+#define	SIZE_INV_SHIFT 21
+#define	QSIZE_INV(s) (((1U << SIZE_INV_SHIFT) / (s << QUANTUM_2POW)) + 1)
+		static const unsigned qsize_invs[] = {
+		    QSIZE_INV(3),
+		    QSIZE_INV(4), QSIZE_INV(5), QSIZE_INV(6), QSIZE_INV(7)
+#if (QUANTUM_2POW < 4)
+		    ,
+		    QSIZE_INV(8), QSIZE_INV(9), QSIZE_INV(10), QSIZE_INV(11),
+		    QSIZE_INV(12),QSIZE_INV(13), QSIZE_INV(14), QSIZE_INV(15)
+#endif
+		};
+		assert(QUANTUM * (((sizeof(qsize_invs)) / sizeof(unsigned)) + 3)
+		    >= (1U << QSPACE_MAX_2POW_DEFAULT));
+
+		if (size <= (((sizeof(qsize_invs) / sizeof(unsigned)) + 2) <<
+		    QUANTUM_2POW)) {
+			regind = qsize_invs[(size >> QUANTUM_2POW) - 3] * diff;
+			regind >>= SIZE_INV_SHIFT;
+		} else
+			regind = diff / size;
+#undef QSIZE_INV
+	} else if (size < cspace_max) {
+#define	CSIZE_INV(s) (((1U << SIZE_INV_SHIFT) / (s << CACHELINE_2POW)) + 1)
+		static const unsigned csize_invs[] = {
+		    CSIZE_INV(3),
+		    CSIZE_INV(4), CSIZE_INV(5), CSIZE_INV(6), CSIZE_INV(7)
+		};
+		assert(CACHELINE * (((sizeof(csize_invs)) / sizeof(unsigned)) +
+		    3) >= (1U << CSPACE_MAX_2POW_DEFAULT));
+
+		if (size <= (((sizeof(csize_invs) / sizeof(unsigned)) + 2) <<
+		    CACHELINE_2POW)) {
+			regind = csize_invs[(size >> CACHELINE_2POW) - 3] *
+			    diff;
+			regind >>= SIZE_INV_SHIFT;
+		} else
+			regind = diff / size;
+#undef CSIZE_INV
+	} else {
+#define	SSIZE_INV(s) (((1U << SIZE_INV_SHIFT) / (s << SUBPAGE_2POW)) + 1)
+		static const unsigned ssize_invs[] = {
+		    SSIZE_INV(3),
+		    SSIZE_INV(4), SSIZE_INV(5), SSIZE_INV(6), SSIZE_INV(7),
+		    SSIZE_INV(8), SSIZE_INV(9), SSIZE_INV(10), SSIZE_INV(11),
+		    SSIZE_INV(12), SSIZE_INV(13), SSIZE_INV(14), SSIZE_INV(15)
+#if (PAGE_SHIFT == 13)
+		    ,
+		    SSIZE_INV(16), SSIZE_INV(17), SSIZE_INV(18), SSIZE_INV(19),
+		    SSIZE_INV(20), SSIZE_INV(21), SSIZE_INV(22), SSIZE_INV(23),
+		    SSIZE_INV(24), SSIZE_INV(25), SSIZE_INV(26), SSIZE_INV(27),
+		    SSIZE_INV(28), SSIZE_INV(29), SSIZE_INV(29), SSIZE_INV(30)
+#endif
+		};
+		assert(SUBPAGE * (((sizeof(ssize_invs)) / sizeof(unsigned)) + 3)
+		    >= PAGE_SIZE);
+
+		if (size < (((sizeof(ssize_invs) / sizeof(unsigned)) + 2) <<
+		    SUBPAGE_2POW)) {
+			regind = ssize_invs[(size >> SUBPAGE_2POW) - 3] * diff;
+			regind >>= SIZE_INV_SHIFT;
+		} else
+			regind = diff / size;
+#undef SSIZE_INV
+	}
+#undef SIZE_INV_SHIFT
 	assert(diff == regind * size);
 	assert(regind < bin->nregs);
 
@@ -1718,59 +2540,94 @@
 	if (elm < run->regs_minelm)
 		run->regs_minelm = elm;
 	bit = regind - (elm << (SIZEOF_INT_2POW + 3));
-	assert((run->regs_mask[elm] & (1 << bit)) == 0);
-	run->regs_mask[elm] |= (1 << bit);
-#undef SIZE_INV
-#undef SIZE_INV_SHIFT
+	assert((run->regs_mask[elm] & (1U << bit)) == 0);
+	run->regs_mask[elm] |= (1U << bit);
 }
 
 static void
-arena_run_split(arena_t *arena, arena_run_t *run, size_t size)
+arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large,
+    bool zero)
 {
 	arena_chunk_t *chunk;
-	unsigned run_ind, map_offset, total_pages, need_pages, rem_pages;
-	unsigned i;
+	size_t old_ndirty, run_ind, total_pages, need_pages, rem_pages, i;
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
+	old_ndirty = chunk->ndirty;
 	run_ind = (unsigned)(((uintptr_t)run - (uintptr_t)chunk)
-	    >> pagesize_2pow);
-	total_pages = chunk->map[run_ind].npages;
-	need_pages = (size >> pagesize_2pow);
+	    >> PAGE_SHIFT);
+	total_pages = (chunk->map[run_ind].bits & ~PAGE_MASK) >>
+	    PAGE_SHIFT;
+	need_pages = (size >> PAGE_SHIFT);
+	assert(need_pages > 0);
 	assert(need_pages <= total_pages);
 	rem_pages = total_pages - need_pages;
 
-	/* Split enough pages from the front of run to fit allocation size. */
-	map_offset = run_ind;
-	for (i = 0; i < need_pages; i++) {
-		chunk->map[map_offset + i].npages = need_pages;
-		chunk->map[map_offset + i].pos = i;
-	}
+	arena_avail_tree_remove(&arena->runs_avail, &chunk->map[run_ind]);
 
 	/* Keep track of trailing unused pages for later use. */
 	if (rem_pages > 0) {
-		/* Update map for trailing pages. */
-		map_offset += need_pages;
-		chunk->map[map_offset].npages = rem_pages;
-		chunk->map[map_offset].pos = POS_FREE;
-		chunk->map[map_offset + rem_pages - 1].npages = rem_pages;
-		chunk->map[map_offset + rem_pages - 1].pos = POS_FREE;
+		chunk->map[run_ind+need_pages].bits = (rem_pages <<
+		    PAGE_SHIFT) | (chunk->map[run_ind+need_pages].bits &
+		    PAGE_MASK);
+		chunk->map[run_ind+total_pages-1].bits = (rem_pages <<
+		    PAGE_SHIFT) | (chunk->map[run_ind+total_pages-1].bits &
+		    PAGE_MASK);
+		arena_avail_tree_insert(&arena->runs_avail,
+		    &chunk->map[run_ind+need_pages]);
+	}
+
+	for (i = 0; i < need_pages; i++) {
+		/* Zero if necessary. */
+		if (zero) {
+			if ((chunk->map[run_ind + i].bits & CHUNK_MAP_ZEROED)
+			    == 0) {
+				memset((void *)((uintptr_t)chunk + ((run_ind
+				    + i) << PAGE_SHIFT)), 0, PAGE_SIZE);
+				/* CHUNK_MAP_ZEROED is cleared below. */
+			}
+		}
+
+		/* Update dirty page accounting. */
+		if (chunk->map[run_ind + i].bits & CHUNK_MAP_DIRTY) {
+			chunk->ndirty--;
+			arena->ndirty--;
+			/* CHUNK_MAP_DIRTY is cleared below. */
+		}
+
+		/* Initialize the chunk map. */
+		if (large) {
+			chunk->map[run_ind + i].bits = CHUNK_MAP_LARGE
+			    | CHUNK_MAP_ALLOCATED;
+		} else {
+			chunk->map[run_ind + i].bits = (size_t)run
+			    | CHUNK_MAP_ALLOCATED;
+		}
 	}
 
-	chunk->pages_used += need_pages;
+	/*
+	 * Set the run size only in the first element for large runs.  This is
+	 * primarily a debugging aid, since the lack of size info for trailing
+	 * pages only matters if the application tries to operate on an
+	 * interior pointer.
+	 */
+	if (large)
+		chunk->map[run_ind].bits |= size;
+
+	if (chunk->ndirty == 0 && old_ndirty > 0)
+		arena_chunk_tree_dirty_remove(&arena->chunks_dirty, chunk);
 }
 
 static arena_chunk_t *
 arena_chunk_alloc(arena_t *arena)
 {
 	arena_chunk_t *chunk;
+	size_t i;
 
 	if (arena->spare != NULL) {
 		chunk = arena->spare;
 		arena->spare = NULL;
-
-		RB_INSERT(arena_chunk_tree_s, &arena->chunks, chunk);
 	} else {
-		chunk = (arena_chunk_t *)chunk_alloc(chunksize);
+		chunk = (arena_chunk_t *)chunk_alloc(chunksize, true);
 		if (chunk == NULL)
 			return (NULL);
 #ifdef MALLOC_STATS
@@ -1779,29 +2636,29 @@
 
 		chunk->arena = arena;
 
-		RB_INSERT(arena_chunk_tree_s, &arena->chunks, chunk);
-
 		/*
 		 * Claim that no pages are in use, since the header is merely
 		 * overhead.
 		 */
-		chunk->pages_used = 0;
-
-		chunk->max_frun_npages = chunk_npages -
-		    arena_chunk_header_npages;
-		chunk->min_frun_ind = arena_chunk_header_npages;
+		chunk->ndirty = 0;
 
 		/*
-		 * Initialize enough of the map to support one maximal free run.
+		 * Initialize the map to contain one maximal free untouched run.
 		 */
-		chunk->map[arena_chunk_header_npages].npages = chunk_npages -
-		    arena_chunk_header_npages;
-		chunk->map[arena_chunk_header_npages].pos = POS_FREE;
-		chunk->map[chunk_npages - 1].npages = chunk_npages -
-		    arena_chunk_header_npages;
-		chunk->map[chunk_npages - 1].pos = POS_FREE;
+		for (i = 0; i < arena_chunk_header_npages; i++)
+			chunk->map[i].bits = 0;
+		chunk->map[i].bits = arena_maxclass | CHUNK_MAP_ZEROED;
+		for (i++; i < chunk_npages-1; i++) {
+			chunk->map[i].bits = CHUNK_MAP_ZEROED;
+		}
+		chunk->map[chunk_npages-1].bits = arena_maxclass |
+		    CHUNK_MAP_ZEROED;
 	}
 
+	/* Insert the run into the runs_avail tree. */
+	arena_avail_tree_insert(&arena->runs_avail,
+	    &chunk->map[arena_chunk_header_npages]);
+
 	return (chunk);
 }
 
@@ -1809,94 +2666,52 @@
 arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk)
 {
 
-	/*
-	 * Remove chunk from the chunk tree, regardless of whether this chunk
-	 * will be cached, so that the arena does not use it.
-	 */
-	RB_REMOVE(arena_chunk_tree_s, &chunk->arena->chunks, chunk);
-
-	if (opt_hint == false) {
-		if (arena->spare != NULL) {
-			chunk_dealloc((void *)arena->spare, chunksize);
+	if (arena->spare != NULL) {
+		if (arena->spare->ndirty > 0) {
+			arena_chunk_tree_dirty_remove(
+			    &chunk->arena->chunks_dirty, arena->spare);
+			arena->ndirty -= arena->spare->ndirty;
+		}
+		chunk_dealloc((void *)arena->spare, chunksize);
 #ifdef MALLOC_STATS
-			arena->stats.mapped -= chunksize;
-#endif
-		}
-		arena->spare = chunk;
-	} else {
-		assert(arena->spare == NULL);
-		chunk_dealloc((void *)chunk, chunksize);
-#ifdef MALLOC_STATS
-		arena->stats.mapped -= chunksize;
+		arena->stats.mapped -= chunksize;
 #endif
 	}
+
+	/*
+	 * Remove run from runs_avail, regardless of whether this chunk
+	 * will be cached, so that the arena does not use it.  Dirty page
+	 * flushing only uses the chunks_dirty tree, so leaving this chunk in
+	 * the chunks_* trees is sufficient for that purpose.
+	 */
+	arena_avail_tree_remove(&arena->runs_avail,
+	    &chunk->map[arena_chunk_header_npages]);
+
+	arena->spare = chunk;
 }
 
 static arena_run_t *
-arena_run_alloc(arena_t *arena, size_t size)
+arena_run_alloc(arena_t *arena, size_t size, bool large, bool zero)
 {
 	arena_chunk_t *chunk;
 	arena_run_t *run;
-	unsigned need_npages, limit_pages, compl_need_npages;
-
-	assert(size <= (chunksize - (arena_chunk_header_npages <<
-	    pagesize_2pow)));
-	assert((size & pagesize_mask) == 0);
+	arena_chunk_map_t *mapelm, key;
 
-	/*
-	 * Search through arena's chunks in address order for a free run that is
-	 * large enough.  Look for the first fit.
-	 */
-	need_npages = (size >> pagesize_2pow);
-	limit_pages = chunk_npages - arena_chunk_header_npages;
-	compl_need_npages = limit_pages - need_npages;
-	RB_FOREACH(chunk, arena_chunk_tree_s, &arena->chunks) {
-		/*
-		 * Avoid searching this chunk if there are not enough
-		 * contiguous free pages for there to possibly be a large
-		 * enough free run.
-		 */
-		if (chunk->pages_used <= compl_need_npages &&
-		    need_npages <= chunk->max_frun_npages) {
-			arena_chunk_map_t *mapelm;
-			unsigned i;
-			unsigned max_frun_npages = 0;
-			unsigned min_frun_ind = chunk_npages;
+	assert(size <= arena_maxclass);
+	assert((size & PAGE_MASK) == 0);
 
-			assert(chunk->min_frun_ind >=
-			    arena_chunk_header_npages);
-			for (i = chunk->min_frun_ind; i < chunk_npages;) {
-				mapelm = &chunk->map[i];
-				if (mapelm->pos == POS_FREE) {
-					if (mapelm->npages >= need_npages) {
-						run = (arena_run_t *)
-						    ((uintptr_t)chunk + (i <<
-						    pagesize_2pow));
-						/* Update page map. */
-						arena_run_split(arena, run,
-						    size);
-						return (run);
-					}
-					if (mapelm->npages >
-					    max_frun_npages) {
-						max_frun_npages =
-						    mapelm->npages;
-					}
-					if (i < min_frun_ind) {
-						min_frun_ind = i;
-						if (i < chunk->min_frun_ind)
-							chunk->min_frun_ind = i;
-					}
-				}
-				i += mapelm->npages;
-			}
-			/*
-			 * Search failure.  Reset cached chunk->max_frun_npages.
-			 * chunk->min_frun_ind was already reset above (if
-			 * necessary).
-			 */
-			chunk->max_frun_npages = max_frun_npages;
-		}
+	/* Search the arena's chunks for the lowest best fit. */
+	key.bits = size | CHUNK_MAP_KEY;
+	mapelm = arena_avail_tree_nsearch(&arena->runs_avail, &key);
+	if (mapelm != NULL) {
+		arena_chunk_t *run_chunk = CHUNK_ADDR2BASE(mapelm);
+		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
+		    / sizeof(arena_chunk_map_t);
+
+		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind
+		    << PAGE_SHIFT));
+		arena_run_split(arena, run, size, large, zero);
+		return (run);
 	}
 
 	/*
@@ -1906,98 +2721,240 @@
 	if (chunk == NULL)
 		return (NULL);
 	run = (arena_run_t *)((uintptr_t)chunk + (arena_chunk_header_npages <<
-	    pagesize_2pow));
+	    PAGE_SHIFT));
 	/* Update page map. */
-	arena_run_split(arena, run, size);
+	arena_run_split(arena, run, size, large, zero);
 	return (run);
 }
 
 static void
-arena_run_dalloc(arena_t *arena, arena_run_t *run, size_t size)
+arena_purge(arena_t *arena)
 {
 	arena_chunk_t *chunk;
-	unsigned run_ind, run_pages;
+	size_t i, npages;
+#ifdef MALLOC_DEBUG
+	size_t ndirty = 0;
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
+	rb_foreach_begin(arena_chunk_t, link_dirty, &arena->chunks_dirty,
+	    chunk) {
+		ndirty += chunk->ndirty;
+	} rb_foreach_end(arena_chunk_t, link_dirty, &arena->chunks_dirty, chunk)
+	assert(ndirty == arena->ndirty);
+#endif
+	assert(arena->ndirty > opt_dirty_max);
 
-	run_ind = (unsigned)(((uintptr_t)run - (uintptr_t)chunk)
-	    >> pagesize_2pow);
+#ifdef MALLOC_STATS
+	arena->stats.npurge++;
+#endif
+
+	/*
+	 * Iterate downward through chunks until enough dirty memory has been
+	 * purged.  Terminate as soon as possible in order to minimize the
+	 * number of system calls, even if a chunk has only been partially
+	 * purged.
+	 */
+	while (arena->ndirty > (opt_dirty_max >> 1)) {
+		chunk = arena_chunk_tree_dirty_last(&arena->chunks_dirty);
+		assert(chunk != NULL);
+
+		for (i = chunk_npages - 1; chunk->ndirty > 0; i--) {
+			assert(i >= arena_chunk_header_npages);
+
+			if (chunk->map[i].bits & CHUNK_MAP_DIRTY) {
+				chunk->map[i].bits ^= CHUNK_MAP_DIRTY;
+				/* Find adjacent dirty run(s). */
+				for (npages = 1; i > arena_chunk_header_npages
+				    && (chunk->map[i - 1].bits &
+				    CHUNK_MAP_DIRTY); npages++) {
+					i--;
+					chunk->map[i].bits ^= CHUNK_MAP_DIRTY;
+				}
+				chunk->ndirty -= npages;
+				arena->ndirty -= npages;
+
+				madvise((void *)((uintptr_t)chunk + (i <<
+				    PAGE_SHIFT)), (npages << PAGE_SHIFT),
+				    MADV_FREE);
+#ifdef MALLOC_STATS
+				arena->stats.nmadvise++;
+				arena->stats.purged += npages;
+#endif
+				if (arena->ndirty <= (opt_dirty_max >> 1))
+					break;
+			}
+		}
+
+		if (chunk->ndirty == 0) {
+			arena_chunk_tree_dirty_remove(&arena->chunks_dirty,
+			    chunk);
+		}
+	}
+}
+
+static void
+arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty)
+{
+	arena_chunk_t *chunk;
+	size_t size, run_ind, run_pages;
+
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
+	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk)
+	    >> PAGE_SHIFT);
 	assert(run_ind >= arena_chunk_header_npages);
-	assert(run_ind < (chunksize >> pagesize_2pow));
-	run_pages = (size >> pagesize_2pow);
-	assert(run_pages == chunk->map[run_ind].npages);
-
-	/* Subtract pages from count of pages used in chunk. */
-	chunk->pages_used -= run_pages;
-
-	/* Mark run as deallocated. */
-	assert(chunk->map[run_ind].npages == run_pages);
-	chunk->map[run_ind].pos = POS_FREE;
-	assert(chunk->map[run_ind + run_pages - 1].npages == run_pages);
-	chunk->map[run_ind + run_pages - 1].pos = POS_FREE;
-
-	/*
-	 * Tell the kernel that we don't need the data in this run, but only if
-	 * requested via runtime configuration.
-	 */
-	if (opt_hint)
-		madvise(run, size, MADV_FREE);
-
-	/* Try to coalesce with neighboring runs. */
-	if (run_ind > arena_chunk_header_npages &&
-	    chunk->map[run_ind - 1].pos == POS_FREE) {
-		unsigned prev_npages;
-
-		/* Coalesce with previous run. */
-		prev_npages = chunk->map[run_ind - 1].npages;
-		run_ind -= prev_npages;
-		assert(chunk->map[run_ind].npages == prev_npages);
-		assert(chunk->map[run_ind].pos == POS_FREE);
-		run_pages += prev_npages;
-
-		chunk->map[run_ind].npages = run_pages;
-		assert(chunk->map[run_ind].pos == POS_FREE);
-		chunk->map[run_ind + run_pages - 1].npages = run_pages;
-		assert(chunk->map[run_ind + run_pages - 1].pos == POS_FREE);
+	assert(run_ind < chunk_npages);
+	if ((chunk->map[run_ind].bits & CHUNK_MAP_LARGE) != 0)
+		size = chunk->map[run_ind].bits & ~PAGE_MASK;
+	else
+		size = run->bin->run_size;
+	run_pages = (size >> PAGE_SHIFT);
+
+	/* Mark pages as unallocated in the chunk map. */
+	if (dirty) {
+		size_t i;
+
+		for (i = 0; i < run_pages; i++) {
+			assert((chunk->map[run_ind + i].bits & CHUNK_MAP_DIRTY)
+			    == 0);
+			chunk->map[run_ind + i].bits = CHUNK_MAP_DIRTY;
+		}
+
+		if (chunk->ndirty == 0) {
+			arena_chunk_tree_dirty_insert(&arena->chunks_dirty,
+			    chunk);
+		}
+		chunk->ndirty += run_pages;
+		arena->ndirty += run_pages;
+	} else {
+		size_t i;
+
+		for (i = 0; i < run_pages; i++) {
+			chunk->map[run_ind + i].bits &= ~(CHUNK_MAP_LARGE |
+			    CHUNK_MAP_ALLOCATED);
+		}
 	}
+	chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
+	    PAGE_MASK);
+	chunk->map[run_ind+run_pages-1].bits = size |
+	    (chunk->map[run_ind+run_pages-1].bits & PAGE_MASK);
 
+	/* Try to coalesce forward. */
 	if (run_ind + run_pages < chunk_npages &&
-	    chunk->map[run_ind + run_pages].pos == POS_FREE) {
-		unsigned next_npages;
+	    (chunk->map[run_ind+run_pages].bits & CHUNK_MAP_ALLOCATED) == 0) {
+		size_t nrun_size = chunk->map[run_ind+run_pages].bits &
+		    ~PAGE_MASK;
+
+		/*
+		 * Remove successor from runs_avail; the coalesced run is
+		 * inserted later.
+		 */
+		arena_avail_tree_remove(&arena->runs_avail,
+		    &chunk->map[run_ind+run_pages]);
+
+		size += nrun_size;
+		run_pages = size >> PAGE_SHIFT;
+
+		assert((chunk->map[run_ind+run_pages-1].bits & ~PAGE_MASK)
+		    == nrun_size);
+		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
+		    PAGE_MASK);
+		chunk->map[run_ind+run_pages-1].bits = size |
+		    (chunk->map[run_ind+run_pages-1].bits & PAGE_MASK);
+	}
+
+	/* Try to coalesce backward. */
+	if (run_ind > arena_chunk_header_npages && (chunk->map[run_ind-1].bits &
+	    CHUNK_MAP_ALLOCATED) == 0) {
+		size_t prun_size = chunk->map[run_ind-1].bits & ~PAGE_MASK;
+
+		run_ind -= prun_size >> PAGE_SHIFT;
 
-		/* Coalesce with next run. */
-		next_npages = chunk->map[run_ind + run_pages].npages;
-		run_pages += next_npages;
-		assert(chunk->map[run_ind + run_pages - 1].npages ==
-		    next_npages);
-		assert(chunk->map[run_ind + run_pages - 1].pos == POS_FREE);
-
-		chunk->map[run_ind].npages = run_pages;
-		chunk->map[run_ind].pos = POS_FREE;
-		chunk->map[run_ind + run_pages - 1].npages = run_pages;
-		assert(chunk->map[run_ind + run_pages - 1].pos == POS_FREE);
-	}
-
-	if (chunk->map[run_ind].npages > chunk->max_frun_npages)
-		chunk->max_frun_npages = chunk->map[run_ind].npages;
-	if (run_ind < chunk->min_frun_ind)
-		chunk->min_frun_ind = run_ind;
+		/*
+		 * Remove predecessor from runs_avail; the coalesced run is
+		 * inserted later.
+		 */
+		arena_avail_tree_remove(&arena->runs_avail,
+		    &chunk->map[run_ind]);
+
+		size += prun_size;
+		run_pages = size >> PAGE_SHIFT;
+
+		assert((chunk->map[run_ind].bits & ~PAGE_MASK) ==
+		    prun_size);
+		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
+		    PAGE_MASK);
+		chunk->map[run_ind+run_pages-1].bits = size |
+		    (chunk->map[run_ind+run_pages-1].bits & PAGE_MASK);
+	}
+
+	/* Insert into runs_avail, now that coalescing is complete. */
+	arena_avail_tree_insert(&arena->runs_avail, &chunk->map[run_ind]);
 
 	/* Deallocate chunk if it is now completely unused. */
-	if (chunk->pages_used == 0)
+	if ((chunk->map[arena_chunk_header_npages].bits & (~PAGE_MASK |
+	    CHUNK_MAP_ALLOCATED)) == arena_maxclass)
 		arena_chunk_dealloc(arena, chunk);
+
+	/* Enforce opt_dirty_max. */
+	if (arena->ndirty > opt_dirty_max)
+		arena_purge(arena);
+}
+
+static void
+arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
+    size_t oldsize, size_t newsize)
+{
+	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> PAGE_SHIFT;
+	size_t head_npages = (oldsize - newsize) >> PAGE_SHIFT;
+
+	assert(oldsize > newsize);
+
+	/*
+	 * Update the chunk map so that arena_run_dalloc() can treat the
+	 * leading run as separately allocated.
+	 */
+	chunk->map[pageind].bits = (oldsize - newsize) | CHUNK_MAP_LARGE |
+	    CHUNK_MAP_ALLOCATED;
+	chunk->map[pageind+head_npages].bits = newsize | CHUNK_MAP_LARGE |
+	    CHUNK_MAP_ALLOCATED;
+
+	arena_run_dalloc(arena, run, false);
+}
+
+static void
+arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
+    size_t oldsize, size_t newsize, bool dirty)
+{
+	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> PAGE_SHIFT;
+	size_t npages = newsize >> PAGE_SHIFT;
+
+	assert(oldsize > newsize);
+
+	/*
+	 * Update the chunk map so that arena_run_dalloc() can treat the
+	 * trailing run as separately allocated.
+	 */
+	chunk->map[pageind].bits = newsize | CHUNK_MAP_LARGE |
+	    CHUNK_MAP_ALLOCATED;
+	chunk->map[pageind+npages].bits = (oldsize - newsize) | CHUNK_MAP_LARGE
+	    | CHUNK_MAP_ALLOCATED;
+
+	arena_run_dalloc(arena, (arena_run_t *)((uintptr_t)run + newsize),
+	    dirty);
 }
 
 static arena_run_t *
 arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin)
 {
+	arena_chunk_map_t *mapelm;
 	arena_run_t *run;
 	unsigned i, remainder;
 
 	/* Look for a usable run. */
-	if ((run = RB_MIN(arena_run_tree_s, &bin->runs)) != NULL) {
+	mapelm = arena_run_tree_first(&bin->runs);
+	if (mapelm != NULL) {
 		/* run is guaranteed to have available space. */
-		RB_REMOVE(arena_run_tree_s, &bin->runs, run);
+		arena_run_tree_remove(&bin->runs, mapelm);
+		run = (arena_run_t *)(mapelm->bits & ~PAGE_MASK);
 #ifdef MALLOC_STATS
 		bin->stats.reruns++;
 #endif
@@ -2006,19 +2963,21 @@
 	/* No existing runs have any space available. */
 
 	/* Allocate a new run. */
-	run = arena_run_alloc(arena, bin->run_size);
+	run = arena_run_alloc(arena, bin->run_size, false, false);
 	if (run == NULL)
 		return (NULL);
 
 	/* Initialize run internals. */
 	run->bin = bin;
 
-	for (i = 0; i < bin->regs_mask_nelms; i++)
+	for (i = 0; i < bin->regs_mask_nelms - 1; i++)
 		run->regs_mask[i] = UINT_MAX;
-	remainder = bin->nregs & ((1 << (SIZEOF_INT_2POW + 3)) - 1);
-	if (remainder != 0) {
+	remainder = bin->nregs & ((1U << (SIZEOF_INT_2POW + 3)) - 1);
+	if (remainder == 0)
+		run->regs_mask[i] = UINT_MAX;
+	else {
 		/* The last element has spare bits that need to be unset. */
-		run->regs_mask[i] = (UINT_MAX >> ((1 << (SIZEOF_INT_2POW + 3))
+		run->regs_mask[i] = (UINT_MAX >> ((1U << (SIZEOF_INT_2POW + 3))
 		    - remainder));
 	}
 
@@ -2085,9 +3044,8 @@
 	size_t try_run_size, good_run_size;
 	unsigned good_nregs, good_mask_nelms, good_reg0_offset;
 	unsigned try_nregs, try_mask_nelms, try_reg0_offset;
-	float max_ovrhd = RUN_MAX_OVRHD;
 
-	assert(min_run_size >= pagesize);
+	assert(min_run_size >= PAGE_SIZE);
 	assert(min_run_size <= arena_maxclass);
 	assert(min_run_size <= RUN_MAX_SMALL);
 
@@ -2103,11 +3061,11 @@
 	 */
 	try_run_size = min_run_size;
 	try_nregs = ((try_run_size - sizeof(arena_run_t)) / bin->reg_size)
-	    + 1; /* Counter-act the first line of the loop. */
+	    + 1; /* Counter-act try_nregs-- in loop. */
 	do {
 		try_nregs--;
 		try_mask_nelms = (try_nregs >> (SIZEOF_INT_2POW + 3)) +
-		    ((try_nregs & ((1 << (SIZEOF_INT_2POW + 3)) - 1)) ? 1 : 0);
+		    ((try_nregs & ((1U << (SIZEOF_INT_2POW + 3)) - 1)) ? 1 : 0);
 		try_reg0_offset = try_run_size - (try_nregs * bin->reg_size);
 	} while (sizeof(arena_run_t) + (sizeof(unsigned) * (try_mask_nelms - 1))
 	    > try_reg0_offset);
@@ -2123,22 +3081,21 @@
 		good_reg0_offset = try_reg0_offset;
 
 		/* Try more aggressive settings. */
-		try_run_size += pagesize;
+		try_run_size += PAGE_SIZE;
 		try_nregs = ((try_run_size - sizeof(arena_run_t)) /
 		    bin->reg_size) + 1; /* Counter-act try_nregs-- in loop. */
 		do {
 			try_nregs--;
 			try_mask_nelms = (try_nregs >> (SIZEOF_INT_2POW + 3)) +
-			    ((try_nregs & ((1 << (SIZEOF_INT_2POW + 3)) - 1)) ?
+			    ((try_nregs & ((1U << (SIZEOF_INT_2POW + 3)) - 1)) ?
 			    1 : 0);
 			try_reg0_offset = try_run_size - (try_nregs *
 			    bin->reg_size);
 		} while (sizeof(arena_run_t) + (sizeof(unsigned) *
 		    (try_mask_nelms - 1)) > try_reg0_offset);
 	} while (try_run_size <= arena_maxclass && try_run_size <= RUN_MAX_SMALL
-	    && max_ovrhd > RUN_MAX_OVRHD_RELAX / ((float)(bin->reg_size << 3))
-	    && ((float)(try_reg0_offset)) / ((float)(try_run_size)) >
-	    max_ovrhd);
+	    && RUN_MAX_OVRHD * (bin->reg_size << 3) > RUN_MAX_OVRHD_RELAX
+	    && (try_reg0_offset << RUN_BFP) > RUN_MAX_OVRHD * try_run_size);
 
 	assert(sizeof(arena_run_t) + (sizeof(unsigned) * (good_mask_nelms - 1))
 	    <= good_reg0_offset);
@@ -2153,107 +3110,283 @@
 	return (good_run_size);
 }
 
-static void *
-arena_malloc(arena_t *arena, size_t size)
+#ifdef MALLOC_BALANCE
+static inline void
+arena_lock_balance(arena_t *arena)
 {
-	void *ret;
-
-	assert(arena != NULL);
-	assert(arena->magic == ARENA_MAGIC);
-	assert(size != 0);
-	assert(QUANTUM_CEILING(size) <= arena_maxclass);
+	unsigned contention;
 
-	if (size <= bin_maxclass) {
-		arena_bin_t *bin;
-		arena_run_t *run;
+	contention = malloc_spin_lock(&arena->lock);
+	if (narenas > 1) {
+		/*
+		 * Calculate the exponentially averaged contention for this
+		 * arena.  Due to integer math always rounding down, this value
+		 * decays somewhat faster than normal.
+		 */
+		arena->contention = (((uint64_t)arena->contention
+		    * (uint64_t)((1U << BALANCE_ALPHA_INV_2POW)-1))
+		    + (uint64_t)contention) >> BALANCE_ALPHA_INV_2POW;
+		if (arena->contention >= opt_balance_threshold)
+			arena_lock_balance_hard(arena);
+	}
+}
 
-		/* Small allocation. */
+static void
+arena_lock_balance_hard(arena_t *arena)
+{
+	uint32_t ind;
 
-		if (size < small_min) {
-			/* Tiny. */
-			size = pow2_ceil(size);
-			bin = &arena->bins[ffs((int)(size >> (TINY_MIN_2POW +
-			    1)))];
-#if (!defined(NDEBUG) || defined(MALLOC_STATS))
-			/*
-			 * Bin calculation is always correct, but we may need
-			 * to fix size for the purposes of assertions and/or
-			 * stats accuracy.
-			 */
-			if (size < (1 << TINY_MIN_2POW))
-				size = (1 << TINY_MIN_2POW);
+	arena->contention = 0;
+#ifdef MALLOC_STATS
+	arena->stats.nbalance++;
 #endif
-		} else if (size <= small_max) {
-			/* Quantum-spaced. */
-			size = QUANTUM_CEILING(size);
-			bin = &arena->bins[ntbins + (size >> opt_quantum_2pow)
-			    - 1];
-		} else {
-			/* Sub-page. */
-			size = pow2_ceil(size);
-			bin = &arena->bins[ntbins + nqbins
-			    + (ffs((int)(size >> opt_small_max_2pow)) - 2)];
-		}
-		assert(size == bin->reg_size);
+	ind = PRN(balance, narenas_2pow);
+	if (arenas[ind] != NULL)
+		arenas_map = arenas[ind];
+	else {
+		malloc_spin_lock(&arenas_lock);
+		if (arenas[ind] != NULL)
+			arenas_map = arenas[ind];
+		else
+			arenas_map = arenas_extend(ind);
+		malloc_spin_unlock(&arenas_lock);
+	}
+}
+#endif
+
+#ifdef MALLOC_MAG
+static inline void *
+mag_alloc(mag_t *mag)
+{
+
+	if (mag->nrounds == 0)
+		return (NULL);
+	mag->nrounds--;
+
+	return (mag->rounds[mag->nrounds]);
+}
+
+static void
+mag_load(mag_t *mag)
+{
+	arena_t *arena;
+	arena_bin_t *bin;
+	arena_run_t *run;
+	void *round;
+	size_t i;
 
-		malloc_mutex_lock(&arena->mtx);
+	arena = choose_arena();
+	bin = &arena->bins[mag->binind];
+#ifdef MALLOC_BALANCE
+	arena_lock_balance(arena);
+#else
+	malloc_spin_lock(&arena->lock);
+#endif
+	for (i = mag->nrounds; i < max_rounds; i++) {
 		if ((run = bin->runcur) != NULL && run->nfree > 0)
-			ret = arena_bin_malloc_easy(arena, bin, run);
+			round = arena_bin_malloc_easy(arena, bin, run);
 		else
-			ret = arena_bin_malloc_hard(arena, bin);
+			round = arena_bin_malloc_hard(arena, bin);
+		if (round == NULL)
+			break;
+		mag->rounds[i] = round;
+	}
+#ifdef MALLOC_STATS
+	bin->stats.nmags++;
+	arena->stats.nmalloc_small += (i - mag->nrounds);
+	arena->stats.allocated_small += (i - mag->nrounds) * bin->reg_size;
+#endif
+	malloc_spin_unlock(&arena->lock);
+	mag->nrounds = i;
+}
 
-		if (ret == NULL) {
-			malloc_mutex_unlock(&arena->mtx);
+static inline void *
+mag_rack_alloc(mag_rack_t *rack, size_t size, bool zero)
+{
+	void *ret;
+	bin_mags_t *bin_mags;
+	mag_t *mag;
+	size_t binind;
+
+	binind = size2bin[size];
+	assert(binind < nbins);
+	bin_mags = &rack->bin_mags[binind];
+
+	mag = bin_mags->curmag;
+	if (mag == NULL) {
+		/* Create an initial magazine for this size class. */
+		assert(bin_mags->sparemag == NULL);
+		mag = mag_create(choose_arena(), binind);
+		if (mag == NULL)
 			return (NULL);
+		bin_mags->curmag = mag;
+		mag_load(mag);
+	}
+
+	ret = mag_alloc(mag);
+	if (ret == NULL) {
+		if (bin_mags->sparemag != NULL) {
+			if (bin_mags->sparemag->nrounds > 0) {
+				/* Swap magazines. */
+				bin_mags->curmag = bin_mags->sparemag;
+				bin_mags->sparemag = mag;
+				mag = bin_mags->curmag;
+			} else {
+				/* Reload the current magazine. */
+				mag_load(mag);
+			}
+		} else {
+			/* Create a second magazine. */
+			mag = mag_create(choose_arena(), binind);
+			if (mag == NULL)
+				return (NULL);
+			mag_load(mag);
+			bin_mags->sparemag = bin_mags->curmag;
+			bin_mags->curmag = mag;
 		}
+		ret = mag_alloc(mag);
+		if (ret == NULL)
+			return (NULL);
+	}
 
-#ifdef MALLOC_STATS
-		bin->stats.nrequests++;
-		arena->stats.nmalloc_small++;
-		arena->stats.allocated_small += size;
+	if (zero == false) {
+		if (opt_junk)
+			memset(ret, 0xa5, size);
+		else if (opt_zero)
+			memset(ret, 0, size);
+	} else
+		memset(ret, 0, size);
+
+	return (ret);
+}
 #endif
-	} else {
-		/* Large allocation. */
-		size = PAGE_CEILING(size);
-		malloc_mutex_lock(&arena->mtx);
-		ret = (void *)arena_run_alloc(arena, size);
-		if (ret == NULL) {
-			malloc_mutex_unlock(&arena->mtx);
-			return (NULL);
-		}
-#ifdef MALLOC_STATS
-		arena->stats.nmalloc_large++;
-		arena->stats.allocated_large += size;
+
+static inline void *
+arena_malloc_small(arena_t *arena, size_t size, bool zero)
+{
+	void *ret;
+	arena_bin_t *bin;
+	arena_run_t *run;
+	size_t binind;
+
+	binind = size2bin[size];
+	assert(binind < nbins);
+	bin = &arena->bins[binind];
+	size = bin->reg_size;
+
+#ifdef MALLOC_BALANCE
+	arena_lock_balance(arena);
+#else
+	malloc_spin_lock(&arena->lock);
 #endif
+	if ((run = bin->runcur) != NULL && run->nfree > 0)
+		ret = arena_bin_malloc_easy(arena, bin, run);
+	else
+		ret = arena_bin_malloc_hard(arena, bin);
+
+	if (ret == NULL) {
+		malloc_spin_unlock(&arena->lock);
+		return (NULL);
 	}
 
-	malloc_mutex_unlock(&arena->mtx);
+#ifdef MALLOC_STATS
+	bin->stats.nrequests++;
+	arena->stats.nmalloc_small++;
+	arena->stats.allocated_small += size;
+#endif
+	malloc_spin_unlock(&arena->lock);
 
-	if (opt_junk)
-		memset(ret, 0xa5, size);
-	else if (opt_zero)
+	if (zero == false) {
+		if (opt_junk)
+			memset(ret, 0xa5, size);
+		else if (opt_zero)
+			memset(ret, 0, size);
+	} else
 		memset(ret, 0, size);
+
 	return (ret);
 }
 
-static inline void
-arena_palloc_trim(arena_t *arena, arena_chunk_t *chunk, unsigned pageind,
-    unsigned npages)
+static void *
+arena_malloc_large(arena_t *arena, size_t size, bool zero)
 {
-	unsigned i;
+	void *ret;
 
-	assert(npages > 0);
+	/* Large allocation. */
+	size = PAGE_CEILING(size);
+#ifdef MALLOC_BALANCE
+	arena_lock_balance(arena);
+#else
+	malloc_spin_lock(&arena->lock);
+#endif
+	ret = (void *)arena_run_alloc(arena, size, true, zero);
+	if (ret == NULL) {
+		malloc_spin_unlock(&arena->lock);
+		return (NULL);
+	}
+#ifdef MALLOC_STATS
+	arena->stats.nmalloc_large++;
+	arena->stats.allocated_large += size;
+#endif
+	malloc_spin_unlock(&arena->lock);
 
-	/*
-	 * Modifiy the map such that arena_run_dalloc() sees the run as
-	 * separately allocated.
-	 */
-	for (i = 0; i < npages; i++) {
-		chunk->map[pageind + i].npages = npages;
-		chunk->map[pageind + i].pos = i;
+	if (zero == false) {
+		if (opt_junk)
+			memset(ret, 0xa5, size);
+		else if (opt_zero)
+			memset(ret, 0, size);
 	}
-	arena_run_dalloc(arena, (arena_run_t *)((uintptr_t)chunk + (pageind <<
-	    pagesize_2pow)), npages << pagesize_2pow);
+
+	return (ret);
+}
+
+static inline void *
+arena_malloc(arena_t *arena, size_t size, bool zero)
+{
+
+	assert(arena != NULL);
+	assert(arena->magic == ARENA_MAGIC);
+	assert(size != 0);
+	assert(QUANTUM_CEILING(size) <= arena_maxclass);
+
+	if (size <= bin_maxclass) {
+#ifdef MALLOC_MAG
+		if (__isthreaded && opt_mag) {
+			mag_rack_t *rack = mag_rack;
+			if (rack == NULL) {
+				rack = mag_rack_create(arena);
+				if (rack == NULL)
+					return (NULL);
+				mag_rack = rack;
+			}
+			return (mag_rack_alloc(rack, size, zero));
+		} else
+#endif
+			return (arena_malloc_small(arena, size, zero));
+	} else
+		return (arena_malloc_large(arena, size, zero));
+}
+
+static inline void *
+imalloc(size_t size)
+{
+
+	assert(size != 0);
+
+	if (size <= arena_maxclass)
+		return (arena_malloc(choose_arena(), size, false));
+	else
+		return (huge_malloc(size, false));
+}
+
+static inline void *
+icalloc(size_t size)
+{
+
+	if (size <= arena_maxclass)
+		return (arena_malloc(choose_arena(), size, true));
+	else
+		return (huge_malloc(size, true));
 }
 
 /* Only handles large allocations that require more than page alignment. */
@@ -2263,62 +3396,44 @@
 	void *ret;
 	size_t offset;
 	arena_chunk_t *chunk;
-	unsigned pageind, i, npages;
 
-	assert((size & pagesize_mask) == 0);
-	assert((alignment & pagesize_mask) == 0);
+	assert((size & PAGE_MASK) == 0);
+	assert((alignment & PAGE_MASK) == 0);
 
-	npages = size >> pagesize_2pow;
-
-	malloc_mutex_lock(&arena->mtx);
-	ret = (void *)arena_run_alloc(arena, alloc_size);
+#ifdef MALLOC_BALANCE
+	arena_lock_balance(arena);
+#else
+	malloc_spin_lock(&arena->lock);
+#endif
+	ret = (void *)arena_run_alloc(arena, alloc_size, true, false);
 	if (ret == NULL) {
-		malloc_mutex_unlock(&arena->mtx);
+		malloc_spin_unlock(&arena->lock);
 		return (NULL);
 	}
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ret);
 
 	offset = (uintptr_t)ret & (alignment - 1);
-	assert((offset & pagesize_mask) == 0);
+	assert((offset & PAGE_MASK) == 0);
 	assert(offset < alloc_size);
-	if (offset == 0) {
-		pageind = (((uintptr_t)ret - (uintptr_t)chunk) >>
-		    pagesize_2pow);
-
-		/* Update the map for the run to be kept. */
-		for (i = 0; i < npages; i++) {
-			chunk->map[pageind + i].npages = npages;
-			assert(chunk->map[pageind + i].pos == i);
-		}
-
-		/* Trim trailing space. */
-		arena_palloc_trim(arena, chunk, pageind + npages,
-		    (alloc_size - size) >> pagesize_2pow);
-	} else {
+	if (offset == 0)
+		arena_run_trim_tail(arena, chunk, ret, alloc_size, size, false);
+	else {
 		size_t leadsize, trailsize;
 
 		leadsize = alignment - offset;
-		ret = (void *)((uintptr_t)ret + leadsize);
-		pageind = (((uintptr_t)ret - (uintptr_t)chunk) >>
-		    pagesize_2pow);
-
-		/* Update the map for the run to be kept. */
-		for (i = 0; i < npages; i++) {
-			chunk->map[pageind + i].npages = npages;
-			chunk->map[pageind + i].pos = i;
+		if (leadsize > 0) {
+			arena_run_trim_head(arena, chunk, ret, alloc_size,
+			    alloc_size - leadsize);
+			ret = (void *)((uintptr_t)ret + leadsize);
 		}
 
-		/* Trim leading space. */
-		arena_palloc_trim(arena, chunk, pageind - (leadsize >>
-		    pagesize_2pow), leadsize >> pagesize_2pow);
-
 		trailsize = alloc_size - leadsize - size;
 		if (trailsize != 0) {
 			/* Trim trailing space. */
 			assert(trailsize < alloc_size);
-			arena_palloc_trim(arena, chunk, pageind + npages,
-			    trailsize >> pagesize_2pow);
+			arena_run_trim_tail(arena, chunk, ret, size + trailsize,
+			    size, false);
 		}
 	}
 
@@ -2326,7 +3441,7 @@
 	arena->stats.nmalloc_large++;
 	arena->stats.allocated_large += size;
 #endif
-	malloc_mutex_unlock(&arena->mtx);
+	malloc_spin_unlock(&arena->lock);
 
 	if (opt_junk)
 		memset(ret, 0xa5, size);
@@ -2335,96 +3450,395 @@
 	return (ret);
 }
 
-/* Return the size of the allocation pointed to by ptr. */
-static size_t
-arena_salloc(const void *ptr)
+static inline void *
+ipalloc(size_t alignment, size_t size)
 {
-	size_t ret;
+	void *ret;
+	size_t ceil_size;
+
+	/*
+	 * Round size up to the nearest multiple of alignment.
+	 *
+	 * This done, we can take advantage of the fact that for each small
+	 * size class, every object is aligned at the smallest power of two
+	 * that is non-zero in the base two representation of the size.  For
+	 * example:
+	 *
+	 *   Size |   Base 2 | Minimum alignment
+	 *   -----+----------+------------------
+	 *     96 |  1100000 |  32
+	 *    144 | 10100000 |  32
+	 *    192 | 11000000 |  64
+	 *
+	 * Depending on runtime settings, it is possible that arena_malloc()
+	 * will further round up to a power of two, but that never causes
+	 * correctness issues.
+	 */
+	ceil_size = (size + (alignment - 1)) & (-alignment);
+	/*
+	 * (ceil_size < size) protects against the combination of maximal
+	 * alignment and size greater than maximal alignment.
+	 */
+	if (ceil_size < size) {
+		/* size_t overflow. */
+		return (NULL);
+	}
+
+	if (ceil_size <= PAGE_SIZE || (alignment <= PAGE_SIZE
+	    && ceil_size <= arena_maxclass))
+		ret = arena_malloc(choose_arena(), ceil_size, false);
+	else {
+		size_t run_size;
+
+		/*
+		 * We can't achieve subpage alignment, so round up alignment
+		 * permanently; it makes later calculations simpler.
+		 */
+		alignment = PAGE_CEILING(alignment);
+		ceil_size = PAGE_CEILING(size);
+		/*
+		 * (ceil_size < size) protects against very large sizes within
+		 * PAGE_SIZE of SIZE_T_MAX.
+		 *
+		 * (ceil_size + alignment < ceil_size) protects against the
+		 * combination of maximal alignment and ceil_size large enough
+		 * to cause overflow.  This is similar to the first overflow
+		 * check above, but it needs to be repeated due to the new
+		 * ceil_size value, which may now be *equal* to maximal
+		 * alignment, whereas before we only detected overflow if the
+		 * original size was *greater* than maximal alignment.
+		 */
+		if (ceil_size < size || ceil_size + alignment < ceil_size) {
+			/* size_t overflow. */
+			return (NULL);
+		}
+
+		/*
+		 * Calculate the size of the over-size run that arena_palloc()
+		 * would need to allocate in order to guarantee the alignment.
+		 */
+		if (ceil_size >= alignment)
+			run_size = ceil_size + alignment - PAGE_SIZE;
+		else {
+			/*
+			 * It is possible that (alignment << 1) will cause
+			 * overflow, but it doesn't matter because we also
+			 * subtract PAGE_SIZE, which in the case of overflow
+			 * leaves us with a very large run_size.  That causes
+			 * the first conditional below to fail, which means
+			 * that the bogus run_size value never gets used for
+			 * anything important.
+			 */
+			run_size = (alignment << 1) - PAGE_SIZE;
+		}
+
+		if (run_size <= arena_maxclass) {
+			ret = arena_palloc(choose_arena(), alignment, ceil_size,
+			    run_size);
+		} else if (alignment <= chunksize)
+			ret = huge_malloc(ceil_size, false);
+		else
+			ret = huge_palloc(alignment, ceil_size);
+	}
+
+	assert(((uintptr_t)ret & (alignment - 1)) == 0);
+	return (ret);
+}
+
+/* Return the size of the allocation pointed to by ptr. */
+static size_t
+arena_salloc(const void *ptr)
+{
+	size_t ret;
 	arena_chunk_t *chunk;
-	arena_chunk_map_t *mapelm;
-	unsigned pageind;
+	size_t pageind, mapbits;
 
 	assert(ptr != NULL);
 	assert(CHUNK_ADDR2BASE(ptr) != ptr);
 
-	/*
-	 * No arena data structures that we query here can change in a way that
-	 * affects this function, so we don't need to lock.
-	 */
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> pagesize_2pow);
-	mapelm = &chunk->map[pageind];
-	if (mapelm->pos != 0 || ptr != (void *)((uintptr_t)chunk) + (pageind <<
-	    pagesize_2pow)) {
-		arena_run_t *run;
-
-		pageind -= mapelm->pos;
-
-		run = (arena_run_t *)((uintptr_t)chunk + (pageind <<
-		    pagesize_2pow));
+	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
+	mapbits = chunk->map[pageind].bits;
+	assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
+	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
+		arena_run_t *run = (arena_run_t *)(mapbits & ~PAGE_MASK);
 		assert(run->magic == ARENA_RUN_MAGIC);
 		ret = run->bin->reg_size;
-	} else
-		ret = mapelm->npages << pagesize_2pow;
+	} else {
+		ret = mapbits & ~PAGE_MASK;
+		assert(ret != 0);
+	}
 
 	return (ret);
 }
 
-static void *
-arena_ralloc(void *ptr, size_t size, size_t oldsize)
+static inline size_t
+isalloc(const void *ptr)
 {
-	void *ret;
+	size_t ret;
+	arena_chunk_t *chunk;
 
-	/* Avoid moving the allocation if the size class would not change. */
-	if (size < small_min) {
-		if (oldsize < small_min &&
-		    ffs((int)(pow2_ceil(size) >> (TINY_MIN_2POW + 1)))
-		    == ffs((int)(pow2_ceil(oldsize) >> (TINY_MIN_2POW + 1))))
-			goto IN_PLACE;
-	} else if (size <= small_max) {
-		if (oldsize >= small_min && oldsize <= small_max &&
-		    (QUANTUM_CEILING(size) >> opt_quantum_2pow)
-		    == (QUANTUM_CEILING(oldsize) >> opt_quantum_2pow))
-			goto IN_PLACE;
+	assert(ptr != NULL);
+
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+	if (chunk != ptr) {
+		/* Region. */
+		assert(chunk->arena->magic == ARENA_MAGIC);
+
+		ret = arena_salloc(ptr);
 	} else {
+		extent_node_t *node, key;
+
+		/* Chunk (huge allocation). */
+
+		malloc_mutex_lock(&huge_mtx);
+
+		/* Extract from tree of huge allocations. */
+		key.addr = __DECONST(void *, ptr);
+		node = extent_tree_ad_search(&huge, &key);
+		assert(node != NULL);
+
+		ret = node->size;
+
+		malloc_mutex_unlock(&huge_mtx);
+	}
+
+	return (ret);
+}
+
+static inline void
+arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
+    arena_chunk_map_t *mapelm)
+{
+	arena_run_t *run;
+	arena_bin_t *bin;
+	size_t size;
+
+	run = (arena_run_t *)(mapelm->bits & ~PAGE_MASK);
+	assert(run->magic == ARENA_RUN_MAGIC);
+	bin = run->bin;
+	size = bin->reg_size;
+
+	if (opt_junk)
+		memset(ptr, 0x5a, size);
+
+	arena_run_reg_dalloc(run, bin, ptr, size);
+	run->nfree++;
+
+	if (run->nfree == bin->nregs) {
+		/* Deallocate run. */
+		if (run == bin->runcur)
+			bin->runcur = NULL;
+		else if (bin->nregs != 1) {
+			size_t run_pageind = (((uintptr_t)run -
+			    (uintptr_t)chunk)) >> PAGE_SHIFT;
+			arena_chunk_map_t *run_mapelm =
+			    &chunk->map[run_pageind];
+			/*
+			 * This block's conditional is necessary because if the
+			 * run only contains one region, then it never gets
+			 * inserted into the non-full runs tree.
+			 */
+			arena_run_tree_remove(&bin->runs, run_mapelm);
+		}
+#ifdef MALLOC_DEBUG
+		run->magic = 0;
+#endif
+		arena_run_dalloc(arena, run, true);
+#ifdef MALLOC_STATS
+		bin->stats.curruns--;
+#endif
+	} else if (run->nfree == 1 && run != bin->runcur) {
 		/*
-		 * We make no attempt to resize runs here, though it would be
-		 * possible to do so.
+		 * Make sure that bin->runcur always refers to the lowest
+		 * non-full run, if one exists.
 		 */
-		if (oldsize > small_max && PAGE_CEILING(size) == oldsize)
-			goto IN_PLACE;
+		if (bin->runcur == NULL)
+			bin->runcur = run;
+		else if ((uintptr_t)run < (uintptr_t)bin->runcur) {
+			/* Switch runcur. */
+			if (bin->runcur->nfree > 0) {
+				arena_chunk_t *runcur_chunk =
+				    CHUNK_ADDR2BASE(bin->runcur);
+				size_t runcur_pageind =
+				    (((uintptr_t)bin->runcur -
+				    (uintptr_t)runcur_chunk)) >> PAGE_SHIFT;
+				arena_chunk_map_t *runcur_mapelm =
+				    &runcur_chunk->map[runcur_pageind];
+
+				/* Insert runcur. */
+				arena_run_tree_insert(&bin->runs,
+				    runcur_mapelm);
+			}
+			bin->runcur = run;
+		} else {
+			size_t run_pageind = (((uintptr_t)run -
+			    (uintptr_t)chunk)) >> PAGE_SHIFT;
+			arena_chunk_map_t *run_mapelm =
+			    &chunk->map[run_pageind];
+
+			assert(arena_run_tree_search(&bin->runs, run_mapelm) ==
+			    NULL);
+			arena_run_tree_insert(&bin->runs, run_mapelm);
+		}
 	}
+#ifdef MALLOC_STATS
+	arena->stats.allocated_small -= size;
+	arena->stats.ndalloc_small++;
+#endif
+}
 
-	/*
-	 * If we get here, then size and oldsize are different enough that we
-	 * need to use a different size class.  In that case, fall back to
-	 * allocating new space and copying.
-	 */
-	ret = arena_malloc(choose_arena(), size);
-	if (ret == NULL)
-		return (NULL);
+#ifdef MALLOC_MAG
+static void
+mag_unload(mag_t *mag)
+{
+	arena_chunk_t *chunk;
+	arena_t *arena;
+	void *round;
+	size_t i, ndeferred, nrounds;
 
-	/* Junk/zero-filling were already done by arena_malloc(). */
-	if (size < oldsize)
-		memcpy(ret, ptr, size);
-	else
-		memcpy(ret, ptr, oldsize);
-	idalloc(ptr);
-	return (ret);
-IN_PLACE:
-	if (opt_junk && size < oldsize)
-		memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize - size);
-	else if (opt_zero && size > oldsize)
-		memset((void *)((uintptr_t)ptr + oldsize), 0, size - oldsize);
-	return (ptr);
+	for (ndeferred = mag->nrounds; ndeferred > 0;) {
+		nrounds = ndeferred;
+		/* Lock the arena associated with the first round. */
+		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mag->rounds[0]);
+		arena = chunk->arena;
+#ifdef MALLOC_BALANCE
+		arena_lock_balance(arena);
+#else
+		malloc_spin_lock(&arena->lock);
+#endif
+		/* Deallocate every round that belongs to the locked arena. */
+		for (i = ndeferred = 0; i < nrounds; i++) {
+			round = mag->rounds[i];
+			chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(round);
+			if (chunk->arena == arena) {
+				size_t pageind = (((uintptr_t)round -
+				    (uintptr_t)chunk) >> PAGE_SHIFT);
+				arena_chunk_map_t *mapelm =
+				    &chunk->map[pageind];
+				arena_dalloc_small(arena, chunk, round, mapelm);
+			} else {
+				/*
+				 * This round was allocated via a different
+				 * arena than the one that is currently locked.
+				 * Stash the round, so that it can be handled
+				 * in a future pass.
+				 */
+				mag->rounds[ndeferred] = round;
+				ndeferred++;
+			}
+		}
+		malloc_spin_unlock(&arena->lock);
+	}
+
+	mag->nrounds = 0;
+}
+
+static inline void
+mag_rack_dalloc(mag_rack_t *rack, void *ptr)
+{
+	arena_t *arena;
+	arena_chunk_t *chunk;
+	arena_run_t *run;
+	arena_bin_t *bin;
+	bin_mags_t *bin_mags;
+	mag_t *mag;
+	size_t pageind, binind;
+	arena_chunk_map_t *mapelm;
+
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+	arena = chunk->arena;
+	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
+	mapelm = &chunk->map[pageind];
+	run = (arena_run_t *)(mapelm->bits & ~PAGE_MASK);
+	assert(run->magic == ARENA_RUN_MAGIC);
+	bin = run->bin;
+	binind = ((uintptr_t)bin - (uintptr_t)&arena->bins) /
+	    sizeof(arena_bin_t);
+	assert(binind < nbins);
+
+	if (opt_junk)
+		memset(ptr, 0x5a, arena->bins[binind].reg_size);
+
+	bin_mags = &rack->bin_mags[binind];
+	mag = bin_mags->curmag;
+	if (mag == NULL) {
+		/* Create an initial magazine for this size class. */
+		assert(bin_mags->sparemag == NULL);
+		mag = mag_create(choose_arena(), binind);
+		if (mag == NULL) {
+			malloc_spin_lock(&arena->lock);
+			arena_dalloc_small(arena, chunk, ptr, mapelm);
+			malloc_spin_unlock(&arena->lock);
+			return;
+		}
+		bin_mags->curmag = mag;
+	}
+
+	if (mag->nrounds == max_rounds) {
+		if (bin_mags->sparemag != NULL) {
+			if (bin_mags->sparemag->nrounds < max_rounds) {
+				/* Swap magazines. */
+				bin_mags->curmag = bin_mags->sparemag;
+				bin_mags->sparemag = mag;
+				mag = bin_mags->curmag;
+			} else {
+				/* Unload the current magazine. */
+				mag_unload(mag);
+			}
+		} else {
+			/* Create a second magazine. */
+			mag = mag_create(choose_arena(), binind);
+			if (mag == NULL) {
+				mag = rack->bin_mags[binind].curmag;
+				mag_unload(mag);
+			} else {
+				bin_mags->sparemag = bin_mags->curmag;
+				bin_mags->curmag = mag;
+			}
+		}
+		assert(mag->nrounds < max_rounds);
+	}
+	mag->rounds[mag->nrounds] = ptr;
+	mag->nrounds++;
 }
+#endif
 
 static void
+arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
+{
+	/* Large allocation. */
+	malloc_spin_lock(&arena->lock);
+
+#ifndef MALLOC_STATS
+	if (opt_junk)
+#endif
+	{
+		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
+		    PAGE_SHIFT;
+		size_t size = chunk->map[pageind].bits & ~PAGE_MASK;
+
+#ifdef MALLOC_STATS
+		if (opt_junk)
+#endif
+			memset(ptr, 0x5a, size);
+#ifdef MALLOC_STATS
+		arena->stats.allocated_large -= size;
+#endif
+	}
+#ifdef MALLOC_STATS
+	arena->stats.ndalloc_large++;
+#endif
+
+	arena_run_dalloc(arena, (arena_run_t *)ptr, true);
+	malloc_spin_unlock(&arena->lock);
+}
+
+static inline void
 arena_dalloc(arena_t *arena, arena_chunk_t *chunk, void *ptr)
 {
-	unsigned pageind;
+	size_t pageind;
 	arena_chunk_map_t *mapelm;
-	size_t size;
 
 	assert(arena != NULL);
 	assert(arena->magic == ARENA_MAGIC);
@@ -2432,90 +3846,220 @@
 	assert(ptr != NULL);
 	assert(CHUNK_ADDR2BASE(ptr) != ptr);
 
-	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> pagesize_2pow);
+	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
 	mapelm = &chunk->map[pageind];
-	if (mapelm->pos != 0 || ptr != (void *)((uintptr_t)chunk) + (pageind <<
-	    pagesize_2pow)) {
-		arena_run_t *run;
-		arena_bin_t *bin;
-
+	assert((mapelm->bits & CHUNK_MAP_ALLOCATED) != 0);
+	if ((mapelm->bits & CHUNK_MAP_LARGE) == 0) {
 		/* Small allocation. */
+#ifdef MALLOC_MAG
+		if (__isthreaded && opt_mag) {
+			mag_rack_t *rack = mag_rack;
+			if (rack == NULL) {
+				rack = mag_rack_create(arena);
+				if (rack == NULL) {
+					malloc_spin_lock(&arena->lock);
+					arena_dalloc_small(arena, chunk, ptr,
+					    mapelm);
+					malloc_spin_unlock(&arena->lock);
+				}
+				mag_rack = rack;
+			}
+			mag_rack_dalloc(rack, ptr);
+		} else {
+#endif
+			malloc_spin_lock(&arena->lock);
+			arena_dalloc_small(arena, chunk, ptr, mapelm);
+			malloc_spin_unlock(&arena->lock);
+#ifdef MALLOC_MAG
+		}
+#endif
+	} else
+		arena_dalloc_large(arena, chunk, ptr);
+}
 
-		pageind -= mapelm->pos;
+static inline void
+idalloc(void *ptr)
+{
+	arena_chunk_t *chunk;
 
-		run = (arena_run_t *)((uintptr_t)chunk + (pageind <<
-		    pagesize_2pow));
-		assert(run->magic == ARENA_RUN_MAGIC);
-		bin = run->bin;
-		size = bin->reg_size;
+	assert(ptr != NULL);
 
-		if (opt_junk)
-			memset(ptr, 0x5a, size);
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+	if (chunk != ptr)
+		arena_dalloc(chunk->arena, chunk, ptr);
+	else
+		huge_dalloc(ptr);
+}
 
-		malloc_mutex_lock(&arena->mtx);
-		arena_run_reg_dalloc(run, bin, ptr, size);
-		run->nfree++;
-
-		if (run->nfree == bin->nregs) {
-			/* Deallocate run. */
-			if (run == bin->runcur)
-				bin->runcur = NULL;
-			else if (bin->nregs != 1) {
-				/*
-				 * This block's conditional is necessary because
-				 * if the run only contains one region, then it
-				 * never gets inserted into the non-full runs
-				 * tree.
-				 */
-				RB_REMOVE(arena_run_tree_s, &bin->runs, run);
-			}
-#ifdef MALLOC_DEBUG
-			run->magic = 0;
+static void
+arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,
+    size_t size, size_t oldsize)
+{
+
+	assert(size < oldsize);
+
+	/*
+	 * Shrink the run, and make trailing pages available for other
+	 * allocations.
+	 */
+#ifdef MALLOC_BALANCE
+	arena_lock_balance(arena);
+#else
+	malloc_spin_lock(&arena->lock);
 #endif
-			arena_run_dalloc(arena, run, bin->run_size);
+	arena_run_trim_tail(arena, chunk, (arena_run_t *)ptr, oldsize, size,
+	    true);
 #ifdef MALLOC_STATS
-			bin->stats.curruns--;
+	arena->stats.allocated_large -= oldsize - size;
 #endif
-		} else if (run->nfree == 1 && run != bin->runcur) {
-			/*
-			 * Make sure that bin->runcur always refers to the
-			 * lowest non-full run, if one exists.
-			 */
-			if (bin->runcur == NULL)
-				bin->runcur = run;
-			else if ((uintptr_t)run < (uintptr_t)bin->runcur) {
-				/* Switch runcur. */
-				if (bin->runcur->nfree > 0) {
-					/* Insert runcur. */
-					RB_INSERT(arena_run_tree_s, &bin->runs,
-					    bin->runcur);
-				}
-				bin->runcur = run;
-			} else
-				RB_INSERT(arena_run_tree_s, &bin->runs, run);
-		}
+	malloc_spin_unlock(&arena->lock);
+}
+
+static bool
+arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,
+    size_t size, size_t oldsize)
+{
+	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT;
+	size_t npages = oldsize >> PAGE_SHIFT;
+
+	assert(oldsize == (chunk->map[pageind].bits & ~PAGE_MASK));
+
+	/* Try to extend the run. */
+	assert(size > oldsize);
+#ifdef MALLOC_BALANCE
+	arena_lock_balance(arena);
+#else
+	malloc_spin_lock(&arena->lock);
+#endif
+	if (pageind + npages < chunk_npages && (chunk->map[pageind+npages].bits
+	    & CHUNK_MAP_ALLOCATED) == 0 && (chunk->map[pageind+npages].bits &
+	    ~PAGE_MASK) >= size - oldsize) {
+		/*
+		 * The next run is available and sufficiently large.  Split the
+		 * following run, then merge the first part with the existing
+		 * allocation.
+		 */
+		arena_run_split(arena, (arena_run_t *)((uintptr_t)chunk +
+		    ((pageind+npages) << PAGE_SHIFT)), size - oldsize, true,
+		    false);
+
+		chunk->map[pageind].bits = size | CHUNK_MAP_LARGE |
+		    CHUNK_MAP_ALLOCATED;
+		chunk->map[pageind+npages].bits = CHUNK_MAP_LARGE |
+		    CHUNK_MAP_ALLOCATED;
+
 #ifdef MALLOC_STATS
-		arena->stats.allocated_small -= size;
-		arena->stats.ndalloc_small++;
+		arena->stats.allocated_large += size - oldsize;
 #endif
+		malloc_spin_unlock(&arena->lock);
+		return (false);
+	}
+	malloc_spin_unlock(&arena->lock);
+
+	return (true);
+}
+
+/*
+ * Try to resize a large allocation, in order to avoid copying.  This will
+ * always fail if growing an object, and the following run is already in use.
+ */
+static bool
+arena_ralloc_large(void *ptr, size_t size, size_t oldsize)
+{
+	size_t psize;
+
+	psize = PAGE_CEILING(size);
+	if (psize == oldsize) {
+		/* Same size class. */
+		if (opt_junk && size < oldsize) {
+			memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize -
+			    size);
+		}
+		return (false);
 	} else {
-		/* Large allocation. */
+		arena_chunk_t *chunk;
+		arena_t *arena;
 
-		size = mapelm->npages << pagesize_2pow;
-		assert((((uintptr_t)ptr) & pagesize_mask) == 0);
+		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+		arena = chunk->arena;
+		assert(arena->magic == ARENA_MAGIC);
+
+		if (psize < oldsize) {
+			/* Fill before shrinking in order avoid a race. */
+			if (opt_junk) {
+				memset((void *)((uintptr_t)ptr + size), 0x5a,
+				    oldsize - size);
+			}
+			arena_ralloc_large_shrink(arena, chunk, ptr, psize,
+			    oldsize);
+			return (false);
+		} else {
+			bool ret = arena_ralloc_large_grow(arena, chunk, ptr,
+			    psize, oldsize);
+			if (ret == false && opt_zero) {
+				memset((void *)((uintptr_t)ptr + oldsize), 0,
+				    size - oldsize);
+			}
+			return (ret);
+		}
+	}
+}
 
-		if (opt_junk)
-			memset(ptr, 0x5a, size);
+static void *
+arena_ralloc(void *ptr, size_t size, size_t oldsize)
+{
+	void *ret;
+	size_t copysize;
 
-		malloc_mutex_lock(&arena->mtx);
-		arena_run_dalloc(arena, (arena_run_t *)ptr, size);
-#ifdef MALLOC_STATS
-		arena->stats.allocated_large -= size;
-		arena->stats.ndalloc_large++;
-#endif
+	/* Try to avoid moving the allocation. */
+	if (size <= bin_maxclass) {
+		if (oldsize <= bin_maxclass && size2bin[size] ==
+		    size2bin[oldsize])
+			goto IN_PLACE;
+	} else {
+		if (oldsize > bin_maxclass && oldsize <= arena_maxclass) {
+			assert(size > bin_maxclass);
+			if (arena_ralloc_large(ptr, size, oldsize) == false)
+				return (ptr);
+		}
 	}
 
-	malloc_mutex_unlock(&arena->mtx);
+	/*
+	 * If we get here, then size and oldsize are different enough that we
+	 * need to move the object.  In that case, fall back to allocating new
+	 * space and copying.
+	 */
+	ret = arena_malloc(choose_arena(), size, false);
+	if (ret == NULL)
+		return (NULL);
+
+	/* Junk/zero-filling were already done by arena_malloc(). */
+	copysize = (size < oldsize) ? size : oldsize;
+	memcpy(ret, ptr, copysize);
+	idalloc(ptr);
+	return (ret);
+IN_PLACE:
+	if (opt_junk && size < oldsize)
+		memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize - size);
+	else if (opt_zero && size > oldsize)
+		memset((void *)((uintptr_t)ptr + oldsize), 0, size - oldsize);
+	return (ptr);
+}
+
+static inline void *
+iralloc(void *ptr, size_t size)
+{
+	size_t oldsize;
+
+	assert(ptr != NULL);
+	assert(size != 0);
+
+	oldsize = isalloc(ptr);
+
+	if (size <= arena_maxclass)
+		return (arena_ralloc(ptr, size, oldsize));
+	else
+		return (huge_ralloc(ptr, size, oldsize));
 }
 
 static bool
@@ -2523,28 +4067,39 @@
 {
 	unsigned i;
 	arena_bin_t *bin;
-	size_t pow2_size, prev_run_size;
+	size_t prev_run_size;
 
-	malloc_mutex_init(&arena->mtx);
+	if (malloc_spin_init(&arena->lock))
+		return (true);
 
 #ifdef MALLOC_STATS
 	memset(&arena->stats, 0, sizeof(arena_stats_t));
 #endif
 
 	/* Initialize chunks. */
-	RB_INIT(&arena->chunks);
+	arena_chunk_tree_dirty_new(&arena->chunks_dirty);
 	arena->spare = NULL;
 
+	arena->ndirty = 0;
+
+	arena_avail_tree_new(&arena->runs_avail);
+
+#ifdef MALLOC_BALANCE
+	arena->contention = 0;
+#endif
+
 	/* Initialize bins. */
-	prev_run_size = pagesize;
+	prev_run_size = PAGE_SIZE;
 
+	i = 0;
+#ifdef MALLOC_TINY
 	/* (2^n)-spaced tiny bins. */
-	for (i = 0; i < ntbins; i++) {
+	for (; i < ntbins; i++) {
 		bin = &arena->bins[i];
 		bin->runcur = NULL;
-		RB_INIT(&bin->runs);
+		arena_run_tree_new(&bin->runs);
 
-		bin->reg_size = (1 << (TINY_MIN_2POW + i));
+		bin->reg_size = (1U << (TINY_MIN_2POW + i));
 
 		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
 
@@ -2552,16 +4107,32 @@
 		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
 #endif
 	}
+#endif
 
 	/* Quantum-spaced bins. */
 	for (; i < ntbins + nqbins; i++) {
 		bin = &arena->bins[i];
 		bin->runcur = NULL;
-		RB_INIT(&bin->runs);
+		arena_run_tree_new(&bin->runs);
+
+		bin->reg_size = (i - ntbins + 1) << QUANTUM_2POW;
+
+		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
+
+#ifdef MALLOC_STATS
+		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
+#endif
+	}
+
+	/* Cacheline-spaced bins. */
+	for (; i < ntbins + nqbins + ncbins; i++) {
+		bin = &arena->bins[i];
+		bin->runcur = NULL;
+		arena_run_tree_new(&bin->runs);
 
-		bin->reg_size = quantum * (i - ntbins + 1);
+		bin->reg_size = cspace_min + ((i - (ntbins + nqbins)) <<
+		    CACHELINE_2POW);
 
-		pow2_size = pow2_ceil(quantum * (i - ntbins + 1));
 		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
 
 #ifdef MALLOC_STATS
@@ -2569,13 +4140,14 @@
 #endif
 	}
 
-	/* (2^n)-spaced sub-page bins. */
-	for (; i < ntbins + nqbins + nsbins; i++) {
+	/* Subpage-spaced bins. */
+	for (; i < nbins; i++) {
 		bin = &arena->bins[i];
 		bin->runcur = NULL;
-		RB_INIT(&bin->runs);
+		arena_run_tree_new(&bin->runs);
 
-		bin->reg_size = (small_max << (i - (ntbins + nqbins) + 1));
+		bin->reg_size = sspace_min + ((i - (ntbins + nqbins + ncbins))
+		    << SUBPAGE_2POW);
 
 		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
 
@@ -2584,41 +4156,130 @@
 #endif
 	}
 
-#ifdef MALLOC_DEBUG
-	arena->magic = ARENA_MAGIC;
-#endif
+#ifdef MALLOC_DEBUG
+	arena->magic = ARENA_MAGIC;
+#endif
+
+	return (false);
+}
+
+/* Create a new arena and insert it into the arenas array at index ind. */
+static arena_t *
+arenas_extend(unsigned ind)
+{
+	arena_t *ret;
+
+	/* Allocate enough space for trailing bins. */
+	ret = (arena_t *)base_alloc(sizeof(arena_t)
+	    + (sizeof(arena_bin_t) * (nbins - 1)));
+	if (ret != NULL && arena_new(ret) == false) {
+		arenas[ind] = ret;
+		return (ret);
+	}
+	/* Only reached if there is an OOM error. */
+
+	/*
+	 * OOM here is quite inconvenient to propagate, since dealing with it
+	 * would require a check for failure in the fast path.  Instead, punt
+	 * by using arenas[0].  In practice, this is an extremely unlikely
+	 * failure.
+	 */
+	_malloc_message(_getprogname(),
+	    ": (malloc) Error initializing arena\n", "", "");
+	if (opt_abort)
+		abort();
+
+	return (arenas[0]);
+}
+
+#ifdef MALLOC_MAG
+static mag_t *
+mag_create(arena_t *arena, size_t binind)
+{
+	mag_t *ret;
+
+	if (sizeof(mag_t) + (sizeof(void *) * (max_rounds - 1)) <=
+	    bin_maxclass) {
+		ret = arena_malloc_small(arena, sizeof(mag_t) + (sizeof(void *)
+		    * (max_rounds - 1)), false);
+	} else {
+		ret = imalloc(sizeof(mag_t) + (sizeof(void *) * (max_rounds -
+		    1)));
+	}
+	if (ret == NULL)
+		return (NULL);
+	ret->binind = binind;
+	ret->nrounds = 0;
+
+	return (ret);
+}
+
+static void
+mag_destroy(mag_t *mag)
+{
+	arena_t *arena;
+	arena_chunk_t *chunk;
+	size_t pageind;
+	arena_chunk_map_t *mapelm;
+
+	chunk = CHUNK_ADDR2BASE(mag);
+	arena = chunk->arena;
+	pageind = (((uintptr_t)mag - (uintptr_t)chunk) >> PAGE_SHIFT);
+	mapelm = &chunk->map[pageind];
+
+	assert(mag->nrounds == 0);
+	if (sizeof(mag_t) + (sizeof(void *) * (max_rounds - 1)) <=
+	    bin_maxclass) {
+		malloc_spin_lock(&arena->lock);
+		arena_dalloc_small(arena, chunk, mag, mapelm);
+		malloc_spin_unlock(&arena->lock);
+	} else
+		idalloc(mag);
+}
+
+static mag_rack_t *
+mag_rack_create(arena_t *arena)
+{
 
-	return (false);
+	assert(sizeof(mag_rack_t) + (sizeof(bin_mags_t *) * (nbins - 1)) <=
+	    bin_maxclass);
+	return (arena_malloc_small(arena, sizeof(mag_rack_t) +
+	    (sizeof(bin_mags_t) * (nbins - 1)), true));
 }
 
-/* Create a new arena and insert it into the arenas array at index ind. */
-static arena_t *
-arenas_extend(unsigned ind)
+static void
+mag_rack_destroy(mag_rack_t *rack)
 {
-	arena_t *ret;
+	arena_t *arena;
+	arena_chunk_t *chunk;
+	bin_mags_t *bin_mags;
+	size_t i, pageind;
+	arena_chunk_map_t *mapelm;
 
-	/* Allocate enough space for trailing bins. */
-	ret = (arena_t *)base_alloc(sizeof(arena_t)
-	    + (sizeof(arena_bin_t) * (ntbins + nqbins + nsbins - 1)));
-	if (ret != NULL && arena_new(ret) == false) {
-		arenas[ind] = ret;
-		return (ret);
+	for (i = 0; i < nbins; i++) {
+		bin_mags = &rack->bin_mags[i];
+		if (bin_mags->curmag != NULL) {
+			assert(bin_mags->curmag->binind == i);
+			mag_unload(bin_mags->curmag);
+			mag_destroy(bin_mags->curmag);
+		}
+		if (bin_mags->sparemag != NULL) {
+			assert(bin_mags->sparemag->binind == i);
+			mag_unload(bin_mags->sparemag);
+			mag_destroy(bin_mags->sparemag);
+		}
 	}
-	/* Only reached if there is an OOM error. */
 
-	/*
-	 * OOM here is quite inconvenient to propagate, since dealing with it
-	 * would require a check for failure in the fast path.  Instead, punt
-	 * by using arenas[0].  In practice, this is an extremely unlikely
-	 * failure.
-	 */
-	_malloc_message(_getprogname(),
-	    ": (malloc) Error initializing arena\n", "", "");
-	if (opt_abort)
-		abort();
+	chunk = CHUNK_ADDR2BASE(rack);
+	arena = chunk->arena;
+	pageind = (((uintptr_t)rack - (uintptr_t)chunk) >> PAGE_SHIFT);
+	mapelm = &chunk->map[pageind];
 
-	return (arenas[0]);
+	malloc_spin_lock(&arena->lock);
+	arena_dalloc_small(arena, chunk, rack, mapelm);
+	malloc_spin_unlock(&arena->lock);
 }
+#endif
 
 /*
  * End arena.
@@ -2629,11 +4290,11 @@
  */
 
 static void *
-huge_malloc(size_t size)
+huge_malloc(size_t size, bool zero)
 {
 	void *ret;
 	size_t csize;
-	chunk_node_t *node;
+	extent_node_t *node;
 
 	/* Allocate one or more contiguous chunks for this request. */
 
@@ -2643,33 +4304,35 @@
 		return (NULL);
 	}
 
-	/* Allocate a chunk node with which to track the chunk. */
-	node = base_chunk_node_alloc();
+	/* Allocate an extent node with which to track the chunk. */
+	node = base_node_alloc();
 	if (node == NULL)
 		return (NULL);
 
-	ret = chunk_alloc(csize);
+	ret = chunk_alloc(csize, zero);
 	if (ret == NULL) {
-		base_chunk_node_dealloc(node);
+		base_node_dealloc(node);
 		return (NULL);
 	}
 
 	/* Insert node into huge. */
-	node->chunk = ret;
+	node->addr = ret;
 	node->size = csize;
 
-	malloc_mutex_lock(&chunks_mtx);
-	RB_INSERT(chunk_tree_s, &huge, node);
+	malloc_mutex_lock(&huge_mtx);
+	extent_tree_ad_insert(&huge, node);
 #ifdef MALLOC_STATS
 	huge_nmalloc++;
 	huge_allocated += csize;
 #endif
-	malloc_mutex_unlock(&chunks_mtx);
+	malloc_mutex_unlock(&huge_mtx);
 
-	if (opt_junk)
-		memset(ret, 0xa5, csize);
-	else if (opt_zero)
-		memset(ret, 0, csize);
+	if (zero == false) {
+		if (opt_junk)
+			memset(ret, 0xa5, csize);
+		else if (opt_zero)
+			memset(ret, 0, csize);
+	}
 
 	return (ret);
 }
@@ -2680,7 +4343,7 @@
 {
 	void *ret;
 	size_t alloc_size, chunk_size, offset;
-	chunk_node_t *node;
+	extent_node_t *node;
 
 	/*
 	 * This allocation requires alignment that is even larger than chunk
@@ -2699,14 +4362,14 @@
 	else
 		alloc_size = (alignment << 1) - chunksize;
 
-	/* Allocate a chunk node with which to track the chunk. */
-	node = base_chunk_node_alloc();
+	/* Allocate an extent node with which to track the chunk. */
+	node = base_node_alloc();
 	if (node == NULL)
 		return (NULL);
 
-	ret = chunk_alloc(alloc_size);
+	ret = chunk_alloc(alloc_size, false);
 	if (ret == NULL) {
-		base_chunk_node_dealloc(node);
+		base_node_dealloc(node);
 		return (NULL);
 	}
 
@@ -2729,319 +4392,94 @@
 		if (trailsize != 0) {
 		    /* Trim trailing space. */
 		    assert(trailsize < alloc_size);
-		    chunk_dealloc((void *)((uintptr_t)ret + chunk_size),
-			trailsize);
-		}
-	}
-
-	/* Insert node into huge. */
-	node->chunk = ret;
-	node->size = chunk_size;
-
-	malloc_mutex_lock(&chunks_mtx);
-	RB_INSERT(chunk_tree_s, &huge, node);
-#ifdef MALLOC_STATS
-	huge_nmalloc++;
-	huge_allocated += chunk_size;
-#endif
-	malloc_mutex_unlock(&chunks_mtx);
-
-	if (opt_junk)
-		memset(ret, 0xa5, chunk_size);
-	else if (opt_zero)
-		memset(ret, 0, chunk_size);
-
-	return (ret);
-}
-
-static void *
-huge_ralloc(void *ptr, size_t size, size_t oldsize)
-{
-	void *ret;
-
-	/* Avoid moving the allocation if the size class would not change. */
-	if (oldsize > arena_maxclass &&
-	    CHUNK_CEILING(size) == CHUNK_CEILING(oldsize)) {
-		if (opt_junk && size < oldsize) {
-			memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize
-			    - size);
-		} else if (opt_zero && size > oldsize) {
-			memset((void *)((uintptr_t)ptr + oldsize), 0, size
-			    - oldsize);
-		}
-		return (ptr);
-	}
-
-	/*
-	 * If we get here, then size and oldsize are different enough that we
-	 * need to use a different size class.  In that case, fall back to
-	 * allocating new space and copying.
-	 */
-	ret = huge_malloc(size);
-	if (ret == NULL)
-		return (NULL);
-
-	if (CHUNK_ADDR2BASE(ptr) == ptr) {
-		/* The old allocation is a chunk. */
-		if (size < oldsize)
-			memcpy(ret, ptr, size);
-		else
-			memcpy(ret, ptr, oldsize);
-	} else {
-		/* The old allocation is a region. */
-		assert(oldsize < size);
-		memcpy(ret, ptr, oldsize);
-	}
-	idalloc(ptr);
-	return (ret);
-}
-
-static void
-huge_dalloc(void *ptr)
-{
-	chunk_node_t key;
-	chunk_node_t *node;
-
-	malloc_mutex_lock(&chunks_mtx);
-
-	/* Extract from tree of huge allocations. */
-	key.chunk = ptr;
-	node = RB_FIND(chunk_tree_s, &huge, &key);
-	assert(node != NULL);
-	assert(node->chunk == ptr);
-	RB_REMOVE(chunk_tree_s, &huge, node);
-
-#ifdef MALLOC_STATS
-	huge_ndalloc++;
-	huge_allocated -= node->size;
-#endif
-
-	malloc_mutex_unlock(&chunks_mtx);
-
-	/* Unmap chunk. */
-#ifdef USE_BRK
-	if (opt_junk)
-		memset(node->chunk, 0x5a, node->size);
-#endif
-	chunk_dealloc(node->chunk, node->size);
-
-	base_chunk_node_dealloc(node);
-}
-
-static void *
-imalloc(size_t size)
-{
-	void *ret;
-
-	assert(size != 0);
-
-	if (size <= arena_maxclass)
-		ret = arena_malloc(choose_arena(), size);
-	else
-		ret = huge_malloc(size);
-
-	return (ret);
-}
-
-static void *
-ipalloc(size_t alignment, size_t size)
-{
-	void *ret;
-	size_t ceil_size;
-
-	/*
-	 * Round size up to the nearest multiple of alignment.
-	 *
-	 * This done, we can take advantage of the fact that for each small
-	 * size class, every object is aligned at the smallest power of two
-	 * that is non-zero in the base two representation of the size.  For
-	 * example:
-	 *
-	 *   Size |   Base 2 | Minimum alignment
-	 *   -----+----------+------------------
-	 *     96 |  1100000 |  32
-	 *    144 | 10100000 |  32
-	 *    192 | 11000000 |  64
-	 *
-	 * Depending on runtime settings, it is possible that arena_malloc()
-	 * will further round up to a power of two, but that never causes
-	 * correctness issues.
-	 */
-	ceil_size = (size + (alignment - 1)) & (-alignment);
-	/*
-	 * (ceil_size < size) protects against the combination of maximal
-	 * alignment and size greater than maximal alignment.
-	 */
-	if (ceil_size < size) {
-		/* size_t overflow. */
-		return (NULL);
-	}
-
-	if (ceil_size <= pagesize || (alignment <= pagesize
-	    && ceil_size <= arena_maxclass))
-		ret = arena_malloc(choose_arena(), ceil_size);
-	else {
-		size_t run_size;
-
-		/*
-		 * We can't achieve sub-page alignment, so round up alignment
-		 * permanently; it makes later calculations simpler.
-		 */
-		alignment = PAGE_CEILING(alignment);
-		ceil_size = PAGE_CEILING(size);
-		/*
-		 * (ceil_size < size) protects against very large sizes within
-		 * pagesize of SIZE_T_MAX.
-		 *
-		 * (ceil_size + alignment < ceil_size) protects against the
-		 * combination of maximal alignment and ceil_size large enough
-		 * to cause overflow.  This is similar to the first overflow
-		 * check above, but it needs to be repeated due to the new
-		 * ceil_size value, which may now be *equal* to maximal
-		 * alignment, whereas before we only detected overflow if the
-		 * original size was *greater* than maximal alignment.
-		 */
-		if (ceil_size < size || ceil_size + alignment < ceil_size) {
-			/* size_t overflow. */
-			return (NULL);
-		}
-
-		/*
-		 * Calculate the size of the over-size run that arena_palloc()
-		 * would need to allocate in order to guarantee the alignment.
-		 */
-		if (ceil_size >= alignment)
-			run_size = ceil_size + alignment - pagesize;
-		else {
-			/*
-			 * It is possible that (alignment << 1) will cause
-			 * overflow, but it doesn't matter because we also
-			 * subtract pagesize, which in the case of overflow
-			 * leaves us with a very large run_size.  That causes
-			 * the first conditional below to fail, which means
-			 * that the bogus run_size value never gets used for
-			 * anything important.
-			 */
-			run_size = (alignment << 1) - pagesize;
-		}
-
-		if (run_size <= arena_maxclass) {
-			ret = arena_palloc(choose_arena(), alignment, ceil_size,
-			    run_size);
-		} else if (alignment <= chunksize)
-			ret = huge_malloc(ceil_size);
-		else
-			ret = huge_palloc(alignment, ceil_size);
-	}
-
-	assert(((uintptr_t)ret & (alignment - 1)) == 0);
-	return (ret);
-}
-
-static void *
-icalloc(size_t size)
-{
-	void *ret;
-
-	if (size <= arena_maxclass) {
-		ret = arena_malloc(choose_arena(), size);
-		if (ret == NULL)
-			return (NULL);
-		memset(ret, 0, size);
-	} else {
-		/*
-		 * The virtual memory system provides zero-filled pages, so
-		 * there is no need to do so manually, unless opt_junk is
-		 * enabled, in which case huge_malloc() fills huge allocations
-		 * with junk.
-		 */
-		ret = huge_malloc(size);
-		if (ret == NULL)
-			return (NULL);
-
-		if (opt_junk)
-			memset(ret, 0, size);
-#ifdef USE_BRK
-		else if ((uintptr_t)ret >= (uintptr_t)brk_base
-		    && (uintptr_t)ret < (uintptr_t)brk_max) {
-			/*
-			 * This may be a re-used brk chunk.  Therefore, zero
-			 * the memory.
-			 */
-			memset(ret, 0, size);
-		}
-#endif
-	}
-
-	return (ret);
-}
-
-static size_t
-isalloc(const void *ptr)
-{
-	size_t ret;
-	arena_chunk_t *chunk;
-
-	assert(ptr != NULL);
-
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr) {
-		/* Region. */
-		assert(chunk->arena->magic == ARENA_MAGIC);
-
-		ret = arena_salloc(ptr);
-	} else {
-		chunk_node_t *node, key;
-
-		/* Chunk (huge allocation). */
-
-		malloc_mutex_lock(&chunks_mtx);
+		    chunk_dealloc((void *)((uintptr_t)ret + chunk_size),
+			trailsize);
+		}
+	}
 
-		/* Extract from tree of huge allocations. */
-		key.chunk = __DECONST(void *, ptr);
-		node = RB_FIND(chunk_tree_s, &huge, &key);
-		assert(node != NULL);
+	/* Insert node into huge. */
+	node->addr = ret;
+	node->size = chunk_size;
 
-		ret = node->size;
+	malloc_mutex_lock(&huge_mtx);
+	extent_tree_ad_insert(&huge, node);
+#ifdef MALLOC_STATS
+	huge_nmalloc++;
+	huge_allocated += chunk_size;
+#endif
+	malloc_mutex_unlock(&huge_mtx);
 
-		malloc_mutex_unlock(&chunks_mtx);
-	}
+	if (opt_junk)
+		memset(ret, 0xa5, chunk_size);
+	else if (opt_zero)
+		memset(ret, 0, chunk_size);
 
 	return (ret);
 }
 
 static void *
-iralloc(void *ptr, size_t size)
+huge_ralloc(void *ptr, size_t size, size_t oldsize)
 {
 	void *ret;
-	size_t oldsize;
-
-	assert(ptr != NULL);
-	assert(size != 0);
+	size_t copysize;
 
-	oldsize = isalloc(ptr);
+	/* Avoid moving the allocation if the size class would not change. */
+	if (oldsize > arena_maxclass &&
+	    CHUNK_CEILING(size) == CHUNK_CEILING(oldsize)) {
+		if (opt_junk && size < oldsize) {
+			memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize
+			    - size);
+		} else if (opt_zero && size > oldsize) {
+			memset((void *)((uintptr_t)ptr + oldsize), 0, size
+			    - oldsize);
+		}
+		return (ptr);
+	}
 
-	if (size <= arena_maxclass)
-		ret = arena_ralloc(ptr, size, oldsize);
-	else
-		ret = huge_ralloc(ptr, size, oldsize);
+	/*
+	 * If we get here, then size and oldsize are different enough that we
+	 * need to use a different size class.  In that case, fall back to
+	 * allocating new space and copying.
+	 */
+	ret = huge_malloc(size, false);
+	if (ret == NULL)
+		return (NULL);
 
+	copysize = (size < oldsize) ? size : oldsize;
+	memcpy(ret, ptr, copysize);
+	idalloc(ptr);
 	return (ret);
 }
 
 static void
-idalloc(void *ptr)
+huge_dalloc(void *ptr)
 {
-	arena_chunk_t *chunk;
+	extent_node_t *node, key;
 
-	assert(ptr != NULL);
+	malloc_mutex_lock(&huge_mtx);
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr) {
-		/* Region. */
-		arena_dalloc(chunk->arena, chunk, ptr);
-	} else
-		huge_dalloc(ptr);
+	/* Extract from tree of huge allocations. */
+	key.addr = ptr;
+	node = extent_tree_ad_search(&huge, &key);
+	assert(node != NULL);
+	assert(node->addr == ptr);
+	extent_tree_ad_remove(&huge, node);
+
+#ifdef MALLOC_STATS
+	huge_ndalloc++;
+	huge_allocated -= node->size;
+#endif
+
+	malloc_mutex_unlock(&huge_mtx);
+
+	/* Unmap chunk. */
+#ifdef MALLOC_DSS
+	if (opt_dss && opt_junk)
+		memset(node->addr, 0x5a, node->size);
+#endif
+	chunk_dealloc(node->addr, node->size);
+
+	base_node_dealloc(node);
 }
 
 static void
@@ -3060,9 +4498,17 @@
 #endif
 		    "\n", "");
 		_malloc_message("Boolean MALLOC_OPTIONS: ",
-		    opt_abort ? "A" : "a",
-		    opt_junk ? "J" : "j",
-		    opt_hint ? "H" : "h");
+		    opt_abort ? "A" : "a", "", "");
+#ifdef MALLOC_DSS
+		_malloc_message(opt_dss ? "D" : "d", "", "", "");
+#endif
+#ifdef MALLOC_MAG
+		_malloc_message(opt_mag ? "G" : "g", "", "", "");
+#endif
+		_malloc_message(opt_junk ? "J" : "j", "", "", "");
+#ifdef MALLOC_DSS
+		_malloc_message(opt_mmap ? "M" : "m", "", "", "");
+#endif
 		_malloc_message(opt_utrace ? "PU" : "Pu",
 		    opt_sysv ? "V" : "v",
 		    opt_xmalloc ? "X" : "x",
@@ -3070,11 +4516,35 @@
 
 		_malloc_message("CPUs: ", umax2s(ncpus, s), "\n", "");
 		_malloc_message("Max arenas: ", umax2s(narenas, s), "\n", "");
+#ifdef MALLOC_BALANCE
+		_malloc_message("Arena balance threshold: ",
+		    umax2s(opt_balance_threshold, s), "\n", "");
+#endif
 		_malloc_message("Pointer size: ", umax2s(sizeof(void *), s),
 		    "\n", "");
-		_malloc_message("Quantum size: ", umax2s(quantum, s), "\n", "");
-		_malloc_message("Max small size: ", umax2s(small_max, s), "\n",
-		    "");
+		_malloc_message("Quantum size: ", umax2s(QUANTUM, s), "\n", "");
+		_malloc_message("Cacheline size (assumed): ", umax2s(CACHELINE,
+		    s), "\n", "");
+#ifdef MALLOC_TINY
+		_malloc_message("Tiny 2^n-spaced sizes: [", umax2s((1U <<
+		    TINY_MIN_2POW), s), "..", "");
+		_malloc_message(umax2s((qspace_min >> 1), s), "]\n", "", "");
+#endif
+		_malloc_message("Quantum-spaced sizes: [", umax2s(qspace_min,
+		    s), "..", "");
+		_malloc_message(umax2s(qspace_max, s), "]\n", "", "");
+		_malloc_message("Cacheline-spaced sizes: [", umax2s(cspace_min,
+		    s), "..", "");
+		_malloc_message(umax2s(cspace_max, s), "]\n", "", "");
+		_malloc_message("Subpage-spaced sizes: [", umax2s(sspace_min,
+		    s), "..", "");
+		_malloc_message(umax2s(sspace_max, s), "]\n", "", "");
+#ifdef MALLOC_MAG
+		_malloc_message("Rounds per magazine: ", umax2s(max_rounds, s),
+		    "\n", "");
+#endif
+		_malloc_message("Max dirty pages per arena: ",
+		    umax2s(opt_dirty_max, s), "\n", "");
 
 		_malloc_message("Chunk size: ", umax2s(chunksize, s), "", "");
 		_malloc_message(" (2^", umax2s(opt_chunk_2pow, s), ")\n", "");
@@ -3082,6 +4552,9 @@
 #ifdef MALLOC_STATS
 		{
 			size_t allocated, mapped;
+#ifdef MALLOC_BALANCE
+			uint64_t nbalance = 0;
+#endif
 			unsigned i;
 			arena_t *arena;
 
@@ -3090,20 +4563,23 @@
 			/* arenas. */
 			for (i = 0, allocated = 0; i < narenas; i++) {
 				if (arenas[i] != NULL) {
-					malloc_mutex_lock(&arenas[i]->mtx);
+					malloc_spin_lock(&arenas[i]->lock);
 					allocated +=
 					    arenas[i]->stats.allocated_small;
 					allocated +=
 					    arenas[i]->stats.allocated_large;
-					malloc_mutex_unlock(&arenas[i]->mtx);
+#ifdef MALLOC_BALANCE
+					nbalance += arenas[i]->stats.nbalance;
+#endif
+					malloc_spin_unlock(&arenas[i]->lock);
 				}
 			}
 
 			/* huge/base. */
-			malloc_mutex_lock(&chunks_mtx);
+			malloc_mutex_lock(&huge_mtx);
 			allocated += huge_allocated;
 			mapped = stats_chunks.curchunks * chunksize;
-			malloc_mutex_unlock(&chunks_mtx);
+			malloc_mutex_unlock(&huge_mtx);
 
 			malloc_mutex_lock(&base_mtx);
 			mapped += base_mapped;
@@ -3112,13 +4588,18 @@
 			malloc_printf("Allocated: %zu, mapped: %zu\n",
 			    allocated, mapped);
 
+#ifdef MALLOC_BALANCE
+			malloc_printf("Arena balance reassignments: %llu\n",
+			    nbalance);
+#endif
+
 			/* Print chunk stats. */
 			{
 				chunk_stats_t chunks_stats;
 
-				malloc_mutex_lock(&chunks_mtx);
+				malloc_mutex_lock(&huge_mtx);
 				chunks_stats = stats_chunks;
-				malloc_mutex_unlock(&chunks_mtx);
+				malloc_mutex_unlock(&huge_mtx);
 
 				malloc_printf("chunks: nchunks   "
 				    "highchunks    curchunks\n");
@@ -3132,8 +4613,7 @@
 			malloc_printf(
 			    "huge: nmalloc      ndalloc    allocated\n");
 			malloc_printf(" %12llu %12llu %12zu\n",
-			    huge_nmalloc, huge_ndalloc, huge_allocated
-			    * chunksize);
+			    huge_nmalloc, huge_ndalloc, huge_allocated);
 
 			/* Print stats for each arena. */
 			for (i = 0; i < narenas; i++) {
@@ -3141,9 +4621,9 @@
 				if (arena != NULL) {
 					malloc_printf(
 					    "\narenas[%u]:\n", i);
-					malloc_mutex_lock(&arena->mtx);
+					malloc_spin_lock(&arena->lock);
 					stats_print(arena);
-					malloc_mutex_unlock(&arena->mtx);
+					malloc_spin_unlock(&arena->lock);
 				}
 			}
 		}
@@ -3152,6 +4632,122 @@
 	}
 }
 
+#ifdef MALLOC_DEBUG
+static void
+size2bin_validate(void)
+{
+	size_t i, size, binind;
+
+	assert(size2bin[0] == 0xffU);
+	i = 1;
+#  ifdef MALLOC_TINY
+	/* Tiny. */
+	for (; i < (1U << TINY_MIN_2POW); i++) {
+		size = pow2_ceil(1U << TINY_MIN_2POW);
+		binind = ffs((int)(size >> (TINY_MIN_2POW + 1)));
+		assert(size2bin[i] == binind);
+	}
+	for (; i < qspace_min; i++) {
+		size = pow2_ceil(i);
+		binind = ffs((int)(size >> (TINY_MIN_2POW + 1)));
+		assert(size2bin[i] == binind);
+	}
+#  endif
+	/* Quantum-spaced. */
+	for (; i <= qspace_max; i++) {
+		size = QUANTUM_CEILING(i);
+		binind = ntbins + (size >> QUANTUM_2POW) - 1;
+		assert(size2bin[i] == binind);
+	}
+	/* Cacheline-spaced. */
+	for (; i <= cspace_max; i++) {
+		size = CACHELINE_CEILING(i);
+		binind = ntbins + nqbins + ((size - cspace_min) >>
+		    CACHELINE_2POW);
+		assert(size2bin[i] == binind);
+	}
+	/* Sub-page. */
+	for (; i <= sspace_max; i++) {
+		size = SUBPAGE_CEILING(i);
+		binind = ntbins + nqbins + ncbins + ((size - sspace_min)
+		    >> SUBPAGE_2POW);
+		assert(size2bin[i] == binind);
+	}
+}
+#endif
+
+static bool
+size2bin_init(void)
+{
+
+	if (opt_qspace_max_2pow != QSPACE_MAX_2POW_DEFAULT
+	    || opt_cspace_max_2pow != CSPACE_MAX_2POW_DEFAULT)
+		return (size2bin_init_hard());
+
+	size2bin = const_size2bin;
+#ifdef MALLOC_DEBUG
+	assert(sizeof(const_size2bin) == bin_maxclass + 1);
+	size2bin_validate();
+#endif
+	return (false);
+}
+
+static bool
+size2bin_init_hard(void)
+{
+	size_t i, size, binind;
+	uint8_t *custom_size2bin;
+
+	assert(opt_qspace_max_2pow != QSPACE_MAX_2POW_DEFAULT
+	    || opt_cspace_max_2pow != CSPACE_MAX_2POW_DEFAULT);
+
+	custom_size2bin = (uint8_t *)base_alloc(bin_maxclass + 1);
+	if (custom_size2bin == NULL)
+		return (true);
+
+	custom_size2bin[0] = 0xffU;
+	i = 1;
+#ifdef MALLOC_TINY
+	/* Tiny. */
+	for (; i < (1U << TINY_MIN_2POW); i++) {
+		size = pow2_ceil(1U << TINY_MIN_2POW);
+		binind = ffs((int)(size >> (TINY_MIN_2POW + 1)));
+		custom_size2bin[i] = binind;
+	}
+	for (; i < qspace_min; i++) {
+		size = pow2_ceil(i);
+		binind = ffs((int)(size >> (TINY_MIN_2POW + 1)));
+		custom_size2bin[i] = binind;
+	}
+#endif
+	/* Quantum-spaced. */
+	for (; i <= qspace_max; i++) {
+		size = QUANTUM_CEILING(i);
+		binind = ntbins + (size >> QUANTUM_2POW) - 1;
+		custom_size2bin[i] = binind;
+	}
+	/* Cacheline-spaced. */
+	for (; i <= cspace_max; i++) {
+		size = CACHELINE_CEILING(i);
+		binind = ntbins + nqbins + ((size - cspace_min) >>
+		    CACHELINE_2POW);
+		custom_size2bin[i] = binind;
+	}
+	/* Sub-page. */
+	for (; i <= sspace_max; i++) {
+		size = SUBPAGE_CEILING(i);
+		binind = ntbins + nqbins + ncbins + ((size - sspace_min) >>
+		    SUBPAGE_2POW);
+		custom_size2bin[i] = binind;
+	}
+
+	size2bin = custom_size2bin;
+#ifdef MALLOC_DEBUG
+	size2bin_validate();
+#endif
+	return (false);
+}
+
 /*
  * FreeBSD's pthreads implementation calls malloc(3), so the malloc
  * implementation has to take pains to avoid infinite recursion during
@@ -3170,7 +4766,7 @@
 static bool
 malloc_init_hard(void)
 {
-	unsigned i, j;
+	unsigned i;
 	int linklen;
 	char buf[PATH_MAX + 1];
 	const char *opts;
@@ -3199,24 +4795,9 @@
 		}
 	}
 
-	/* Get page size. */
-	{
-		long result;
-
-		result = sysconf(_SC_PAGESIZE);
-		assert(result != -1);
-		pagesize = (unsigned) result;
-
-		/*
-		 * We assume that pagesize is a power of 2 when calculating
-		 * pagesize_mask and pagesize_2pow.
-		 */
-		assert(((result - 1) & result) == 0);
-		pagesize_mask = result - 1;
-		pagesize_2pow = ffs((int)result) - 1;
-	}
-
 	for (i = 0; i < 3; i++) {
+		unsigned j;
+
 		/* Get runtime configuration. */
 		switch (i) {
 		case 0:
@@ -3250,10 +4831,11 @@
 			break;
 		case 2:
 			if (_malloc_options != NULL) {
-			    /*
-			     * Use options that were compiled into the program.
-			     */
-			    opts = _malloc_options;
+				/*
+				 * Use options that were compiled into the
+				 * program.
+				 */
+				opts = _malloc_options;
 			} else {
 				/* No configuration specified. */
 				buf[0] = '\0';
@@ -3266,153 +4848,258 @@
 		}
 
 		for (j = 0; opts[j] != '\0'; j++) {
-			switch (opts[j]) {
-			case 'a':
-				opt_abort = false;
-				break;
-			case 'A':
-				opt_abort = true;
-				break;
-			case 'h':
-				opt_hint = false;
-				break;
-			case 'H':
-				opt_hint = true;
-				break;
-			case 'j':
-				opt_junk = false;
-				break;
-			case 'J':
-				opt_junk = true;
-				break;
-			case 'k':
-				/*
-				 * Chunks always require at least one header
-				 * page, so chunks can never be smaller than
-				 * two pages.
-				 */
-				if (opt_chunk_2pow > pagesize_2pow + 1)
-					opt_chunk_2pow--;
-				break;
-			case 'K':
-				/*
-				 * There must be fewer pages in a chunk than
-				 * can be recorded by the pos field of
-				 * arena_chunk_map_t, in order to make POS_FREE
-				 * special.
-				 */
-				if (opt_chunk_2pow - pagesize_2pow
-				    < (sizeof(uint32_t) << 3) - 1)
-					opt_chunk_2pow++;
-				break;
-			case 'n':
-				opt_narenas_lshift--;
-				break;
-			case 'N':
-				opt_narenas_lshift++;
-				break;
-			case 'p':
-				opt_print_stats = false;
-				break;
-			case 'P':
-				opt_print_stats = true;
-				break;
-			case 'q':
-				if (opt_quantum_2pow > QUANTUM_2POW_MIN)
-					opt_quantum_2pow--;
-				break;
-			case 'Q':
-				if (opt_quantum_2pow < pagesize_2pow - 1)
-					opt_quantum_2pow++;
-				break;
-			case 's':
-				if (opt_small_max_2pow > QUANTUM_2POW_MIN)
-					opt_small_max_2pow--;
-				break;
-			case 'S':
-				if (opt_small_max_2pow < pagesize_2pow - 1)
-					opt_small_max_2pow++;
-				break;
-			case 'u':
-				opt_utrace = false;
-				break;
-			case 'U':
-				opt_utrace = true;
-				break;
-			case 'v':
-				opt_sysv = false;
-				break;
-			case 'V':
-				opt_sysv = true;
-				break;
-			case 'x':
-				opt_xmalloc = false;
-				break;
-			case 'X':
-				opt_xmalloc = true;
-				break;
-			case 'z':
-				opt_zero = false;
-				break;
-			case 'Z':
-				opt_zero = true;
-				break;
-			default: {
-				char cbuf[2];
-				
-				cbuf[0] = opts[j];
-				cbuf[1] = '\0';
-				_malloc_message(_getprogname(),
-				    ": (malloc) Unsupported character in "
-				    "malloc options: '", cbuf, "'\n");
+			unsigned k, nreps;
+			bool nseen;
+
+			/* Parse repetition count, if any. */
+			for (nreps = 0, nseen = false;; j++, nseen = true) {
+				switch (opts[j]) {
+					case '0': case '1': case '2': case '3':
+					case '4': case '5': case '6': case '7':
+					case '8': case '9':
+						nreps *= 10;
+						nreps += opts[j] - '0';
+						break;
+					default:
+						goto MALLOC_OUT;
+				}
 			}
+MALLOC_OUT:
+			if (nseen == false)
+				nreps = 1;
+
+			for (k = 0; k < nreps; k++) {
+				switch (opts[j]) {
+				case 'a':
+					opt_abort = false;
+					break;
+				case 'A':
+					opt_abort = true;
+					break;
+				case 'b':
+#ifdef MALLOC_BALANCE
+					opt_balance_threshold >>= 1;
+#endif
+					break;
+				case 'B':
+#ifdef MALLOC_BALANCE
+					if (opt_balance_threshold == 0)
+						opt_balance_threshold = 1;
+					else if ((opt_balance_threshold << 1)
+					    > opt_balance_threshold)
+						opt_balance_threshold <<= 1;
+#endif
+					break;
+				case 'c':
+					if (opt_cspace_max_2pow - 1 >
+					    opt_qspace_max_2pow &&
+					    opt_cspace_max_2pow >
+					    CACHELINE_2POW)
+						opt_cspace_max_2pow--;
+					break;
+				case 'C':
+					if (opt_cspace_max_2pow < PAGE_SHIFT
+					    - 1)
+						opt_cspace_max_2pow++;
+					break;
+				case 'd':
+#ifdef MALLOC_DSS
+					opt_dss = false;
+#endif
+					break;
+				case 'D':
+#ifdef MALLOC_DSS
+					opt_dss = true;
+#endif
+					break;
+				case 'f':
+					opt_dirty_max >>= 1;
+					break;
+				case 'F':
+					if (opt_dirty_max == 0)
+						opt_dirty_max = 1;
+					else if ((opt_dirty_max << 1) != 0)
+						opt_dirty_max <<= 1;
+					break;
+#ifdef MALLOC_MAG
+				case 'g':
+					opt_mag = false;
+					break;
+				case 'G':
+					opt_mag = true;
+					break;
+#endif
+				case 'j':
+					opt_junk = false;
+					break;
+				case 'J':
+					opt_junk = true;
+					break;
+				case 'k':
+					/*
+					 * Chunks always require at least one
+					 * header page, so chunks can never be
+					 * smaller than two pages.
+					 */
+					if (opt_chunk_2pow > PAGE_SHIFT + 1)
+						opt_chunk_2pow--;
+					break;
+				case 'K':
+					if (opt_chunk_2pow + 1 <
+					    (sizeof(size_t) << 3))
+						opt_chunk_2pow++;
+					break;
+				case 'm':
+#ifdef MALLOC_DSS
+					opt_mmap = false;
+#endif
+					break;
+				case 'M':
+#ifdef MALLOC_DSS
+					opt_mmap = true;
+#endif
+					break;
+				case 'n':
+					opt_narenas_lshift--;
+					break;
+				case 'N':
+					opt_narenas_lshift++;
+					break;
+				case 'p':
+					opt_print_stats = false;
+					break;
+				case 'P':
+					opt_print_stats = true;
+					break;
+				case 'q':
+					if (opt_qspace_max_2pow > QUANTUM_2POW)
+						opt_qspace_max_2pow--;
+					break;
+				case 'Q':
+					if (opt_qspace_max_2pow + 1 <
+					    opt_cspace_max_2pow)
+						opt_qspace_max_2pow++;
+					break;
+#ifdef MALLOC_MAG
+				case 'R':
+					if (opt_mag_size_2pow + 1 < (8U <<
+					    SIZEOF_PTR_2POW))
+						opt_mag_size_2pow++;
+					break;
+				case 'r':
+					/*
+					 * Make sure there's always at least
+					 * one round per magazine.
+					 */
+					if ((1U << (opt_mag_size_2pow-1)) >=
+					    sizeof(mag_t))
+						opt_mag_size_2pow--;
+					break;
+#endif
+				case 'u':
+					opt_utrace = false;
+					break;
+				case 'U':
+					opt_utrace = true;
+					break;
+				case 'v':
+					opt_sysv = false;
+					break;
+				case 'V':
+					opt_sysv = true;
+					break;
+				case 'x':
+					opt_xmalloc = false;
+					break;
+				case 'X':
+					opt_xmalloc = true;
+					break;
+				case 'z':
+					opt_zero = false;
+					break;
+				case 'Z':
+					opt_zero = true;
+					break;
+				default: {
+					char cbuf[2];
+
+					cbuf[0] = opts[j];
+					cbuf[1] = '\0';
+					_malloc_message(_getprogname(),
+					    ": (malloc) Unsupported character "
+					    "in malloc options: '", cbuf,
+					    "'\n");
+				}
+				}
 			}
 		}
 	}
 
+#ifdef MALLOC_DSS
+	/* Make sure that there is some method for acquiring memory. */
+	if (opt_dss == false && opt_mmap == false)
+		opt_mmap = true;
+#endif
+
 	/* Take care to call atexit() only once. */
 	if (opt_print_stats) {
 		/* Print statistics at exit. */
 		atexit(malloc_print_stats);
 	}
 
-	/* Set variables according to the value of opt_small_max_2pow. */
-	if (opt_small_max_2pow < opt_quantum_2pow)
-		opt_small_max_2pow = opt_quantum_2pow;
-	small_max = (1 << opt_small_max_2pow);
-
-	/* Set bin-related variables. */
-	bin_maxclass = (pagesize >> 1);
-	assert(opt_quantum_2pow >= TINY_MIN_2POW);
-	ntbins = opt_quantum_2pow - TINY_MIN_2POW;
-	assert(ntbins <= opt_quantum_2pow);
-	nqbins = (small_max >> opt_quantum_2pow);
-	nsbins = pagesize_2pow - opt_small_max_2pow - 1;
-
-	/* Set variables according to the value of opt_quantum_2pow. */
-	quantum = (1 << opt_quantum_2pow);
-	quantum_mask = quantum - 1;
-	if (ntbins > 0)
-		small_min = (quantum >> 1) + 1;
-	else
-		small_min = 1;
-	assert(small_min <= quantum);
+#ifdef MALLOC_MAG
+	/*
+	 * Calculate the actual number of rounds per magazine, taking into
+	 * account header overhead.
+	 */
+	max_rounds = (1LLU << (opt_mag_size_2pow - SIZEOF_PTR_2POW)) -
+	    (sizeof(mag_t) >> SIZEOF_PTR_2POW) + 1;
+#endif
+
+	/* Set variables according to the value of opt_[qc]space_max_2pow. */
+	qspace_max = (1U << opt_qspace_max_2pow);
+	cspace_min = CACHELINE_CEILING(qspace_max);
+	if (cspace_min == qspace_max)
+		cspace_min += CACHELINE;
+	cspace_max = (1U << opt_cspace_max_2pow);
+	sspace_min = SUBPAGE_CEILING(cspace_max);
+	if (sspace_min == cspace_max)
+		sspace_min += SUBPAGE;
+	assert(sspace_min < PAGE_SIZE);
+	sspace_max = PAGE_SIZE - SUBPAGE;
+
+#ifdef MALLOC_TINY
+	assert(QUANTUM_2POW >= TINY_MIN_2POW);
+#endif
+	assert(ntbins <= QUANTUM_2POW);
+	nqbins = qspace_max >> QUANTUM_2POW;
+	ncbins = ((cspace_max - cspace_min) >> CACHELINE_2POW) + 1;
+	nsbins = ((sspace_max - sspace_min) >> SUBPAGE_2POW) + 1;
+	nbins = ntbins + nqbins + ncbins + nsbins;
+
+	if (size2bin_init()) {
+		malloc_mutex_unlock(&init_lock);
+		return (true);
+	}
 
 	/* Set variables according to the value of opt_chunk_2pow. */
 	chunksize = (1LU << opt_chunk_2pow);
 	chunksize_mask = chunksize - 1;
-	chunk_npages = (chunksize >> pagesize_2pow);
+	chunk_npages = (chunksize >> PAGE_SHIFT);
 	{
-		unsigned header_size;
+		size_t header_size;
 
-		header_size = sizeof(arena_chunk_t) + (sizeof(arena_chunk_map_t)
-		    * (chunk_npages - 1));
-		arena_chunk_header_npages = (header_size >> pagesize_2pow);
-		if ((header_size & pagesize_mask) != 0)
-			arena_chunk_header_npages++;
+		/*
+		 * Compute the header size such that it is large enough to
+		 * contain the page map.
+		 */
+		header_size = sizeof(arena_chunk_t) +
+		    (sizeof(arena_chunk_map_t) * (chunk_npages - 1));
+		arena_chunk_header_npages = (header_size >> PAGE_SHIFT) +
+		    ((header_size & PAGE_MASK) != 0);
 	}
 	arena_maxclass = chunksize - (arena_chunk_header_npages <<
-	    pagesize_2pow);
+	    PAGE_SHIFT);
 
 	UTRACE(0, 0, 0);
 
@@ -3421,48 +5108,47 @@
 #endif
 
 	/* Various sanity checks that regard configuration. */
-	assert(quantum >= sizeof(void *));
-	assert(quantum <= pagesize);
-	assert(chunksize >= pagesize);
-	assert(quantum * 4 <= chunksize);
+	assert(chunksize >= PAGE_SIZE);
 
 	/* Initialize chunks data. */
-	malloc_mutex_init(&chunks_mtx);
-	RB_INIT(&huge);
-#ifdef USE_BRK
-	malloc_mutex_init(&brk_mtx);
-	brk_base = sbrk(0);
-	brk_prev = brk_base;
-	brk_max = brk_base;
+	malloc_mutex_init(&huge_mtx);
+	extent_tree_ad_new(&huge);
+#ifdef MALLOC_DSS
+	malloc_mutex_init(&dss_mtx);
+	dss_base = sbrk(0);
+	dss_prev = dss_base;
+	dss_max = dss_base;
+	extent_tree_szad_new(&dss_chunks_szad);
+	extent_tree_ad_new(&dss_chunks_ad);
 #endif
 #ifdef MALLOC_STATS
 	huge_nmalloc = 0;
 	huge_ndalloc = 0;
 	huge_allocated = 0;
 #endif
-	RB_INIT(&old_chunks);
 
 	/* Initialize base allocation data structures. */
 #ifdef MALLOC_STATS
 	base_mapped = 0;
 #endif
-#ifdef USE_BRK
+#ifdef MALLOC_DSS
 	/*
 	 * Allocate a base chunk here, since it doesn't actually have to be
 	 * chunk-aligned.  Doing this before allocating any other chunks allows
 	 * the use of space that would otherwise be wasted.
 	 */
-	base_pages_alloc(0);
+	if (opt_dss)
+		base_pages_alloc(0);
 #endif
-	base_chunk_nodes = NULL;
+	base_nodes = NULL;
 	malloc_mutex_init(&base_mtx);
 
 	if (ncpus > 1) {
 		/*
-		 * For SMP systems, create four times as many arenas as there
-		 * are CPUs by default.
+		 * For SMP systems, create twice as many arenas as there are
+		 * CPUs by default.
 		 */
-		opt_narenas_lshift += 2;
+		opt_narenas_lshift++;
 	}
 
 	/* Determine how many arenas to use. */
@@ -3471,18 +5157,24 @@
 		if ((narenas << opt_narenas_lshift) > narenas)
 			narenas <<= opt_narenas_lshift;
 		/*
-		 * Make sure not to exceed the limits of what base_malloc()
-		 * can handle.
+		 * Make sure not to exceed the limits of what base_alloc() can
+		 * handle.
 		 */
 		if (narenas * sizeof(arena_t *) > chunksize)
 			narenas = chunksize / sizeof(arena_t *);
 	} else if (opt_narenas_lshift < 0) {
-		if ((narenas << opt_narenas_lshift) < narenas)
-			narenas <<= opt_narenas_lshift;
+		if ((narenas >> -opt_narenas_lshift) < narenas)
+			narenas >>= -opt_narenas_lshift;
 		/* Make sure there is at least one arena. */
 		if (narenas == 0)
 			narenas = 1;
 	}
+#ifdef MALLOC_BALANCE
+	assert(narenas != 0);
+	for (narenas_2pow = 0;
+	     (narenas >> (narenas_2pow + 1)) != 0;
+	     narenas_2pow++);
+#endif
 
 #ifdef NO_TLS
 	if (narenas > 1) {
@@ -3512,7 +5204,9 @@
 #endif
 
 #ifndef NO_TLS
+#  ifndef MALLOC_BALANCE
 	next_arena = 0;
+#  endif
 #endif
 
 	/* Allocate and initialize arenas. */
@@ -3529,15 +5223,30 @@
 
 	/*
 	 * Initialize one arena here.  The rest are lazily created in
-	 * arena_choose_hard().
+	 * choose_arena_hard().
 	 */
 	arenas_extend(0);
 	if (arenas[0] == NULL) {
 		malloc_mutex_unlock(&init_lock);
 		return (true);
 	}
+#ifndef NO_TLS
+	/*
+	 * Assign the initial arena to the initial thread, in order to avoid
+	 * spurious creation of an extra arena if the application switches to
+	 * threaded mode.
+	 */
+	arenas_map = arenas[0];
+#endif
+	/*
+	 * Seed here for the initial thread, since choose_arena_hard() is only
+	 * called for other threads.  The seed value doesn't really matter.
+	 */
+#ifdef MALLOC_BALANCE
+	SPRN(balance, 42);
+#endif
 
-	malloc_mutex_init(&arenas_mtx);
+	malloc_spin_init(&arenas_lock);
 
 	malloc_initialized = true;
 	malloc_mutex_unlock(&init_lock);
@@ -3768,8 +5477,37 @@
  */
 /******************************************************************************/
 /*
- * Begin library-private functions, used by threading libraries for protection
- * of malloc during fork().  These functions are only called if the program is
+ * Begin library-private functions.
+ */
+
+/******************************************************************************/
+/*
+ * Begin thread cache.
+ */
+
+/*
+ * We provide an unpublished interface in order to receive notifications from
+ * the pthreads library whenever a thread exits.  This allows us to clean up
+ * thread caches.
+ */
+void
+_malloc_thread_cleanup(void)
+{
+
+#ifdef MALLOC_MAG
+	if (mag_rack != NULL) {
+		assert(mag_rack != (void *)-1);
+		mag_rack_destroy(mag_rack);
+#ifdef MALLOC_DEBUG
+		mag_rack = (void *)-1;
+#endif
+	}
+#endif
+}
+
+/*
+ * The following functions are used by threading libraries for protection of
+ * malloc during fork().  These functions are only called if the program is
  * running in threaded mode, so there is no need to check whether the program
  * is threaded here.
  */
@@ -3777,39 +5515,73 @@
 void
 _malloc_prefork(void)
 {
-	unsigned i;
+	bool again;
+	unsigned i, j;
+	arena_t *larenas[narenas], *tarenas[narenas];
 
 	/* Acquire all mutexes in a safe order. */
 
-	malloc_mutex_lock(&arenas_mtx);
-	for (i = 0; i < narenas; i++) {
-		if (arenas[i] != NULL)
-			malloc_mutex_lock(&arenas[i]->mtx);
-	}
-	malloc_mutex_unlock(&arenas_mtx);
+	/*
+	 * arenas_lock must be acquired after all of the arena mutexes, in
+	 * order to avoid potential deadlock with arena_lock_balance[_hard]().
+	 * Since arenas_lock protects the arenas array, the following code has
+	 * to race with arenas_extend() callers until it succeeds in locking
+	 * all arenas before locking arenas_lock.
+	 */
+	memset(larenas, 0, sizeof(arena_t *) * narenas);
+	do {
+		again = false;
+
+		malloc_spin_lock(&arenas_lock);
+		for (i = 0; i < narenas; i++) {
+			if (arenas[i] != larenas[i]) {
+				memcpy(tarenas, arenas, sizeof(arena_t *) *
+				    narenas);
+				malloc_spin_unlock(&arenas_lock);
+				for (j = 0; j < narenas; j++) {
+					if (larenas[j] != tarenas[j]) {
+						larenas[j] = tarenas[j];
+						malloc_spin_lock(
+						    &larenas[j]->lock);
+					}
+				}
+				again = true;
+				break;
+			}
+		}
+	} while (again);
 
 	malloc_mutex_lock(&base_mtx);
 
-	malloc_mutex_lock(&chunks_mtx);
+	malloc_mutex_lock(&huge_mtx);
+
+#ifdef MALLOC_DSS
+	malloc_mutex_lock(&dss_mtx);
+#endif
 }
 
 void
 _malloc_postfork(void)
 {
 	unsigned i;
+	arena_t *larenas[narenas];
 
 	/* Release all mutexes, now that fork() has completed. */
 
-	malloc_mutex_unlock(&chunks_mtx);
+#ifdef MALLOC_DSS
+	malloc_mutex_unlock(&dss_mtx);
+#endif
+
+	malloc_mutex_unlock(&huge_mtx);
 
 	malloc_mutex_unlock(&base_mtx);
 
-	malloc_mutex_lock(&arenas_mtx);
+	memcpy(larenas, arenas, sizeof(arena_t *) * narenas);
+	malloc_spin_unlock(&arenas_lock);
 	for (i = 0; i < narenas; i++) {
-		if (arenas[i] != NULL)
-			malloc_mutex_unlock(&arenas[i]->mtx);
+		if (larenas[i] != NULL)
+			malloc_spin_unlock(&larenas[i]->lock);
 	}
-	malloc_mutex_unlock(&arenas_mtx);
 }
 
 /*
