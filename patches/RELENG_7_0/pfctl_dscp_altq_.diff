Index: contrib/pf/pfctl/parse.y
===================================================================
RCS file: /home/eri/mine/FreeBSD/src/contrib/pf/pfctl/parse.y,v
retrieving revision 1.8
diff -u -r1.8 parse.y
--- contrib/pf/pfctl/parse.y	3 Jul 2007 12:30:02 -0000	1.8
+++ contrib/pf/pfctl/parse.y	7 Mar 2008 19:22:02 -0000
@@ -184,6 +184,7 @@
 #define FOM_TOS		0x04
 #define FOM_KEEP	0x08
 #define FOM_SRCTRACK	0x10
+#define FOM_DSCP	0x20
 	struct node_uid		*uid;
 	struct node_gid		*gid;
 	struct {
@@ -194,6 +195,7 @@
 	} flags;
 	struct node_icmp	*icmpspec;
 	u_int32_t		 tos;
+	u_int32_t		 dscp;
 	u_int32_t		 prob;
 	struct {
 		int			 action;
@@ -413,7 +415,7 @@
 %token	RETURNRST RETURNICMP RETURNICMP6 PROTO INET INET6 ALL ANY ICMPTYPE
 %token	ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINAT ARROW NODF
 %token	MINTTL ERROR ALLOWOPTS FASTROUTE FILENAME ROUTETO DUPTO REPLYTO NO LABEL
-%token	NOROUTE URPFFAILED FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DROP TABLE
+%token	NOROUTE URPFFAILED FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DSCP DROP TABLE
 %token	REASSEMBLE FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
 %token	SET OPTIMIZATION TIMEOUT LIMIT LOGINTERFACE BLOCKPOLICY RANDOMID
 %token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG SKIP HOSTID
@@ -429,7 +431,7 @@
 %token	<v.i>			PORTBINARY
 %type	<v.interface>		interface if_list if_item_not if_item
 %type	<v.number>		number icmptype icmp6type uid gid
-%type	<v.number>		tos not yesno
+%type	<v.number>		tos dscp not yesno
 %type	<v.i>			no dir af fragcache optimizer
 %type	<v.i>			sourcetrack flush unaryop statelock
 %type	<v.b>			action nataction natpass scrubaction
@@ -1756,7 +1758,14 @@
 #endif
 			}
 
-			r.tos = $9.tos;
+			if ($9.tos) {
+				r.tos = $9.tos;
+				r.rule_flag |= PFRULE_TOS;
+			}
+			if ($9.dscp) {
+				r.tos = $9.dscp;
+				r.rule_flag |= PFRULE_DSCP;
+			}
 			r.keep_state = $9.keep.action;
 
 			/* 'keep state' by default on pass rules. */
@@ -2094,6 +2103,14 @@
 			filter_opts.marker |= FOM_TOS;
 			filter_opts.tos = $1;
 		}
+		| dscp {
+			if (filter_opts.marker & FOM_DSCP) {
+				yyerror("dscp cannot be redefined");
+				YYERROR;
+			}
+			filter_opts.marker |= FOM_DSCP;
+			filter_opts.dscp = $1;
+		}
 		| keep {
 			if (filter_opts.marker & FOM_KEEP) {
 				yyerror("modulate or keep cannot be redefined");
@@ -3085,6 +3102,46 @@
 		}
 		;
 
+dscp		: DSCP STRING			{
+                        if (!strcmp($2, "EF"))
+                                $$ = DSCP_EF;
+                        else if (!strcmp($2, "af11"))
+                                $$ = DSCP_AF11;
+                        else if (!strcmp($2, "af12"))
+                                $$ = DSCP_AF12;
+                        else if (!strcmp($2, "af13"))
+                                $$ = DSCP_AF13;
+                        else if (!strcmp($2, "af21"))
+                                $$ = DSCP_AF21;
+                        else if (!strcmp($2, "af22"))
+                                $$ = DSCP_AF22;
+                        else if (!strcmp($2, "af23"))
+                                $$ = DSCP_AF23;
+                        else if (!strcmp($2, "af31"))
+                                $$ = DSCP_AF31;
+                        else if (!strcmp($2, "af32"))
+                                $$ = DSCP_AF32;
+                        else if (!strcmp($2, "af33"))
+                                $$ = DSCP_AF33;
+                        else if (!strcmp($2, "af41"))
+                                $$ = DSCP_AF41;
+                        else if (!strcmp($2, "af42"))
+                                $$ = DSCP_AF42;
+                        else if (!strcmp($2, "af43"))
+                                $$ = DSCP_AF43;
+                        else if ($2[0] == '0' && $2[1] == 'x')
+                                $$ = strtoul($2, NULL, 16);
+                        else
+                                $$ = strtoul($2, NULL, 10);
+                        if (!$$ || $$ > 64) {
+                                yyerror("illegal dscp value %s", $2);
+                                free($2);
+                                YYERROR;
+                        }
+                        free($2);
+                }
+		;
+
 sourcetrack	: SOURCETRACK		{ $$ = PF_SRCTRACK; }
 		| SOURCETRACK GLOBAL	{ $$ = PF_SRCTRACK_GLOBAL; }
 		| SOURCETRACK RULE	{ $$ = PF_SRCTRACK_RULE; }
@@ -4110,6 +4167,10 @@
 		yyerror("keep state on block rules doesn't make sense");
 		problems++;
 	}
+	if ((r->rule_flag & PFRULE_TOS) && (r->rule_flag & PFRULE_DSCP)) {
+		yyerror("tos and dscp cannot be used together");
+		problems++;
+	}
 	return (-problems);
 }
 
@@ -4902,6 +4963,7 @@
 		{ "debug",		DEBUG},
 		{ "drop",		DROP},
 		{ "drop-ovl",		FRAGDROP},
+		{ "dscp",		DSCP},
 		{ "dup-to",		DUPTO},
 		{ "fastroute",		FASTROUTE},
 		{ "file",		FILENAME},
Index: contrib/pf/pfctl/pfctl_altq.c
===================================================================
RCS file: /home/eri/mine/FreeBSD/src/contrib/pf/pfctl/pfctl_altq.c,v
retrieving revision 1.9
diff -u -r1.9 pfctl_altq.c
--- contrib/pf/pfctl/pfctl_altq.c	3 Jul 2007 12:30:02 -0000	1.9
+++ contrib/pf/pfctl/pfctl_altq.c	7 Mar 2008 19:19:29 -0000
@@ -690,13 +690,6 @@
 		return (-1);
 	}
 
-	if ((opts->rtsc_m1 < opts->rtsc_m2 && opts->rtsc_m1 != 0) ||
-	    (opts->lssc_m1 < opts->lssc_m2 && opts->lssc_m1 != 0) ||
-	    (opts->ulsc_m1 < opts->ulsc_m2 && opts->ulsc_m1 != 0)) {
-		warnx("m1 must be zero for convex curve: %s", pa->qname);
-		return (-1);
-	}
-
 	/*
 	 * admission control:
 	 * for the real-time service curve, the sum of the service curves
Index: contrib/pf/pfctl/pfctl_parser.c
===================================================================
RCS file: /home/eri/mine/FreeBSD/src/contrib/pf/pfctl/pfctl_parser.c,v
retrieving revision 1.8
diff -u -r1.8 pfctl_parser.c
--- contrib/pf/pfctl/pfctl_parser.c	3 Jul 2007 12:30:02 -0000	1.8
+++ contrib/pf/pfctl/pfctl_parser.c	7 Mar 2008 19:23:29 -0000
@@ -839,8 +839,10 @@
 				printf(" code %u", r->code-1);
 		}
 	}
-	if (r->tos)
-		printf(" tos 0x%2.2x", r->tos);
+        if (r->tos && (r->rule_flag & PFRULE_TOS))
+                printf(" tos 0x%2.2x", r->tos);
+         if (r->tos && (r->rule_flag & PFRULE_DSCP))
+                  printf(" dscp 0x%2.2x", r->tos & DSCP_MASK);
 	if (!r->keep_state && r->action == PF_PASS && !anchor_call[0])
 		printf(" no state");
 	else if (r->keep_state == PF_STATE_NORMAL)
Index: sys/contrib/pf/net/pf.c
===================================================================
RCS file: /home/eri/mine/FreeBSD/src/sys/contrib/pf/net/pf.c,v
retrieving revision 1.46.2.1
diff -u -r1.46.2.1 pf.c
--- sys/contrib/pf/net/pf.c	25 Nov 2007 19:26:46 -0000	1.46.2.1
+++ sys/contrib/pf/net/pf.c	7 Mar 2008 19:28:08 -0000
@@ -3305,8 +3305,10 @@
 		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
 		    r->dst.port[0], r->dst.port[1], th->th_dport))
 			r = r->skip[PF_SKIP_DST_PORT].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
-			r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
 		else if ((r->flagset & th->th_flags) != r->flags)
@@ -3727,8 +3729,10 @@
 		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
 		    r->dst.port[0], r->dst.port[1], uh->uh_dport))
 			r = r->skip[PF_SKIP_DST_PORT].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
-			r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
 		else if (r->uid.op && (pd->lookup.done || (pd->lookup.done =
@@ -4082,8 +4086,10 @@
 			r = TAILQ_NEXT(r, entries);
 		else if (r->code && r->code != icmpcode + 1)
 			r = TAILQ_NEXT(r, entries);
-		else if (r->tos && !(r->tos == pd->tos))
-			r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
 		else if (r->prob && r->prob <= arc4random())
@@ -4341,8 +4347,10 @@
 		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af,
 		    r->dst.neg, NULL))
 			r = r->skip[PF_SKIP_DST_ADDR].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
-			r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 		else if (r->rule_flag & PFRULE_FRAGMENT)
 			r = TAILQ_NEXT(r, entries);
 		else if (r->prob && r->prob <= arc4random())
@@ -4558,8 +4566,10 @@
 		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af,
 		    r->dst.neg, NULL))
 			r = r->skip[PF_SKIP_DST_ADDR].ptr;
-		else if (r->tos && !(r->tos == pd->tos))
-			r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_TOS) && r->tos && !(r->tos & pd->tos))
+                        r = TAILQ_NEXT(r, entries);
+                else if ((r->rule_flag & PFRULE_DSCP) && r->tos &&
+                        !(r->tos & (pd->tos & DSCP_MASK)))
 		else if (r->os_fingerprint != PF_OSFP_ANY)
 			r = TAILQ_NEXT(r, entries);
 		else if (pd->proto == IPPROTO_UDP &&
@@ -6983,7 +6993,7 @@
 
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
-		if (pqid || (pd.tos & IPTOS_LOWDELAY))
+		if (pqid || ((r->rule_flag & PFRULE_TOS) && pd.tos == IPTOS_LOWDELAY))
 			pd.pf_mtag->qid = r->pqid;
 		else
 			pd.pf_mtag->qid = r->qid;
@@ -7212,7 +7222,7 @@
 	PF_ACPY(&pd.baddr, dir == PF_OUT ? pd.src : pd.dst, AF_INET6);
 	pd.ip_sum = NULL;
 	pd.af = AF_INET6;
-	pd.tos = 0;
+	pd.tos = (ntohl(h->ip6_flow) >> 20) & DSCP_MASK;
 	pd.tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
 	pd.eh = eh;
 
@@ -7444,7 +7454,7 @@
 
 #ifdef ALTQ
 	if (action == PF_PASS && r->qid) {
-		if (pd.tos & IPTOS_LOWDELAY)
+		if ((r->rule_flag & PFRULE_TOS) && pd.tos == IPTOS_LOWDELAY)
 			pd.pf_mtag->qid = r->pqid;
 		else
 			pd.pf_mtag->qid = r->qid;
Index: sys/contrib/pf/net/pfvar.h
===================================================================
RCS file: /home/eri/mine/FreeBSD/src/sys/contrib/pf/net/pfvar.h,v
retrieving revision 1.16
diff -u -r1.16 pfvar.h
--- sys/contrib/pf/net/pfvar.h	3 Jul 2007 12:58:33 -0000	1.16
+++ sys/contrib/pf/net/pfvar.h	7 Mar 2008 19:30:23 -0000
@@ -672,6 +672,27 @@
 	u_int8_t		 allow_opts;
 	u_int8_t		 rt;
 	u_int8_t		 return_ttl;
+#ifndef DSCP_EF
+/* Copied from altq_cdnr.h */
+/* diffserve code points */
+#define DSCP_MASK       0xfc
+#define DSCP_CUMASK     0x03
+#define DSCP_EF         0xb8
+#define DSCP_AF11       0x28
+#define DSCP_AF12       0x30
+#define DSCP_AF13       0x38
+#define DSCP_AF21       0x48
+#define DSCP_AF22       0x50
+#define DSCP_AF23       0x58
+#define DSCP_AF31       0x68
+#define DSCP_AF32       0x70
+#define DSCP_AF33       0x78
+#define DSCP_AF41       0x88
+#define DSCP_AF42       0x90
+#define DSCP_AF43       0x98
+#define AF_CLASSMASK            0xe0
+#define AF_DROPPRECMASK         0x18
+#endif
 	u_int8_t		 tos;
 	u_int8_t		 anchor_relative;
 	u_int8_t		 anchor_wildcard;
@@ -698,6 +719,10 @@
 #define PFRULE_RANDOMID		0x0800
 #define PFRULE_REASSEMBLE_TCP	0x1000
 
+/* rule flags for TOS or DSCP differentiation */
+#define PFRULE_TOS		0x2000
+#define PFRULE_DSCP		0x4000
+
 /* rule flags again */
 #define PFRULE_IFBOUND		0x00010000	/* if-bound */
 

