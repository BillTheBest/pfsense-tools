Index: conf/files
===================================================================
RCS file: /home/ncvs/src/sys/conf/files,v
retrieving revision 1.1031.2.29
diff -u -p -r1.1031.2.29 files
--- conf/files	12 Apr 2006 17:45:24 -0000	1.1031.2.29
+++ conf/files	21 May 2006 21:43:16 -0000
@@ -1678,6 +1678,7 @@ netinet6/route6.c		optional inet6
 netinet6/scope6.c		optional inet6
 netinet6/udp6_output.c		optional inet6
 netinet6/udp6_usrreq.c		optional inet6
+netipsec/if_enc.c		optional fast_ipsec
 netipsec/ipsec.c		optional fast_ipsec
 netipsec/ipsec_input.c		optional fast_ipsec
 netipsec/ipsec_mbuf.c		optional fast_ipsec
Index: net/if_types.h
===================================================================
RCS file: /home/ncvs/src/sys/net/if_types.h,v
retrieving revision 1.21
diff -u -p -r1.21 if_types.h
--- net/if_types.h	10 Jun 2005 16:49:19 -0000	1.21
+++ net/if_types.h	21 May 2006 22:10:08 -0000
@@ -246,6 +246,7 @@
 #define	IFT_GIF		0xf0
 #define	IFT_PVC		0xf1
 #define	IFT_FAITH	0xf2
+#define	IFT_ENC		0xf4
 #define	IFT_PFLOG	0xf6
 #define	IFT_PFSYNC	0xf7
 #define	IFT_CARP	0xf8	/* Common Address Redundancy Protocol */
Index: netipsec/if_enc.c
===================================================================
RCS file: netipsec/if_enc.c
diff -N netipsec/if_enc.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ netipsec/if_enc.c	27 May 2006 03:29:41 -0000
@@ -0,0 +1,324 @@
+/*-
+ * Copyright (c) 2006 Andrew Thompson
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Broadcom Corporation nor the name of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written consent.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/module.h>
+#include <machine/bus.h>
+#include <sys/rman.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+
+#include <net/if.h>
+#include <net/if_clone.h>
+#include <net/if_types.h>
+#include <net/pfil.h>
+#include <net/route.h>
+#include <net/netisr.h>
+#include <net/bpf.h>
+#include <net/bpfdesc.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/in_var.h>
+#include "opt_inet6.h"
+
+#ifdef INET6
+#include <netinet/ip6.h>
+#include <netinet6/ip6_var.h>
+#endif
+
+#include <netipsec/ipsec.h>
+
+#define ENCMTU		(1024+512)
+#define ENC_HDRLEN	12
+
+/* XXX this define must have the same value as in OpenBSD */
+#define M_CONF		0x0400	/* payload was encrypted (ESP-transport) */
+#define M_AUTH		0x0800	/* payload was authenticated (AH or ESP auth) */
+#define M_AUTH_AH	0x2000	/* header was authenticated (AH) */
+
+struct enchdr {
+	u_int32_t af;
+	u_int32_t spi;
+	u_int32_t flags;
+};
+
+struct ifnet	*encif;
+struct mtx	enc_mtx;
+
+struct enc_softc {
+	struct	ifnet *sc_ifp;
+};
+
+int		encioctl(struct ifnet *, u_long, caddr_t);
+int		encoutput(struct ifnet *ifp, struct mbuf *m,
+		    struct sockaddr *dst, struct rtentry *rt);
+static int	enc_clone_create(struct if_clone *, int);
+static void	enc_clone_destroy(struct ifnet *);
+
+IFC_SIMPLE_DECLARE(enc, 0);
+
+static void
+enc_clone_destroy(struct ifnet *ifp)
+{
+
+	KASSERT(encif == ifp, ("%s: unknown ifnet", __func__));
+
+	mtx_lock(&enc_mtx);
+	encif = NULL;
+	mtx_unlock(&enc_mtx);
+
+	bpfdetach(ifp);
+	if_detach(ifp);
+	if_free(ifp);
+
+}
+
+static int
+enc_clone_create(struct if_clone *ifc, int unit)
+{
+	struct ifnet *ifp;
+	struct enc_softc *sc;
+
+	mtx_lock(&enc_mtx);
+	if (encif != NULL)
+		return (EBUSY);
+	mtx_unlock(&enc_mtx);
+
+	sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_ZERO);
+	ifp = sc->sc_ifp = if_alloc(IFT_ENC);
+	if (ifp == NULL) {
+		free(sc, M_DEVBUF);
+		return (ENOSPC);
+	}
+
+	if_initname(ifp, ifc->ifc_name, unit);
+	ifp->if_mtu = ENCMTU;
+	ifp->if_ioctl = encioctl;
+	ifp->if_output = encoutput;
+	ifp->if_snd.ifq_maxlen = ifqmaxlen;
+	ifp->if_softc = sc;
+	if_attach(ifp);
+	bpfattach(ifp, DLT_ENC, ENC_HDRLEN);
+
+	mtx_lock(&enc_mtx);
+	encif = ifp;
+	mtx_unlock(&enc_mtx);
+
+	return (0);
+}
+
+static int
+enc_modevent(module_t mod, int type, void *data)
+{
+	switch (type) {
+	case MOD_LOAD:
+		mtx_init(&enc_mtx, "enc mtx", NULL, MTX_DEF);
+		if_clone_attach(&enc_cloner);
+		break;
+	case MOD_UNLOAD:
+		printf("enc module unload - not possible for this module\n"); 
+		return (EINVAL);
+	default:
+		return (EOPNOTSUPP);
+	}
+	return (0);
+}
+
+static moduledata_t enc_mod = {
+	"enc",
+	enc_modevent,
+	0
+};
+
+DECLARE_MODULE(enc, enc_mod, SI_SUB_PROTO_IFATTACHDOMAIN, SI_ORDER_ANY);
+
+int
+encoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
+    struct rtentry *rt)
+{
+	m_freem(m);
+	return (0);
+}
+
+/*
+ * Process an ioctl request.
+ */
+/* ARGSUSED */
+int
+encioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	int error = 0;
+
+	switch (cmd) {
+
+	case SIOCSIFFLAGS:
+		if (ifp->if_flags & IFF_UP)
+			ifp->if_drv_flags |= IFF_DRV_RUNNING;
+		else
+			ifp->if_drv_flags &= ~IFF_DRV_RUNNING;
+
+		break;
+
+	default:
+		error = EINVAL;
+	}
+	return (error);
+}
+
+int
+ipsec_filter(struct mbuf **mp, int dir)
+{
+	int error, i;
+	struct ip *ip;
+
+	mtx_lock(&enc_mtx);
+	if (encif == NULL || (encif->if_drv_flags & IFF_DRV_RUNNING) == 0) {
+		mtx_unlock(&enc_mtx);
+		return (0);
+	}
+
+	i = min((*mp)->m_pkthdr.len, max_protohdr);
+	if ((*mp)->m_len < i) {
+		*mp = m_pullup(*mp, i);
+		if (*mp == NULL) {
+			printf("%s: m_pullup failed\n", __func__);
+			mtx_unlock(&enc_mtx);
+			return (-1);
+		}
+	}
+
+	/* Skip pfil(9) if no filters are loaded */
+	if (inet_pfil_hook.ph_busy_count < 0
+#ifdef INET6
+	    && inet6_pfil_hook.ph_busy_count < 0
+#endif
+	    ) {
+		mtx_unlock(&enc_mtx);
+		return (0);
+	}
+
+	error = 0;
+	ip = mtod(*mp, struct ip *);
+	switch (ip->ip_v) {
+		case IPPROTO_IPV4:
+			/*
+			 * before calling the firewall, swap fields the same as
+			 * IP does. here we assume the header is contiguous
+			 */
+			ip->ip_len = ntohs(ip->ip_len);
+			ip->ip_off = ntohs(ip->ip_off);
+
+			printf("passing to pfil from %s\n", encif->if_xname);
+			error = pfil_run_hooks(&inet_pfil_hook, mp,
+			    encif, dir, NULL);
+
+			if (*mp == NULL || error != 0)
+				break;
+
+			/* restore byte ordering */
+			ip = mtod(*mp, struct ip *);
+			ip->ip_len = htons(ip->ip_len);
+			ip->ip_off = htons(ip->ip_off);
+			break;
+
+#ifdef INET6
+		case IPPROTO_IPV6:
+			error = pfil_run_hooks(&inet6_pfil_hook, mp,
+			    encif, dir, NULL);
+			break;
+#endif
+		default:
+			printf("%s: unknown IP version\n", __func__);
+	}
+
+	mtx_unlock(&enc_mtx);
+	if (*mp == NULL)
+		return (error);
+	if (error != 0)
+		goto bad;
+
+	return (error);
+
+bad:
+	mtx_unlock(&enc_mtx);
+	m_freem(*mp);
+	*mp = NULL;
+	return (error);
+}
+
+void
+ipsec_bpf(struct mbuf *m, struct secasvar *sav, int af)
+{
+	int flags;
+	struct enchdr hdr;
+	struct mbuf m1;
+
+	KASSERT(sav != NULL, ("%s: sav is null", __func__));
+
+	mtx_lock(&enc_mtx);
+	if (encif == NULL || (encif->if_drv_flags & IFF_DRV_RUNNING) == 0) {
+		mtx_unlock(&enc_mtx);
+		return;
+	}
+
+	if (encif->if_bpf) {
+		flags = M_CONF;
+		/* XXX Check these flags 
+		if (sav->alg_auth != SADB_AALG_NONE)
+			flags |= M_AUTH;
+		*/
+
+		/*
+		 * We need to prepend the address family as a four byte
+		 * field.  Cons up a dummy header to pacify bpf.  This
+		 * is safe because bpf will only read from the mbuf
+		 * (i.e., it won't try to free it or keep a pointer a
+		 * to it).
+		 */
+		hdr.af = af;
+		hdr.spi = sav->spi;
+		hdr.flags = flags;
+
+		m1.m_flags = 0;
+		m1.m_next = m;
+		m1.m_len = ENC_HDRLEN;
+		m1.m_data = (char *) &hdr;
+
+		bpf_mtap(encif->if_bpf, &m1);
+	}
+	mtx_unlock(&enc_mtx);
+}
Index: netipsec/ipsec.h
===================================================================
RCS file: /home/ncvs/src/sys/netipsec/ipsec.h,v
retrieving revision 1.8.2.1
diff -u -p -r1.8.2.1 ipsec.h
--- netipsec/ipsec.h	23 Mar 2006 23:24:32 -0000	1.8.2.1
+++ netipsec/ipsec.h	27 May 2006 00:07:07 -0000
@@ -413,6 +413,9 @@ extern	void m_checkalignment(const char*
 extern	struct mbuf *m_makespace(struct mbuf *m0, int skip, int hlen, int *off);
 extern	caddr_t m_pad(struct mbuf *m, int n);
 extern	int m_striphdr(struct mbuf *m, int skip, int hlen);
+extern	int ipsec_filter(struct mbuf **, int);
+extern	void ipsec_bpf(struct mbuf *, struct secasvar *, int);
+
 #endif /* _KERNEL */
 
 #ifndef _KERNEL
Index: netipsec/ipsec_input.c
===================================================================
RCS file: /home/ncvs/src/sys/netipsec/ipsec_input.c,v
retrieving revision 1.9
diff -u -p -r1.9 ipsec_input.c
--- netipsec/ipsec_input.c	7 Jan 2005 01:45:46 -0000	1.9
+++ netipsec/ipsec_input.c	27 May 2006 00:04:31 -0000
@@ -445,6 +445,17 @@ ipsec4_common_input_cb(struct mbuf *m, s
 	key_sa_recordxfer(sav, m);		/* record data transfer */
 
 	/*
+	 * Pass the mbuf to enc0 for bpf and pfil. We will filter the IPIP
+	 * packet later after it has been decapsulated.
+	 */
+	ipsec_bpf(m, sav, AF_INET);
+
+	if (prot != IPPROTO_IPIP)
+		if ((error = ipsec_filter(&m, 1)) != 0)
+			return (error);
+
+
+	/*
 	 * Re-dispatch via software interrupt.
 	 */
 	if ((error = netisr_queue(NETISR_IP, m))) {
Index: netipsec/ipsec_output.c
===================================================================
RCS file: /home/ncvs/src/sys/netipsec/ipsec_output.c,v
retrieving revision 1.10
diff -u -p -r1.10 ipsec_output.c
--- netipsec/ipsec_output.c	20 Jan 2004 22:45:10 -0000	1.10
+++ netipsec/ipsec_output.c	27 May 2006 01:10:32 -0000
@@ -358,6 +358,11 @@ ipsec4_process_packet(
 		goto bad;
 
 	sav = isr->sav;
+
+	/* pass the mbuf to enc0 for packet filtering */
+	if ((error = ipsec_filter(&m, 2)) != 0)
+		goto bad;
+
 	if (!tunalready) {
 		union sockaddr_union *dst = &sav->sah->saidx.dst;
 		int setdf;
@@ -455,6 +460,9 @@ ipsec4_process_packet(
 		}
 	}
 
+	/* pass the mbuf to enc0 for bpf processing */
+	ipsec_bpf(m, sav, AF_INET);
+
 	/*
 	 * Dispatch to the appropriate IPsec transform logic.  The
 	 * packet will be returned for transmission after crypto
Index: netipsec/xform_ipip.c
===================================================================
RCS file: /home/ncvs/src/sys/netipsec/xform_ipip.c,v
retrieving revision 1.11.2.1
diff -u -p -r1.11.2.1 xform_ipip.c
--- netipsec/xform_ipip.c	1 Apr 2006 15:22:44 -0000	1.11.2.1
+++ netipsec/xform_ipip.c	26 May 2006 23:44:00 -0000
@@ -345,6 +345,9 @@ _ipip_input(struct mbuf *m, int iphlen, 
 	/* Statistics */
 	ipipstat.ipips_ibytes += m->m_pkthdr.len - iphlen;
 
+	if (ipsec_filter(&m, 1) != 0)
+		return;
+
 	/*
 	 * Interface pointer stays the same; if no IPsec processing has
 	 * been done (or will be done), this will point to a normal
