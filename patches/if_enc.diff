Index: conf/files
===================================================================
RCS file: /home/ncvs/src/sys/conf/files,v
retrieving revision 1.1031.2.29
diff -u -p -r1.1031.2.29 files
--- conf/files	12 Apr 2006 17:45:24 -0000	1.1031.2.29
+++ conf/files	21 May 2006 21:43:16 -0000
@@ -1678,6 +1678,7 @@ netinet6/route6.c		optional inet6
 netinet6/scope6.c		optional inet6
 netinet6/udp6_output.c		optional inet6
 netinet6/udp6_usrreq.c		optional inet6
+netipsec/if_enc.c		optional fast_ipsec
 netipsec/ipsec.c		optional fast_ipsec
 netipsec/ipsec_input.c		optional fast_ipsec
 netipsec/ipsec_mbuf.c		optional fast_ipsec
Index: net/if_types.h
===================================================================
RCS file: /home/ncvs/src/sys/net/if_types.h,v
retrieving revision 1.21
diff -u -p -r1.21 if_types.h
--- net/if_types.h	10 Jun 2005 16:49:19 -0000	1.21
+++ net/if_types.h	21 May 2006 22:10:08 -0000
@@ -246,6 +246,7 @@
 #define	IFT_GIF		0xf0
 #define	IFT_PVC		0xf1
 #define	IFT_FAITH	0xf2
+#define	IFT_ENC		0xf4
 #define	IFT_PFLOG	0xf6
 #define	IFT_PFSYNC	0xf7
 #define	IFT_CARP	0xf8	/* Common Address Redundancy Protocol */
Index: netipsec/if_enc.c
===================================================================
RCS file: netipsec/if_enc.c
diff -N netipsec/if_enc.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ netipsec/if_enc.c	24 May 2006 18:57:31 -0000
@@ -0,0 +1,278 @@
+/*-
+ * Copyright (c) 2006
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Broadcom Corporation nor the name of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written consent.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/module.h>
+#include <machine/bus.h>
+#include <sys/rman.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/sysctl.h>
+
+#include <net/if.h>
+#include <net/if_clone.h>
+#include <net/if_types.h>
+#include <net/pfil.h>
+#include <net/netisr.h>
+#include <net/bpf.h>
+#include <net/bpfdesc.h>
+
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/in_var.h>
+#include "opt_inet6.h"
+
+#ifdef INET6
+#include <netinet/ip6.h>
+#include <netinet6/ip6_var.h>
+#endif
+
+#define ENCMTU		(1024+512)
+#define ENC_HDRLEN	12
+
+int		ipsec_dofilter = 0;
+struct ifnet	*ipsec_encif;
+
+struct enchdr {
+	u_int32_t af;
+	u_int32_t spi;
+	u_int32_t flags;
+};
+
+struct enc_softc {
+	struct	ifnet *sc_ifp;
+};
+
+int		encioctl(struct ifnet *, u_long, caddr_t);
+int		encoutput(struct ifnet *ifp, struct mbuf *m,
+		    struct sockaddr *dst, struct rtentry *rt);
+static int	enc_clone_create(struct if_clone *, int);
+static void	enc_clone_destroy(struct ifnet *);
+int		ipsec_filter(struct mbuf **, int, int, int, int);
+
+IFC_SIMPLE_DECLARE(enc, 0);
+
+static void
+enc_clone_destroy(struct ifnet *ifp)
+{
+
+	KASSERT(ipsec_encif == ifp, ("%s: unknown ifnet", __func__));
+
+	/* XXX This needs locking */
+	ipsec_dofilter = 0;
+	ipsec_encif = NULL;
+
+	bpfdetach(ifp);
+	if_detach(ifp);
+	if_free(ifp);
+
+}
+
+static int
+enc_clone_create(struct if_clone *ifc, int unit)
+{
+	struct ifnet *ifp;
+	struct enc_softc *sc;
+
+	if (ipsec_encif != NULL)
+		return (EBUSY);
+
+	sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_ZERO);
+	ifp = sc->sc_ifp = if_alloc(IFT_ENC);
+	if (ifp == NULL) {
+		free(sc, M_DEVBUF);
+		return (ENOSPC);
+	}
+
+	if_initname(ifp, ifc->ifc_name, unit);
+	ifp->if_mtu = ENCMTU;
+	ifp->if_ioctl = encioctl;
+	ifp->if_output = encoutput;
+	ifp->if_snd.ifq_maxlen = ifqmaxlen;
+	ifp->if_softc = sc;
+	if_attach(ifp);
+	bpfattach(ifp, DLT_ENC, ENC_HDRLEN);
+	ipsec_encif = ifp;
+	ipsec_dofilter = 1;
+
+	return (0);
+}
+
+static int
+enc_modevent(module_t mod, int type, void *data) 
+{ 
+	switch (type) { 
+	case MOD_LOAD: 
+		if_clone_attach(&enc_cloner);
+		break; 
+	case MOD_UNLOAD:
+		/* not yet */
+	default:
+		return EOPNOTSUPP;
+	} 
+	return 0; 
+} 
+
+static moduledata_t enc_mod = { 
+	"enc", 
+	enc_modevent, 
+	0
+}; 
+
+DECLARE_MODULE(enc, enc_mod, SI_SUB_PROTO_IFATTACHDOMAIN, SI_ORDER_ANY);
+
+int
+encoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
+    struct rtentry *rt)
+{
+    m_freem(m);
+    return (0);
+}
+
+/*
+ * Process an ioctl request.
+ */
+/* ARGSUSED */
+int
+encioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	int error = 0;
+
+	switch (cmd) {
+
+	case SIOCSIFFLAGS:
+		if (ifp->if_flags & IFF_UP)
+			ifp->if_drv_flags |= IFF_DRV_RUNNING;
+		else
+			ifp->if_drv_flags &= ~IFF_DRV_RUNNING;
+
+		break;
+
+	default:
+		error = EINVAL;
+	}
+	return (error);
+}
+
+int
+ipsec_filter(struct mbuf **mp, int af, int spi, int flags, int dir)
+{
+	int error, i;
+	struct mbuf m1;
+	struct enchdr hdr;
+	struct ip *ip;
+
+	KASSERT(ipsec_encif != NULL, ("enc interface is null"));
+
+	if (ipsec_encif->if_bpf) {
+		/*
+		 * We need to prepend the address family as a four byte field.
+		 * Cons up a dummy header to pacify bpf.  This is safe because
+		 * bpf will only read from the mbuf (i.e., it won't try to free
+		 * it or keep a pointer a to it).
+		 */
+		hdr.af = af;
+		hdr.spi = spi;
+		hdr.flags = flags;
+
+		m1.m_flags = 0;
+		m1.m_next = *mp;
+		m1.m_len = ENC_HDRLEN;
+		m1.m_data = (char *) &hdr;
+
+		bpf_mtap(ipsec_encif->if_bpf, &m1);
+	}
+
+	i = min((*mp)->m_pkthdr.len, max_protohdr);
+	if ((*mp)->m_len < i) {
+		*mp = m_pullup(*mp, i);
+		if (*mp == NULL) {
+			printf("%s: m_pullup failed\n", __func__);
+			return (-1);
+		}
+	}
+
+	/* Skip pfil(9) if no filters are loaded */
+	if (inet_pfil_hook.ph_busy_count < 0
+#ifdef INET6
+	    && inet6_pfil_hook.ph_busy_count < 0
+#endif
+	    ) 
+		return (0);
+
+	error = 0;
+	ip = mtod(*mp, struct ip *);
+	switch (ip->ip_p) {
+		case IPPROTO_IPV4:
+			/*
+			 * before calling the firewall, swap fields the same as
+			 * IP does. here we assume the header is contiguous
+			 */
+			ip->ip_len = ntohs(ip->ip_len);
+			ip->ip_off = ntohs(ip->ip_off);
+
+			error = pfil_run_hooks(&inet_pfil_hook, mp,
+			    ipsec_encif, dir, NULL);
+
+			if (*mp == NULL || error != 0)
+				break;
+
+			/* restore byte ordering */
+			ip = mtod(*mp, struct ip *);
+			ip->ip_len = htons(ip->ip_len);
+			ip->ip_off = htons(ip->ip_off);
+			break;
+
+#ifdef INET6
+		case IPPROTO_IPV6:
+			error = pfil_run_hooks(&inet6_pfil_hook, mp,
+			    ipsec_encif, dir, NULL);
+			break;
+#endif
+	}
+
+	if (*mp == NULL)
+		return (error);
+	if (error != 0)
+		goto bad;
+		
+	return (error);
+
+bad:
+	m_freem(*mp);
+	*mp = NULL;
+	return (error);
+}
+
Index: netipsec/ipsec.h
===================================================================
RCS file: /home/ncvs/src/sys/netipsec/ipsec.h,v
retrieving revision 1.8.2.1
diff -u -p -r1.8.2.1 ipsec.h
--- netipsec/ipsec.h	23 Mar 2006 23:24:32 -0000	1.8.2.1
+++ netipsec/ipsec.h	23 May 2006 02:43:06 -0000
@@ -318,6 +318,12 @@ struct newipsecstat {
 }
 
 #ifdef _KERNEL
+
+/* XXX this define must have the same value as in OpenBSD */
+#define IPSEC_M_CONF		0x0400	/* payload was encrypted (ESP-transport) */
+#define IPSEC_M_AUTH		0x0800	/* payload was authenticated (AH or ESP auth) */
+#define IPSEC_M_AUTH_AH		0x2000	/* header was authenticated (AH) */
+
 struct ipsec_output_state {
 	struct mbuf *m;
 	struct route *ro;
@@ -330,6 +336,7 @@ struct ipsec_history {
 };
 
 extern int ipsec_debug;
+extern int ipsec_dofilter;
 
 extern struct newipsecstat newipsecstat;
 extern struct secpolicy ip4_def_policy;
@@ -413,6 +420,7 @@ extern	void m_checkalignment(const char*
 extern	struct mbuf *m_makespace(struct mbuf *m0, int skip, int hlen, int *off);
 extern	caddr_t m_pad(struct mbuf *m, int n);
 extern	int m_striphdr(struct mbuf *m, int skip, int hlen);
+extern	int ipsec_filter(struct mbuf **, int, int, int, int);
 #endif /* _KERNEL */
 
 #ifndef _KERNEL
Index: netipsec/ipsec_input.c
===================================================================
RCS file: /home/ncvs/src/sys/netipsec/ipsec_input.c,v
retrieving revision 1.9
diff -u -p -r1.9 ipsec_input.c
--- netipsec/ipsec_input.c	7 Jan 2005 01:45:46 -0000	1.9
+++ netipsec/ipsec_input.c	23 May 2006 21:51:01 -0000
@@ -444,6 +444,18 @@ ipsec4_common_input_cb(struct mbuf *m, s
 
 	key_sa_recordxfer(sav, m);		/* record data transfer */
 
+	/* pass the mbuf to enc0 for bpf and pfil */
+	if (ipsec_dofilter) {
+		int flags;
+		flags = IPSEC_M_CONF;
+		if ((m->m_flags & M_AUTHIPDGM) != 0)
+			flags |= IPSEC_M_AUTH;
+
+		if ((error = ipsec_filter(&m, af, sav->spi, flags, 1)) != 0)
+			return (error);
+	}
+
+
 	/*
 	 * Re-dispatch via software interrupt.
 	 */
Index: netipsec/ipsec_output.c
===================================================================
RCS file: /home/ncvs/src/sys/netipsec/ipsec_output.c,v
retrieving revision 1.10
diff -u -p -r1.10 ipsec_output.c
--- netipsec/ipsec_output.c	20 Jan 2004 22:45:10 -0000	1.10
+++ netipsec/ipsec_output.c	23 May 2006 21:51:35 -0000
@@ -358,6 +358,19 @@ ipsec4_process_packet(
 		goto bad;
 
 	sav = isr->sav;
+	/* pass the mbuf to enc0 for bpf and pfil */
+	if (ipsec_dofilter) {
+		int flags;
+		/* XXX Check these flags */
+		flags = IPSEC_M_CONF;
+		if (sav->alg_auth != SADB_AALG_NONE)
+			flags |= IPSEC_M_AUTH;
+
+		error = ipsec_filter(&m, AF_INET, sav->spi, flags, 2);
+		if (error != 0)
+			goto bad;
+	}
+
 	if (!tunalready) {
 		union sockaddr_union *dst = &sav->sah->saidx.dst;
 		int setdf;
@@ -533,6 +546,7 @@ ipsec6_output_trans(
 	int flags,
 	int *tun)
 {
+	struct secasvar *sav;
 	struct ipsecrequest *isr;
 	struct secasindex saidx;
 	int error = 0;
@@ -560,6 +574,20 @@ ipsec6_output_trans(
 	m = state->m;
 
 	isr = ipsec_nextisr(m, isr, AF_INET6, &saidx, &error);
+
+	sav = isr->sav;
+	/* pass the mbuf to enc0 for bpf and pfil */
+	if (ipsec_dofilter) {
+		int flags;
+		flags = IPSEC_M_CONF;
+		if (sav->alg_auth != SADB_AALG_NONE)
+			flags |= IPSEC_M_AUTH;
+
+		error = ipsec_filter(&m, AF_INET, sav->spi, flags, 2);
+		if (error != 0)
+			goto bad;
+	}
+
 	if (isr == NULL) {
 #ifdef notdef
 		/* XXX should notification be done for all errors ? */
